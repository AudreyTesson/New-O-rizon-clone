"use strict";
(self["webpackChunk"] = self["webpackChunk"] || []).push([["vendors-node_modules_tw-elements_dist_js_chartjs-plugin-datalabels_es_js"],{

/***/ "./node_modules/tw-elements/dist/js/chartjs-plugin-datalabels.es.js":
/*!**************************************************************************!*\
  !*** ./node_modules/tw-elements/dist/js/chartjs-plugin-datalabels.es.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Me)
/* harmony export */ });
/* harmony import */ var _chart_es_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chart.es.js */ "./node_modules/tw-elements/dist/js/chart.es.js");

/*!
 * chartjs-plugin-datalabels v2.2.0
 * https://chartjs-plugin-datalabels.netlify.app
 * (c) 2017-2022 chartjs-plugin-datalabels contributors
 * Released under the MIT license
 */
var D = function() {
  if (typeof window < "u") {
    if (window.devicePixelRatio)
      return window.devicePixelRatio;
    var e = window.screen;
    if (e)
      return (e.deviceXDPI || 1) / (e.logicalXDPI || 1);
  }
  return 1;
}(), m = {
  // @todo move this in Chart.helpers.toTextLines
  toTextLines: function(e) {
    var t = [], r;
    for (e = [].concat(e); e.length; )
      r = e.pop(), typeof r == "string" ? t.unshift.apply(t, r.split(`
`)) : Array.isArray(r) ? e.push.apply(e, r) : (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.i)(e) || t.unshift("" + r);
    return t;
  },
  // @todo move this in Chart.helpers.canvas.textSize
  // @todo cache calls of measureText if font doesn't change?!
  textSize: function(e, t, r) {
    var a = [].concat(t), i = a.length, n = e.font, o = 0, s;
    for (e.font = r.string, s = 0; s < i; ++s)
      o = Math.max(e.measureText(a[s]).width, o);
    return e.font = n, {
      height: i * r.lineHeight,
      width: o
    };
  },
  /**
   * Returns value bounded by min and max. This is equivalent to max(min, min(value, max)).
   * @todo move this method in Chart.helpers.bound
   * https://doc.qt.io/qt-5/qtglobal.html#qBound
   */
  bound: function(e, t, r) {
    return Math.max(e, Math.min(t, r));
  },
  /**
   * Returns an array of pair [value, state] where state is:
   * * -1: value is only in a0 (removed)
   * *  1: value is only in a1 (added)
   */
  arrayDiff: function(e, t) {
    var r = e.slice(), a = [], i, n, o, s;
    for (i = 0, o = t.length; i < o; ++i)
      s = t[i], n = r.indexOf(s), n === -1 ? a.push([s, 1]) : r.splice(n, 1);
    for (i = 0, o = r.length; i < o; ++i)
      a.push([r[i], -1]);
    return a;
  },
  /**
   * https://github.com/chartjs/chartjs-plugin-datalabels/issues/70
   */
  rasterize: function(e) {
    return Math.round(e * D) / D;
  }
};
function A(e, t) {
  var r = t.x, a = t.y;
  if (r === null)
    return { x: 0, y: -1 };
  if (a === null)
    return { x: 1, y: 0 };
  var i = e.x - r, n = e.y - a, o = Math.sqrt(i * i + n * n);
  return {
    x: o ? i / o : 0,
    y: o ? n / o : -1
  };
}
function ae(e, t, r, a, i) {
  switch (i) {
    case "center":
      r = a = 0;
      break;
    case "bottom":
      r = 0, a = 1;
      break;
    case "right":
      r = 1, a = 0;
      break;
    case "left":
      r = -1, a = 0;
      break;
    case "top":
      r = 0, a = -1;
      break;
    case "start":
      r = -r, a = -a;
      break;
    case "end":
      break;
    default:
      i *= Math.PI / 180, r = Math.cos(i), a = Math.sin(i);
      break;
  }
  return {
    x: e,
    y: t,
    vx: r,
    vy: a
  };
}
var te = 0, j = 1, N = 2, O = 4, F = 8;
function M(e, t, r) {
  var a = te;
  return e < r.left ? a |= j : e > r.right && (a |= N), t < r.top ? a |= F : t > r.bottom && (a |= O), a;
}
function ie(e, t) {
  for (var r = e.x0, a = e.y0, i = e.x1, n = e.y1, o = M(r, a, t), s = M(i, n, t), l, u, v; !(!(o | s) || o & s); )
    l = o || s, l & F ? (u = r + (i - r) * (t.top - a) / (n - a), v = t.top) : l & O ? (u = r + (i - r) * (t.bottom - a) / (n - a), v = t.bottom) : l & N ? (v = a + (n - a) * (t.right - r) / (i - r), u = t.right) : l & j && (v = a + (n - a) * (t.left - r) / (i - r), u = t.left), l === o ? (r = u, a = v, o = M(r, a, t)) : (i = u, n = v, s = M(i, n, t));
  return {
    x0: r,
    x1: i,
    y0: a,
    y1: n
  };
}
function P(e, t) {
  var r = t.anchor, a = e, i, n;
  return t.clamp && (a = ie(a, t.area)), r === "start" ? (i = a.x0, n = a.y0) : r === "end" ? (i = a.x1, n = a.y1) : (i = (a.x0 + a.x1) / 2, n = (a.y0 + a.y1) / 2), ae(i, n, e.vx, e.vy, t.align);
}
var E = {
  arc: function(e, t) {
    var r = (e.startAngle + e.endAngle) / 2, a = Math.cos(r), i = Math.sin(r), n = e.innerRadius, o = e.outerRadius;
    return P({
      x0: e.x + a * n,
      y0: e.y + i * n,
      x1: e.x + a * o,
      y1: e.y + i * o,
      vx: a,
      vy: i
    }, t);
  },
  point: function(e, t) {
    var r = A(e, t.origin), a = r.x * e.options.radius, i = r.y * e.options.radius;
    return P({
      x0: e.x - a,
      y0: e.y - i,
      x1: e.x + a,
      y1: e.y + i,
      vx: r.x,
      vy: r.y
    }, t);
  },
  bar: function(e, t) {
    var r = A(e, t.origin), a = e.x, i = e.y, n = 0, o = 0;
    return e.horizontal ? (a = Math.min(e.x, e.base), n = Math.abs(e.base - e.x)) : (i = Math.min(e.y, e.base), o = Math.abs(e.base - e.y)), P({
      x0: a,
      y0: i + o,
      x1: a + n,
      y1: i,
      vx: r.x,
      vy: r.y
    }, t);
  },
  fallback: function(e, t) {
    var r = A(e, t.origin);
    return P({
      x0: e.x,
      y0: e.y,
      x1: e.x + (e.width || 0),
      y1: e.y + (e.height || 0),
      vx: r.x,
      vy: r.y
    }, t);
  }
}, x = m.rasterize;
function ne(e) {
  var t = e.borderWidth || 0, r = e.padding, a = e.size.height, i = e.size.width, n = -i / 2, o = -a / 2;
  return {
    frame: {
      x: n - r.left - t,
      y: o - r.top - t,
      w: i + r.width + t * 2,
      h: a + r.height + t * 2
    },
    text: {
      x: n,
      y: o,
      w: i,
      h: a
    }
  };
}
function oe(e, t) {
  var r = t.chart.getDatasetMeta(t.datasetIndex).vScale;
  if (!r)
    return null;
  if (r.xCenter !== void 0 && r.yCenter !== void 0)
    return { x: r.xCenter, y: r.yCenter };
  var a = r.getBasePixel();
  return e.horizontal ? { x: a, y: null } : { x: null, y: a };
}
function se(e) {
  return e instanceof _chart_es_js__WEBPACK_IMPORTED_MODULE_0__.A ? E.arc : e instanceof _chart_es_js__WEBPACK_IMPORTED_MODULE_0__.P ? E.point : e instanceof _chart_es_js__WEBPACK_IMPORTED_MODULE_0__.B ? E.bar : E.fallback;
}
function le(e, t, r, a, i, n) {
  var o = Math.PI / 2;
  if (n) {
    var s = Math.min(n, i / 2, a / 2), l = t + s, u = r + s, v = t + a - s, d = r + i - s;
    e.moveTo(t, u), l < v && u < d ? (e.arc(l, u, s, -Math.PI, -o), e.arc(v, u, s, -o, 0), e.arc(v, d, s, 0, o), e.arc(l, d, s, o, Math.PI)) : l < v ? (e.moveTo(l, r), e.arc(v, u, s, -o, o), e.arc(l, u, s, o, Math.PI + o)) : u < d ? (e.arc(l, u, s, -Math.PI, 0), e.arc(l, d, s, 0, Math.PI)) : e.arc(l, u, s, -Math.PI, Math.PI), e.closePath(), e.moveTo(t, r);
  } else
    e.rect(t, r, a, i);
}
function ue(e, t, r) {
  var a = r.backgroundColor, i = r.borderColor, n = r.borderWidth;
  !a && (!i || !n) || (e.beginPath(), le(
    e,
    x(t.x) + n / 2,
    x(t.y) + n / 2,
    x(t.w) - n,
    x(t.h) - n,
    r.borderRadius
  ), e.closePath(), a && (e.fillStyle = a, e.fill()), i && n && (e.strokeStyle = i, e.lineWidth = n, e.lineJoin = "miter", e.stroke()));
}
function ve(e, t, r) {
  var a = r.lineHeight, i = e.w, n = e.x, o = e.y + a / 2;
  return t === "center" ? n += i / 2 : (t === "end" || t === "right") && (n += i), {
    h: a,
    w: i,
    x: n,
    y: o
  };
}
function de(e, t, r) {
  var a = e.shadowBlur, i = r.stroked, n = x(r.x), o = x(r.y), s = x(r.w);
  i && e.strokeText(t, n, o, s), r.filled && (a && i && (e.shadowBlur = 0), e.fillText(t, n, o, s), a && i && (e.shadowBlur = a));
}
function fe(e, t, r, a) {
  var i = a.textAlign, n = a.color, o = !!n, s = a.font, l = t.length, u = a.textStrokeColor, v = a.textStrokeWidth, d = u && v, y;
  if (!(!l || !o && !d))
    for (r = ve(r, i, s), e.font = s.string, e.textAlign = i, e.textBaseline = "middle", e.shadowBlur = a.textShadowBlur, e.shadowColor = a.textShadowColor, o && (e.fillStyle = n), d && (e.lineJoin = "round", e.lineWidth = v, e.strokeStyle = u), y = 0, l = t.length; y < l; ++y)
      de(e, t[y], {
        stroked: d,
        filled: o,
        w: r.w,
        x: r.x,
        y: r.y + r.h * y
      });
}
var L = function(e, t, r, a) {
  var i = this;
  i._config = e, i._index = a, i._model = null, i._rects = null, i._ctx = t, i._el = r;
};
(0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.m)(L.prototype, {
  /**
   * @private
   */
  _modelize: function(e, t, r, a) {
    var i = this, n = i._index, o = (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.t)((0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.r)([r.font, {}], a, n)), s = (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.r)([r.color, _chart_es_js__WEBPACK_IMPORTED_MODULE_0__.d.color], a, n);
    return {
      align: (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.r)([r.align, "center"], a, n),
      anchor: (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.r)([r.anchor, "center"], a, n),
      area: a.chart.chartArea,
      backgroundColor: (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.r)([r.backgroundColor, null], a, n),
      borderColor: (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.r)([r.borderColor, null], a, n),
      borderRadius: (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.r)([r.borderRadius, 0], a, n),
      borderWidth: (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.r)([r.borderWidth, 0], a, n),
      clamp: (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.r)([r.clamp, !1], a, n),
      clip: (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.r)([r.clip, !1], a, n),
      color: s,
      display: e,
      font: o,
      lines: t,
      offset: (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.r)([r.offset, 4], a, n),
      opacity: (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.r)([r.opacity, 1], a, n),
      origin: oe(i._el, a),
      padding: (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.a)((0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.r)([r.padding, 4], a, n)),
      positioner: se(i._el),
      rotation: (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.r)([r.rotation, 0], a, n) * (Math.PI / 180),
      size: m.textSize(i._ctx, t, o),
      textAlign: (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.r)([r.textAlign, "start"], a, n),
      textShadowBlur: (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.r)([r.textShadowBlur, 0], a, n),
      textShadowColor: (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.r)([r.textShadowColor, s], a, n),
      textStrokeColor: (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.r)([r.textStrokeColor, s], a, n),
      textStrokeWidth: (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.r)([r.textStrokeWidth, 0], a, n)
    };
  },
  update: function(e) {
    var t = this, r = null, a = null, i = t._index, n = t._config, o, s, l, u = (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.r)([n.display, !0], e, i);
    u && (o = e.dataset.data[i], s = (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.v)((0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.c)(n.formatter, [o, e]), o), l = (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.i)(s) ? [] : m.toTextLines(s), l.length && (r = t._modelize(u, l, n, e), a = ne(r))), t._model = r, t._rects = a;
  },
  geometry: function() {
    return this._rects ? this._rects.frame : {};
  },
  rotation: function() {
    return this._model ? this._model.rotation : 0;
  },
  visible: function() {
    return this._model && this._model.opacity;
  },
  model: function() {
    return this._model;
  },
  draw: function(e, t) {
    var r = this, a = e.ctx, i = r._model, n = r._rects, o;
    this.visible() && (a.save(), i.clip && (o = i.area, a.beginPath(), a.rect(
      o.left,
      o.top,
      o.right - o.left,
      o.bottom - o.top
    ), a.clip()), a.globalAlpha = m.bound(0, i.opacity, 1), a.translate(x(t.x), x(t.y)), a.rotate(i.rotation), ue(a, n.frame, i), fe(a, i.lines, n.text, i), a.restore());
  }
});
var he = Number.MIN_SAFE_INTEGER || -9007199254740991, ye = Number.MAX_SAFE_INTEGER || 9007199254740991;
function b(e, t, r) {
  var a = Math.cos(r), i = Math.sin(r), n = t.x, o = t.y;
  return {
    x: n + a * (e.x - n) - i * (e.y - o),
    y: o + i * (e.x - n) + a * (e.y - o)
  };
}
function W(e, t) {
  var r = ye, a = he, i = t.origin, n, o, s, l, u;
  for (n = 0; n < e.length; ++n)
    o = e[n], s = o.x - i.x, l = o.y - i.y, u = t.vx * s + t.vy * l, r = Math.min(r, u), a = Math.max(a, u);
  return {
    min: r,
    max: a
  };
}
function I(e, t) {
  var r = t.x - e.x, a = t.y - e.y, i = Math.sqrt(r * r + a * a);
  return {
    vx: (t.x - e.x) / i,
    vy: (t.y - e.y) / i,
    origin: e,
    ln: i
  };
}
var G = function() {
  this._rotation = 0, this._rect = {
    x: 0,
    y: 0,
    w: 0,
    h: 0
  };
};
(0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.m)(G.prototype, {
  center: function() {
    var e = this._rect;
    return {
      x: e.x + e.w / 2,
      y: e.y + e.h / 2
    };
  },
  update: function(e, t, r) {
    this._rotation = r, this._rect = {
      x: t.x + e.x,
      y: t.y + e.y,
      w: t.w,
      h: t.h
    };
  },
  contains: function(e) {
    var t = this, r = 1, a = t._rect;
    return e = b(e, t.center(), -t._rotation), !(e.x < a.x - r || e.y < a.y - r || e.x > a.x + a.w + r * 2 || e.y > a.y + a.h + r * 2);
  },
  // Separating Axis Theorem
  // https://gamedevelopment.tutsplus.com/tutorials/collision-detection-using-the-separating-axis-theorem--gamedev-169
  intersects: function(e) {
    var t = this._points(), r = e._points(), a = [
      I(t[0], t[1]),
      I(t[0], t[3])
    ], i, n, o;
    for (this._rotation !== e._rotation && a.push(
      I(r[0], r[1]),
      I(r[0], r[3])
    ), i = 0; i < a.length; ++i)
      if (n = W(t, a[i]), o = W(r, a[i]), n.max < o.min || o.max < n.min)
        return !1;
    return !0;
  },
  /**
   * @private
   */
  _points: function() {
    var e = this, t = e._rect, r = e._rotation, a = e.center();
    return [
      b({ x: t.x, y: t.y }, a, r),
      b({ x: t.x + t.w, y: t.y }, a, r),
      b({ x: t.x + t.w, y: t.y + t.h }, a, r),
      b({ x: t.x, y: t.y + t.h }, a, r)
    ];
  }
});
function H(e, t, r) {
  var a = t.positioner(e, t), i = a.vx, n = a.vy;
  if (!i && !n)
    return { x: a.x, y: a.y };
  var o = r.w, s = r.h, l = t.rotation, u = Math.abs(o / 2 * Math.cos(l)) + Math.abs(s / 2 * Math.sin(l)), v = Math.abs(o / 2 * Math.sin(l)) + Math.abs(s / 2 * Math.cos(l)), d = 1 / Math.max(Math.abs(i), Math.abs(n));
  return u *= i * d, v *= n * d, u += t.offset * i, v += t.offset * n, {
    x: a.x + u,
    y: a.y + v
  };
}
function xe(e, t) {
  var r, a, i, n;
  for (r = e.length - 1; r >= 0; --r)
    for (i = e[r].$layout, a = r - 1; a >= 0 && i._visible; --a)
      n = e[a].$layout, n._visible && i._box.intersects(n._box) && t(i, n);
  return e;
}
function _e(e) {
  var t, r, a, i, n, o, s;
  for (t = 0, r = e.length; t < r; ++t)
    a = e[t], i = a.$layout, i._visible && (s = new Proxy(a._el, { get: (l, u) => l.getProps([u], !0)[u] }), n = a.geometry(), o = H(s, a.model(), n), i._box.update(o, n, a.rotation()));
  return xe(e, function(l, u) {
    var v = l._hidable, d = u._hidable;
    v && d || d ? u._visible = !1 : v && (l._visible = !1);
  });
}
var w = {
  prepare: function(e) {
    var t = [], r, a, i, n, o;
    for (r = 0, i = e.length; r < i; ++r)
      for (a = 0, n = e[r].length; a < n; ++a)
        o = e[r][a], t.push(o), o.$layout = {
          _box: new G(),
          _hidable: !1,
          _visible: !0,
          _set: r,
          _idx: o._index
        };
    return t.sort(function(s, l) {
      var u = s.$layout, v = l.$layout;
      return u._idx === v._idx ? v._set - u._set : v._idx - u._idx;
    }), this.update(t), t;
  },
  update: function(e) {
    var t = !1, r, a, i, n, o;
    for (r = 0, a = e.length; r < a; ++r)
      i = e[r], n = i.model(), o = i.$layout, o._hidable = n && n.display === "auto", o._visible = i.visible(), t |= o._hidable;
    t && _e(e);
  },
  lookup: function(e, t) {
    var r, a;
    for (r = e.length - 1; r >= 0; --r)
      if (a = e[r].$layout, a && a._visible && a._box.contains(t))
        return e[r];
    return null;
  },
  draw: function(e, t) {
    var r, a, i, n, o, s;
    for (r = 0, a = t.length; r < a; ++r)
      i = t[r], n = i.$layout, n._visible && (o = i.geometry(), s = H(i._el, i.model(), o), n._box.update(s, o, i.rotation()), i.draw(e, s));
  }
}, ce = function(e) {
  if ((0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.i)(e))
    return null;
  var t = e, r, a, i;
  if ((0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.b)(e))
    if (!(0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.i)(e.label))
      t = e.label;
    else if (!(0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.i)(e.r))
      t = e.r;
    else
      for (t = "", r = Object.keys(e), i = 0, a = r.length; i < a; ++i)
        t += (i !== 0 ? ", " : "") + r[i] + ": " + e[r[i]];
  return "" + t;
}, be = {
  align: "center",
  anchor: "center",
  backgroundColor: null,
  borderColor: null,
  borderRadius: 0,
  borderWidth: 0,
  clamp: !1,
  clip: !1,
  color: void 0,
  display: !0,
  font: {
    family: void 0,
    lineHeight: 1.2,
    size: void 0,
    style: void 0,
    weight: null
  },
  formatter: ce,
  labels: void 0,
  listeners: {},
  offset: 4,
  opacity: 1,
  padding: {
    top: 4,
    right: 4,
    bottom: 4,
    left: 4
  },
  rotation: 0,
  textAlign: "start",
  textStrokeColor: void 0,
  textStrokeWidth: 0,
  textShadowBlur: 0,
  textShadowColor: void 0
}, h = "$datalabels", U = "$default";
function pe(e, t) {
  var r = e.datalabels, a = {}, i = [], n, o;
  return r === !1 ? null : (r === !0 && (r = {}), t = (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.m)({}, [t, r]), n = t.labels || {}, o = Object.keys(n), delete t.labels, o.length ? o.forEach(function(s) {
    n[s] && i.push((0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.m)({}, [
      t,
      n[s],
      { _key: s }
    ]));
  }) : i.push(t), a = i.reduce(function(s, l) {
    return (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.e)(l.listeners || {}, function(u, v) {
      s[v] = s[v] || {}, s[v][l._key || U] = u;
    }), delete l.listeners, s;
  }, {}), {
    labels: i,
    listeners: a
  });
}
function R(e, t, r, a) {
  if (t) {
    var i = r.$context, n = r.$groups, o;
    t[n._set] && (o = t[n._set][n._key], o && (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.c)(o, [i, a]) === !0 && (e[h]._dirty = !0, r.update(i)));
  }
}
function me(e, t, r, a, i) {
  var n, o;
  !r && !a || (r ? a ? r !== a && (o = n = !0) : o = !0 : n = !0, o && R(e, t.leave, r, i), n && R(e, t.enter, a, i));
}
function we(e, t) {
  var r = e[h], a = r._listeners, i, n;
  if (!(!a.enter && !a.leave)) {
    if (t.type === "mousemove")
      n = w.lookup(r._labels, t);
    else if (t.type !== "mouseout")
      return;
    i = r._hovered, r._hovered = n, me(e, a, i, n, t);
  }
}
function ge(e, t) {
  var r = e[h], a = r._listeners.click, i = a && w.lookup(r._labels, t);
  i && R(e, a, i, t);
}
var Me = {
  id: "datalabels",
  defaults: be,
  beforeInit: function(e) {
    e[h] = {
      _actives: []
    };
  },
  beforeUpdate: function(e) {
    var t = e[h];
    t._listened = !1, t._listeners = {}, t._datasets = [], t._labels = [];
  },
  afterDatasetUpdate: function(e, t, r) {
    var a = t.index, i = e[h], n = i._datasets[a] = [], o = e.isDatasetVisible(a), s = e.data.datasets[a], l = pe(s, r), u = t.meta.data || [], v = e.ctx, d, y, $, T, S, B, c, _;
    for (v.save(), d = 0, $ = u.length; d < $; ++d)
      if (c = u[d], c[h] = [], o && c && e.getDataVisibility(d) && !c.skip)
        for (y = 0, T = l.labels.length; y < T; ++y)
          S = l.labels[y], B = S._key, _ = new L(S, v, c, d), _.$groups = {
            _set: a,
            _key: B || U
          }, _.$context = {
            active: !1,
            chart: e,
            dataIndex: d,
            dataset: s,
            datasetIndex: a
          }, _.update(_.$context), c[h].push(_), n.push(_);
    v.restore(), (0,_chart_es_js__WEBPACK_IMPORTED_MODULE_0__.m)(i._listeners, l.listeners, {
      merger: function(k, C, X) {
        C[k] = C[k] || {}, C[k][t.index] = X[k], i._listened = !0;
      }
    });
  },
  afterUpdate: function(e) {
    e[h]._labels = w.prepare(e[h]._datasets);
  },
  // Draw labels on top of all dataset elements
  // https://github.com/chartjs/chartjs-plugin-datalabels/issues/29
  // https://github.com/chartjs/chartjs-plugin-datalabels/issues/32
  afterDatasetsDraw: function(e) {
    w.draw(e, e[h]._labels);
  },
  beforeEvent: function(e, t) {
    if (e[h]._listened) {
      var r = t.event;
      switch (r.type) {
        case "mousemove":
        case "mouseout":
          we(e, r);
          break;
        case "click":
          ge(e, r);
          break;
      }
    }
  },
  afterEvent: function(e) {
    var t = e[h], r = t._actives, a = t._actives = e.getActiveElements(), i = m.arrayDiff(r, a), n, o, s, l, u, v, d;
    for (n = 0, o = i.length; n < o; ++n)
      if (u = i[n], u[1])
        for (d = u[0].element[h] || [], s = 0, l = d.length; s < l; ++s)
          v = d[s], v.$context.active = u[1] === 1, v.update(v.$context);
    (t._dirty || i.length) && (w.update(t._labels), e.render()), delete t._dirty;
  }
};

//# sourceMappingURL=chartjs-plugin-datalabels.es.js.map


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfdHctZWxlbWVudHNfZGlzdF9qc19jaGFydGpzLXBsdWdpbi1kYXRhbGFiZWxzX2VzX2pzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQXlJO0FBQ3pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsVUFBVTtBQUNyQztBQUNBLDhDQUE4QywrQ0FBQztBQUMvQztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsT0FBTztBQUNyQztBQUNBLDhCQUE4QixPQUFPO0FBQ3JDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGLHNCQUFzQjtBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0EsQ0FBQztBQUNEO0FBQ0EsOEJBQThCO0FBQzlCLCtDQUErQyxPQUFPLCtDQUFDLEdBQUcsNkJBQTZCO0FBQ3ZGLG1CQUFtQiwrQ0FBQyxHQUFHO0FBQ3ZCO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxHQUFHO0FBQ0gsV0FBVywrQ0FBQyxrQkFBa0I7QUFDOUIsdUJBQXVCO0FBQ3ZCLEtBQUs7QUFDTCxHQUFHLElBQUk7QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLCtDQUFDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLEdBQUc7QUFDSDtBQUNBO0FBQ0Esd0NBQXdDLE9BQU87QUFDL0M7QUFDQSx5Q0FBeUMsT0FBTztBQUNoRDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxpQkFBaUIsK0NBQUM7QUFDbEI7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsOEJBQThCLE9BQU87QUFDckM7QUFDQSw2REFBNkQsT0FBTztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUdFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHctZWxlbWVudHMvZGlzdC9qcy9jaGFydGpzLXBsdWdpbi1kYXRhbGFiZWxzLmVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IG0gYXMgZywgaSBhcyBwLCB0IGFzIHEsIHIgYXMgZiwgZCBhcyBKLCBhIGFzIEssIHYgYXMgViwgYyBhcyB6LCBlIGFzIFksIEEgYXMgUSwgUCBhcyBaLCBCIGFzIGVlLCBiIGFzIHJlIH0gZnJvbSBcIi4vY2hhcnQuZXMuanNcIjtcbi8qIVxuICogY2hhcnRqcy1wbHVnaW4tZGF0YWxhYmVscyB2Mi4yLjBcbiAqIGh0dHBzOi8vY2hhcnRqcy1wbHVnaW4tZGF0YWxhYmVscy5uZXRsaWZ5LmFwcFxuICogKGMpIDIwMTctMjAyMiBjaGFydGpzLXBsdWdpbi1kYXRhbGFiZWxzIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbnZhciBEID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93IDwgXCJ1XCIpIHtcbiAgICBpZiAod2luZG93LmRldmljZVBpeGVsUmF0aW8pXG4gICAgICByZXR1cm4gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gICAgdmFyIGUgPSB3aW5kb3cuc2NyZWVuO1xuICAgIGlmIChlKVxuICAgICAgcmV0dXJuIChlLmRldmljZVhEUEkgfHwgMSkgLyAoZS5sb2dpY2FsWERQSSB8fCAxKTtcbiAgfVxuICByZXR1cm4gMTtcbn0oKSwgbSA9IHtcbiAgLy8gQHRvZG8gbW92ZSB0aGlzIGluIENoYXJ0LmhlbHBlcnMudG9UZXh0TGluZXNcbiAgdG9UZXh0TGluZXM6IGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgdCA9IFtdLCByO1xuICAgIGZvciAoZSA9IFtdLmNvbmNhdChlKTsgZS5sZW5ndGg7IClcbiAgICAgIHIgPSBlLnBvcCgpLCB0eXBlb2YgciA9PSBcInN0cmluZ1wiID8gdC51bnNoaWZ0LmFwcGx5KHQsIHIuc3BsaXQoYFxuYCkpIDogQXJyYXkuaXNBcnJheShyKSA/IGUucHVzaC5hcHBseShlLCByKSA6IHAoZSkgfHwgdC51bnNoaWZ0KFwiXCIgKyByKTtcbiAgICByZXR1cm4gdDtcbiAgfSxcbiAgLy8gQHRvZG8gbW92ZSB0aGlzIGluIENoYXJ0LmhlbHBlcnMuY2FudmFzLnRleHRTaXplXG4gIC8vIEB0b2RvIGNhY2hlIGNhbGxzIG9mIG1lYXN1cmVUZXh0IGlmIGZvbnQgZG9lc24ndCBjaGFuZ2U/IVxuICB0ZXh0U2l6ZTogZnVuY3Rpb24oZSwgdCwgcikge1xuICAgIHZhciBhID0gW10uY29uY2F0KHQpLCBpID0gYS5sZW5ndGgsIG4gPSBlLmZvbnQsIG8gPSAwLCBzO1xuICAgIGZvciAoZS5mb250ID0gci5zdHJpbmcsIHMgPSAwOyBzIDwgaTsgKytzKVxuICAgICAgbyA9IE1hdGgubWF4KGUubWVhc3VyZVRleHQoYVtzXSkud2lkdGgsIG8pO1xuICAgIHJldHVybiBlLmZvbnQgPSBuLCB7XG4gICAgICBoZWlnaHQ6IGkgKiByLmxpbmVIZWlnaHQsXG4gICAgICB3aWR0aDogb1xuICAgIH07XG4gIH0sXG4gIC8qKlxuICAgKiBSZXR1cm5zIHZhbHVlIGJvdW5kZWQgYnkgbWluIGFuZCBtYXguIFRoaXMgaXMgZXF1aXZhbGVudCB0byBtYXgobWluLCBtaW4odmFsdWUsIG1heCkpLlxuICAgKiBAdG9kbyBtb3ZlIHRoaXMgbWV0aG9kIGluIENoYXJ0LmhlbHBlcnMuYm91bmRcbiAgICogaHR0cHM6Ly9kb2MucXQuaW8vcXQtNS9xdGdsb2JhbC5odG1sI3FCb3VuZFxuICAgKi9cbiAgYm91bmQ6IGZ1bmN0aW9uKGUsIHQsIHIpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgoZSwgTWF0aC5taW4odCwgcikpO1xuICB9LFxuICAvKipcbiAgICogUmV0dXJucyBhbiBhcnJheSBvZiBwYWlyIFt2YWx1ZSwgc3RhdGVdIHdoZXJlIHN0YXRlIGlzOlxuICAgKiAqIC0xOiB2YWx1ZSBpcyBvbmx5IGluIGEwIChyZW1vdmVkKVxuICAgKiAqICAxOiB2YWx1ZSBpcyBvbmx5IGluIGExIChhZGRlZClcbiAgICovXG4gIGFycmF5RGlmZjogZnVuY3Rpb24oZSwgdCkge1xuICAgIHZhciByID0gZS5zbGljZSgpLCBhID0gW10sIGksIG4sIG8sIHM7XG4gICAgZm9yIChpID0gMCwgbyA9IHQubGVuZ3RoOyBpIDwgbzsgKytpKVxuICAgICAgcyA9IHRbaV0sIG4gPSByLmluZGV4T2YocyksIG4gPT09IC0xID8gYS5wdXNoKFtzLCAxXSkgOiByLnNwbGljZShuLCAxKTtcbiAgICBmb3IgKGkgPSAwLCBvID0gci5sZW5ndGg7IGkgPCBvOyArK2kpXG4gICAgICBhLnB1c2goW3JbaV0sIC0xXSk7XG4gICAgcmV0dXJuIGE7XG4gIH0sXG4gIC8qKlxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9jaGFydGpzLXBsdWdpbi1kYXRhbGFiZWxzL2lzc3Vlcy83MFxuICAgKi9cbiAgcmFzdGVyaXplOiBmdW5jdGlvbihlKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQoZSAqIEQpIC8gRDtcbiAgfVxufTtcbmZ1bmN0aW9uIEEoZSwgdCkge1xuICB2YXIgciA9IHQueCwgYSA9IHQueTtcbiAgaWYgKHIgPT09IG51bGwpXG4gICAgcmV0dXJuIHsgeDogMCwgeTogLTEgfTtcbiAgaWYgKGEgPT09IG51bGwpXG4gICAgcmV0dXJuIHsgeDogMSwgeTogMCB9O1xuICB2YXIgaSA9IGUueCAtIHIsIG4gPSBlLnkgLSBhLCBvID0gTWF0aC5zcXJ0KGkgKiBpICsgbiAqIG4pO1xuICByZXR1cm4ge1xuICAgIHg6IG8gPyBpIC8gbyA6IDAsXG4gICAgeTogbyA/IG4gLyBvIDogLTFcbiAgfTtcbn1cbmZ1bmN0aW9uIGFlKGUsIHQsIHIsIGEsIGkpIHtcbiAgc3dpdGNoIChpKSB7XG4gICAgY2FzZSBcImNlbnRlclwiOlxuICAgICAgciA9IGEgPSAwO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImJvdHRvbVwiOlxuICAgICAgciA9IDAsIGEgPSAxO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInJpZ2h0XCI6XG4gICAgICByID0gMSwgYSA9IDA7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwibGVmdFwiOlxuICAgICAgciA9IC0xLCBhID0gMDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJ0b3BcIjpcbiAgICAgIHIgPSAwLCBhID0gLTE7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwic3RhcnRcIjpcbiAgICAgIHIgPSAtciwgYSA9IC1hO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImVuZFwiOlxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGkgKj0gTWF0aC5QSSAvIDE4MCwgciA9IE1hdGguY29zKGkpLCBhID0gTWF0aC5zaW4oaSk7XG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4ge1xuICAgIHg6IGUsXG4gICAgeTogdCxcbiAgICB2eDogcixcbiAgICB2eTogYVxuICB9O1xufVxudmFyIHRlID0gMCwgaiA9IDEsIE4gPSAyLCBPID0gNCwgRiA9IDg7XG5mdW5jdGlvbiBNKGUsIHQsIHIpIHtcbiAgdmFyIGEgPSB0ZTtcbiAgcmV0dXJuIGUgPCByLmxlZnQgPyBhIHw9IGogOiBlID4gci5yaWdodCAmJiAoYSB8PSBOKSwgdCA8IHIudG9wID8gYSB8PSBGIDogdCA+IHIuYm90dG9tICYmIChhIHw9IE8pLCBhO1xufVxuZnVuY3Rpb24gaWUoZSwgdCkge1xuICBmb3IgKHZhciByID0gZS54MCwgYSA9IGUueTAsIGkgPSBlLngxLCBuID0gZS55MSwgbyA9IE0ociwgYSwgdCksIHMgPSBNKGksIG4sIHQpLCBsLCB1LCB2OyAhKCEobyB8IHMpIHx8IG8gJiBzKTsgKVxuICAgIGwgPSBvIHx8IHMsIGwgJiBGID8gKHUgPSByICsgKGkgLSByKSAqICh0LnRvcCAtIGEpIC8gKG4gLSBhKSwgdiA9IHQudG9wKSA6IGwgJiBPID8gKHUgPSByICsgKGkgLSByKSAqICh0LmJvdHRvbSAtIGEpIC8gKG4gLSBhKSwgdiA9IHQuYm90dG9tKSA6IGwgJiBOID8gKHYgPSBhICsgKG4gLSBhKSAqICh0LnJpZ2h0IC0gcikgLyAoaSAtIHIpLCB1ID0gdC5yaWdodCkgOiBsICYgaiAmJiAodiA9IGEgKyAobiAtIGEpICogKHQubGVmdCAtIHIpIC8gKGkgLSByKSwgdSA9IHQubGVmdCksIGwgPT09IG8gPyAociA9IHUsIGEgPSB2LCBvID0gTShyLCBhLCB0KSkgOiAoaSA9IHUsIG4gPSB2LCBzID0gTShpLCBuLCB0KSk7XG4gIHJldHVybiB7XG4gICAgeDA6IHIsXG4gICAgeDE6IGksXG4gICAgeTA6IGEsXG4gICAgeTE6IG5cbiAgfTtcbn1cbmZ1bmN0aW9uIFAoZSwgdCkge1xuICB2YXIgciA9IHQuYW5jaG9yLCBhID0gZSwgaSwgbjtcbiAgcmV0dXJuIHQuY2xhbXAgJiYgKGEgPSBpZShhLCB0LmFyZWEpKSwgciA9PT0gXCJzdGFydFwiID8gKGkgPSBhLngwLCBuID0gYS55MCkgOiByID09PSBcImVuZFwiID8gKGkgPSBhLngxLCBuID0gYS55MSkgOiAoaSA9IChhLngwICsgYS54MSkgLyAyLCBuID0gKGEueTAgKyBhLnkxKSAvIDIpLCBhZShpLCBuLCBlLnZ4LCBlLnZ5LCB0LmFsaWduKTtcbn1cbnZhciBFID0ge1xuICBhcmM6IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICB2YXIgciA9IChlLnN0YXJ0QW5nbGUgKyBlLmVuZEFuZ2xlKSAvIDIsIGEgPSBNYXRoLmNvcyhyKSwgaSA9IE1hdGguc2luKHIpLCBuID0gZS5pbm5lclJhZGl1cywgbyA9IGUub3V0ZXJSYWRpdXM7XG4gICAgcmV0dXJuIFAoe1xuICAgICAgeDA6IGUueCArIGEgKiBuLFxuICAgICAgeTA6IGUueSArIGkgKiBuLFxuICAgICAgeDE6IGUueCArIGEgKiBvLFxuICAgICAgeTE6IGUueSArIGkgKiBvLFxuICAgICAgdng6IGEsXG4gICAgICB2eTogaVxuICAgIH0sIHQpO1xuICB9LFxuICBwb2ludDogZnVuY3Rpb24oZSwgdCkge1xuICAgIHZhciByID0gQShlLCB0Lm9yaWdpbiksIGEgPSByLnggKiBlLm9wdGlvbnMucmFkaXVzLCBpID0gci55ICogZS5vcHRpb25zLnJhZGl1cztcbiAgICByZXR1cm4gUCh7XG4gICAgICB4MDogZS54IC0gYSxcbiAgICAgIHkwOiBlLnkgLSBpLFxuICAgICAgeDE6IGUueCArIGEsXG4gICAgICB5MTogZS55ICsgaSxcbiAgICAgIHZ4OiByLngsXG4gICAgICB2eTogci55XG4gICAgfSwgdCk7XG4gIH0sXG4gIGJhcjogZnVuY3Rpb24oZSwgdCkge1xuICAgIHZhciByID0gQShlLCB0Lm9yaWdpbiksIGEgPSBlLngsIGkgPSBlLnksIG4gPSAwLCBvID0gMDtcbiAgICByZXR1cm4gZS5ob3Jpem9udGFsID8gKGEgPSBNYXRoLm1pbihlLngsIGUuYmFzZSksIG4gPSBNYXRoLmFicyhlLmJhc2UgLSBlLngpKSA6IChpID0gTWF0aC5taW4oZS55LCBlLmJhc2UpLCBvID0gTWF0aC5hYnMoZS5iYXNlIC0gZS55KSksIFAoe1xuICAgICAgeDA6IGEsXG4gICAgICB5MDogaSArIG8sXG4gICAgICB4MTogYSArIG4sXG4gICAgICB5MTogaSxcbiAgICAgIHZ4OiByLngsXG4gICAgICB2eTogci55XG4gICAgfSwgdCk7XG4gIH0sXG4gIGZhbGxiYWNrOiBmdW5jdGlvbihlLCB0KSB7XG4gICAgdmFyIHIgPSBBKGUsIHQub3JpZ2luKTtcbiAgICByZXR1cm4gUCh7XG4gICAgICB4MDogZS54LFxuICAgICAgeTA6IGUueSxcbiAgICAgIHgxOiBlLnggKyAoZS53aWR0aCB8fCAwKSxcbiAgICAgIHkxOiBlLnkgKyAoZS5oZWlnaHQgfHwgMCksXG4gICAgICB2eDogci54LFxuICAgICAgdnk6IHIueVxuICAgIH0sIHQpO1xuICB9XG59LCB4ID0gbS5yYXN0ZXJpemU7XG5mdW5jdGlvbiBuZShlKSB7XG4gIHZhciB0ID0gZS5ib3JkZXJXaWR0aCB8fCAwLCByID0gZS5wYWRkaW5nLCBhID0gZS5zaXplLmhlaWdodCwgaSA9IGUuc2l6ZS53aWR0aCwgbiA9IC1pIC8gMiwgbyA9IC1hIC8gMjtcbiAgcmV0dXJuIHtcbiAgICBmcmFtZToge1xuICAgICAgeDogbiAtIHIubGVmdCAtIHQsXG4gICAgICB5OiBvIC0gci50b3AgLSB0LFxuICAgICAgdzogaSArIHIud2lkdGggKyB0ICogMixcbiAgICAgIGg6IGEgKyByLmhlaWdodCArIHQgKiAyXG4gICAgfSxcbiAgICB0ZXh0OiB7XG4gICAgICB4OiBuLFxuICAgICAgeTogbyxcbiAgICAgIHc6IGksXG4gICAgICBoOiBhXG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gb2UoZSwgdCkge1xuICB2YXIgciA9IHQuY2hhcnQuZ2V0RGF0YXNldE1ldGEodC5kYXRhc2V0SW5kZXgpLnZTY2FsZTtcbiAgaWYgKCFyKVxuICAgIHJldHVybiBudWxsO1xuICBpZiAoci54Q2VudGVyICE9PSB2b2lkIDAgJiYgci55Q2VudGVyICE9PSB2b2lkIDApXG4gICAgcmV0dXJuIHsgeDogci54Q2VudGVyLCB5OiByLnlDZW50ZXIgfTtcbiAgdmFyIGEgPSByLmdldEJhc2VQaXhlbCgpO1xuICByZXR1cm4gZS5ob3Jpem9udGFsID8geyB4OiBhLCB5OiBudWxsIH0gOiB7IHg6IG51bGwsIHk6IGEgfTtcbn1cbmZ1bmN0aW9uIHNlKGUpIHtcbiAgcmV0dXJuIGUgaW5zdGFuY2VvZiBRID8gRS5hcmMgOiBlIGluc3RhbmNlb2YgWiA/IEUucG9pbnQgOiBlIGluc3RhbmNlb2YgZWUgPyBFLmJhciA6IEUuZmFsbGJhY2s7XG59XG5mdW5jdGlvbiBsZShlLCB0LCByLCBhLCBpLCBuKSB7XG4gIHZhciBvID0gTWF0aC5QSSAvIDI7XG4gIGlmIChuKSB7XG4gICAgdmFyIHMgPSBNYXRoLm1pbihuLCBpIC8gMiwgYSAvIDIpLCBsID0gdCArIHMsIHUgPSByICsgcywgdiA9IHQgKyBhIC0gcywgZCA9IHIgKyBpIC0gcztcbiAgICBlLm1vdmVUbyh0LCB1KSwgbCA8IHYgJiYgdSA8IGQgPyAoZS5hcmMobCwgdSwgcywgLU1hdGguUEksIC1vKSwgZS5hcmModiwgdSwgcywgLW8sIDApLCBlLmFyYyh2LCBkLCBzLCAwLCBvKSwgZS5hcmMobCwgZCwgcywgbywgTWF0aC5QSSkpIDogbCA8IHYgPyAoZS5tb3ZlVG8obCwgciksIGUuYXJjKHYsIHUsIHMsIC1vLCBvKSwgZS5hcmMobCwgdSwgcywgbywgTWF0aC5QSSArIG8pKSA6IHUgPCBkID8gKGUuYXJjKGwsIHUsIHMsIC1NYXRoLlBJLCAwKSwgZS5hcmMobCwgZCwgcywgMCwgTWF0aC5QSSkpIDogZS5hcmMobCwgdSwgcywgLU1hdGguUEksIE1hdGguUEkpLCBlLmNsb3NlUGF0aCgpLCBlLm1vdmVUbyh0LCByKTtcbiAgfSBlbHNlXG4gICAgZS5yZWN0KHQsIHIsIGEsIGkpO1xufVxuZnVuY3Rpb24gdWUoZSwgdCwgcikge1xuICB2YXIgYSA9IHIuYmFja2dyb3VuZENvbG9yLCBpID0gci5ib3JkZXJDb2xvciwgbiA9IHIuYm9yZGVyV2lkdGg7XG4gICFhICYmICghaSB8fCAhbikgfHwgKGUuYmVnaW5QYXRoKCksIGxlKFxuICAgIGUsXG4gICAgeCh0LngpICsgbiAvIDIsXG4gICAgeCh0LnkpICsgbiAvIDIsXG4gICAgeCh0LncpIC0gbixcbiAgICB4KHQuaCkgLSBuLFxuICAgIHIuYm9yZGVyUmFkaXVzXG4gICksIGUuY2xvc2VQYXRoKCksIGEgJiYgKGUuZmlsbFN0eWxlID0gYSwgZS5maWxsKCkpLCBpICYmIG4gJiYgKGUuc3Ryb2tlU3R5bGUgPSBpLCBlLmxpbmVXaWR0aCA9IG4sIGUubGluZUpvaW4gPSBcIm1pdGVyXCIsIGUuc3Ryb2tlKCkpKTtcbn1cbmZ1bmN0aW9uIHZlKGUsIHQsIHIpIHtcbiAgdmFyIGEgPSByLmxpbmVIZWlnaHQsIGkgPSBlLncsIG4gPSBlLngsIG8gPSBlLnkgKyBhIC8gMjtcbiAgcmV0dXJuIHQgPT09IFwiY2VudGVyXCIgPyBuICs9IGkgLyAyIDogKHQgPT09IFwiZW5kXCIgfHwgdCA9PT0gXCJyaWdodFwiKSAmJiAobiArPSBpKSwge1xuICAgIGg6IGEsXG4gICAgdzogaSxcbiAgICB4OiBuLFxuICAgIHk6IG9cbiAgfTtcbn1cbmZ1bmN0aW9uIGRlKGUsIHQsIHIpIHtcbiAgdmFyIGEgPSBlLnNoYWRvd0JsdXIsIGkgPSByLnN0cm9rZWQsIG4gPSB4KHIueCksIG8gPSB4KHIueSksIHMgPSB4KHIudyk7XG4gIGkgJiYgZS5zdHJva2VUZXh0KHQsIG4sIG8sIHMpLCByLmZpbGxlZCAmJiAoYSAmJiBpICYmIChlLnNoYWRvd0JsdXIgPSAwKSwgZS5maWxsVGV4dCh0LCBuLCBvLCBzKSwgYSAmJiBpICYmIChlLnNoYWRvd0JsdXIgPSBhKSk7XG59XG5mdW5jdGlvbiBmZShlLCB0LCByLCBhKSB7XG4gIHZhciBpID0gYS50ZXh0QWxpZ24sIG4gPSBhLmNvbG9yLCBvID0gISFuLCBzID0gYS5mb250LCBsID0gdC5sZW5ndGgsIHUgPSBhLnRleHRTdHJva2VDb2xvciwgdiA9IGEudGV4dFN0cm9rZVdpZHRoLCBkID0gdSAmJiB2LCB5O1xuICBpZiAoISghbCB8fCAhbyAmJiAhZCkpXG4gICAgZm9yIChyID0gdmUociwgaSwgcyksIGUuZm9udCA9IHMuc3RyaW5nLCBlLnRleHRBbGlnbiA9IGksIGUudGV4dEJhc2VsaW5lID0gXCJtaWRkbGVcIiwgZS5zaGFkb3dCbHVyID0gYS50ZXh0U2hhZG93Qmx1ciwgZS5zaGFkb3dDb2xvciA9IGEudGV4dFNoYWRvd0NvbG9yLCBvICYmIChlLmZpbGxTdHlsZSA9IG4pLCBkICYmIChlLmxpbmVKb2luID0gXCJyb3VuZFwiLCBlLmxpbmVXaWR0aCA9IHYsIGUuc3Ryb2tlU3R5bGUgPSB1KSwgeSA9IDAsIGwgPSB0Lmxlbmd0aDsgeSA8IGw7ICsreSlcbiAgICAgIGRlKGUsIHRbeV0sIHtcbiAgICAgICAgc3Ryb2tlZDogZCxcbiAgICAgICAgZmlsbGVkOiBvLFxuICAgICAgICB3OiByLncsXG4gICAgICAgIHg6IHIueCxcbiAgICAgICAgeTogci55ICsgci5oICogeVxuICAgICAgfSk7XG59XG52YXIgTCA9IGZ1bmN0aW9uKGUsIHQsIHIsIGEpIHtcbiAgdmFyIGkgPSB0aGlzO1xuICBpLl9jb25maWcgPSBlLCBpLl9pbmRleCA9IGEsIGkuX21vZGVsID0gbnVsbCwgaS5fcmVjdHMgPSBudWxsLCBpLl9jdHggPSB0LCBpLl9lbCA9IHI7XG59O1xuZyhMLnByb3RvdHlwZSwge1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9tb2RlbGl6ZTogZnVuY3Rpb24oZSwgdCwgciwgYSkge1xuICAgIHZhciBpID0gdGhpcywgbiA9IGkuX2luZGV4LCBvID0gcShmKFtyLmZvbnQsIHt9XSwgYSwgbikpLCBzID0gZihbci5jb2xvciwgSi5jb2xvcl0sIGEsIG4pO1xuICAgIHJldHVybiB7XG4gICAgICBhbGlnbjogZihbci5hbGlnbiwgXCJjZW50ZXJcIl0sIGEsIG4pLFxuICAgICAgYW5jaG9yOiBmKFtyLmFuY2hvciwgXCJjZW50ZXJcIl0sIGEsIG4pLFxuICAgICAgYXJlYTogYS5jaGFydC5jaGFydEFyZWEsXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IGYoW3IuYmFja2dyb3VuZENvbG9yLCBudWxsXSwgYSwgbiksXG4gICAgICBib3JkZXJDb2xvcjogZihbci5ib3JkZXJDb2xvciwgbnVsbF0sIGEsIG4pLFxuICAgICAgYm9yZGVyUmFkaXVzOiBmKFtyLmJvcmRlclJhZGl1cywgMF0sIGEsIG4pLFxuICAgICAgYm9yZGVyV2lkdGg6IGYoW3IuYm9yZGVyV2lkdGgsIDBdLCBhLCBuKSxcbiAgICAgIGNsYW1wOiBmKFtyLmNsYW1wLCAhMV0sIGEsIG4pLFxuICAgICAgY2xpcDogZihbci5jbGlwLCAhMV0sIGEsIG4pLFxuICAgICAgY29sb3I6IHMsXG4gICAgICBkaXNwbGF5OiBlLFxuICAgICAgZm9udDogbyxcbiAgICAgIGxpbmVzOiB0LFxuICAgICAgb2Zmc2V0OiBmKFtyLm9mZnNldCwgNF0sIGEsIG4pLFxuICAgICAgb3BhY2l0eTogZihbci5vcGFjaXR5LCAxXSwgYSwgbiksXG4gICAgICBvcmlnaW46IG9lKGkuX2VsLCBhKSxcbiAgICAgIHBhZGRpbmc6IEsoZihbci5wYWRkaW5nLCA0XSwgYSwgbikpLFxuICAgICAgcG9zaXRpb25lcjogc2UoaS5fZWwpLFxuICAgICAgcm90YXRpb246IGYoW3Iucm90YXRpb24sIDBdLCBhLCBuKSAqIChNYXRoLlBJIC8gMTgwKSxcbiAgICAgIHNpemU6IG0udGV4dFNpemUoaS5fY3R4LCB0LCBvKSxcbiAgICAgIHRleHRBbGlnbjogZihbci50ZXh0QWxpZ24sIFwic3RhcnRcIl0sIGEsIG4pLFxuICAgICAgdGV4dFNoYWRvd0JsdXI6IGYoW3IudGV4dFNoYWRvd0JsdXIsIDBdLCBhLCBuKSxcbiAgICAgIHRleHRTaGFkb3dDb2xvcjogZihbci50ZXh0U2hhZG93Q29sb3IsIHNdLCBhLCBuKSxcbiAgICAgIHRleHRTdHJva2VDb2xvcjogZihbci50ZXh0U3Ryb2tlQ29sb3IsIHNdLCBhLCBuKSxcbiAgICAgIHRleHRTdHJva2VXaWR0aDogZihbci50ZXh0U3Ryb2tlV2lkdGgsIDBdLCBhLCBuKVxuICAgIH07XG4gIH0sXG4gIHVwZGF0ZTogZnVuY3Rpb24oZSkge1xuICAgIHZhciB0ID0gdGhpcywgciA9IG51bGwsIGEgPSBudWxsLCBpID0gdC5faW5kZXgsIG4gPSB0Ll9jb25maWcsIG8sIHMsIGwsIHUgPSBmKFtuLmRpc3BsYXksICEwXSwgZSwgaSk7XG4gICAgdSAmJiAobyA9IGUuZGF0YXNldC5kYXRhW2ldLCBzID0gVih6KG4uZm9ybWF0dGVyLCBbbywgZV0pLCBvKSwgbCA9IHAocykgPyBbXSA6IG0udG9UZXh0TGluZXMocyksIGwubGVuZ3RoICYmIChyID0gdC5fbW9kZWxpemUodSwgbCwgbiwgZSksIGEgPSBuZShyKSkpLCB0Ll9tb2RlbCA9IHIsIHQuX3JlY3RzID0gYTtcbiAgfSxcbiAgZ2VvbWV0cnk6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9yZWN0cyA/IHRoaXMuX3JlY3RzLmZyYW1lIDoge307XG4gIH0sXG4gIHJvdGF0aW9uOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fbW9kZWwgPyB0aGlzLl9tb2RlbC5yb3RhdGlvbiA6IDA7XG4gIH0sXG4gIHZpc2libGU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9tb2RlbCAmJiB0aGlzLl9tb2RlbC5vcGFjaXR5O1xuICB9LFxuICBtb2RlbDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX21vZGVsO1xuICB9LFxuICBkcmF3OiBmdW5jdGlvbihlLCB0KSB7XG4gICAgdmFyIHIgPSB0aGlzLCBhID0gZS5jdHgsIGkgPSByLl9tb2RlbCwgbiA9IHIuX3JlY3RzLCBvO1xuICAgIHRoaXMudmlzaWJsZSgpICYmIChhLnNhdmUoKSwgaS5jbGlwICYmIChvID0gaS5hcmVhLCBhLmJlZ2luUGF0aCgpLCBhLnJlY3QoXG4gICAgICBvLmxlZnQsXG4gICAgICBvLnRvcCxcbiAgICAgIG8ucmlnaHQgLSBvLmxlZnQsXG4gICAgICBvLmJvdHRvbSAtIG8udG9wXG4gICAgKSwgYS5jbGlwKCkpLCBhLmdsb2JhbEFscGhhID0gbS5ib3VuZCgwLCBpLm9wYWNpdHksIDEpLCBhLnRyYW5zbGF0ZSh4KHQueCksIHgodC55KSksIGEucm90YXRlKGkucm90YXRpb24pLCB1ZShhLCBuLmZyYW1lLCBpKSwgZmUoYSwgaS5saW5lcywgbi50ZXh0LCBpKSwgYS5yZXN0b3JlKCkpO1xuICB9XG59KTtcbnZhciBoZSA9IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSIHx8IC05MDA3MTk5MjU0NzQwOTkxLCB5ZSA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIHx8IDkwMDcxOTkyNTQ3NDA5OTE7XG5mdW5jdGlvbiBiKGUsIHQsIHIpIHtcbiAgdmFyIGEgPSBNYXRoLmNvcyhyKSwgaSA9IE1hdGguc2luKHIpLCBuID0gdC54LCBvID0gdC55O1xuICByZXR1cm4ge1xuICAgIHg6IG4gKyBhICogKGUueCAtIG4pIC0gaSAqIChlLnkgLSBvKSxcbiAgICB5OiBvICsgaSAqIChlLnggLSBuKSArIGEgKiAoZS55IC0gbylcbiAgfTtcbn1cbmZ1bmN0aW9uIFcoZSwgdCkge1xuICB2YXIgciA9IHllLCBhID0gaGUsIGkgPSB0Lm9yaWdpbiwgbiwgbywgcywgbCwgdTtcbiAgZm9yIChuID0gMDsgbiA8IGUubGVuZ3RoOyArK24pXG4gICAgbyA9IGVbbl0sIHMgPSBvLnggLSBpLngsIGwgPSBvLnkgLSBpLnksIHUgPSB0LnZ4ICogcyArIHQudnkgKiBsLCByID0gTWF0aC5taW4ociwgdSksIGEgPSBNYXRoLm1heChhLCB1KTtcbiAgcmV0dXJuIHtcbiAgICBtaW46IHIsXG4gICAgbWF4OiBhXG4gIH07XG59XG5mdW5jdGlvbiBJKGUsIHQpIHtcbiAgdmFyIHIgPSB0LnggLSBlLngsIGEgPSB0LnkgLSBlLnksIGkgPSBNYXRoLnNxcnQociAqIHIgKyBhICogYSk7XG4gIHJldHVybiB7XG4gICAgdng6ICh0LnggLSBlLngpIC8gaSxcbiAgICB2eTogKHQueSAtIGUueSkgLyBpLFxuICAgIG9yaWdpbjogZSxcbiAgICBsbjogaVxuICB9O1xufVxudmFyIEcgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fcm90YXRpb24gPSAwLCB0aGlzLl9yZWN0ID0ge1xuICAgIHg6IDAsXG4gICAgeTogMCxcbiAgICB3OiAwLFxuICAgIGg6IDBcbiAgfTtcbn07XG5nKEcucHJvdG90eXBlLCB7XG4gIGNlbnRlcjogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGUgPSB0aGlzLl9yZWN0O1xuICAgIHJldHVybiB7XG4gICAgICB4OiBlLnggKyBlLncgLyAyLFxuICAgICAgeTogZS55ICsgZS5oIC8gMlxuICAgIH07XG4gIH0sXG4gIHVwZGF0ZTogZnVuY3Rpb24oZSwgdCwgcikge1xuICAgIHRoaXMuX3JvdGF0aW9uID0gciwgdGhpcy5fcmVjdCA9IHtcbiAgICAgIHg6IHQueCArIGUueCxcbiAgICAgIHk6IHQueSArIGUueSxcbiAgICAgIHc6IHQudyxcbiAgICAgIGg6IHQuaFxuICAgIH07XG4gIH0sXG4gIGNvbnRhaW5zOiBmdW5jdGlvbihlKSB7XG4gICAgdmFyIHQgPSB0aGlzLCByID0gMSwgYSA9IHQuX3JlY3Q7XG4gICAgcmV0dXJuIGUgPSBiKGUsIHQuY2VudGVyKCksIC10Ll9yb3RhdGlvbiksICEoZS54IDwgYS54IC0gciB8fCBlLnkgPCBhLnkgLSByIHx8IGUueCA+IGEueCArIGEudyArIHIgKiAyIHx8IGUueSA+IGEueSArIGEuaCArIHIgKiAyKTtcbiAgfSxcbiAgLy8gU2VwYXJhdGluZyBBeGlzIFRoZW9yZW1cbiAgLy8gaHR0cHM6Ly9nYW1lZGV2ZWxvcG1lbnQudHV0c3BsdXMuY29tL3R1dG9yaWFscy9jb2xsaXNpb24tZGV0ZWN0aW9uLXVzaW5nLXRoZS1zZXBhcmF0aW5nLWF4aXMtdGhlb3JlbS0tZ2FtZWRldi0xNjlcbiAgaW50ZXJzZWN0czogZnVuY3Rpb24oZSkge1xuICAgIHZhciB0ID0gdGhpcy5fcG9pbnRzKCksIHIgPSBlLl9wb2ludHMoKSwgYSA9IFtcbiAgICAgIEkodFswXSwgdFsxXSksXG4gICAgICBJKHRbMF0sIHRbM10pXG4gICAgXSwgaSwgbiwgbztcbiAgICBmb3IgKHRoaXMuX3JvdGF0aW9uICE9PSBlLl9yb3RhdGlvbiAmJiBhLnB1c2goXG4gICAgICBJKHJbMF0sIHJbMV0pLFxuICAgICAgSShyWzBdLCByWzNdKVxuICAgICksIGkgPSAwOyBpIDwgYS5sZW5ndGg7ICsraSlcbiAgICAgIGlmIChuID0gVyh0LCBhW2ldKSwgbyA9IFcociwgYVtpXSksIG4ubWF4IDwgby5taW4gfHwgby5tYXggPCBuLm1pbilcbiAgICAgICAgcmV0dXJuICExO1xuICAgIHJldHVybiAhMDtcbiAgfSxcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcG9pbnRzOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgZSA9IHRoaXMsIHQgPSBlLl9yZWN0LCByID0gZS5fcm90YXRpb24sIGEgPSBlLmNlbnRlcigpO1xuICAgIHJldHVybiBbXG4gICAgICBiKHsgeDogdC54LCB5OiB0LnkgfSwgYSwgciksXG4gICAgICBiKHsgeDogdC54ICsgdC53LCB5OiB0LnkgfSwgYSwgciksXG4gICAgICBiKHsgeDogdC54ICsgdC53LCB5OiB0LnkgKyB0LmggfSwgYSwgciksXG4gICAgICBiKHsgeDogdC54LCB5OiB0LnkgKyB0LmggfSwgYSwgcilcbiAgICBdO1xuICB9XG59KTtcbmZ1bmN0aW9uIEgoZSwgdCwgcikge1xuICB2YXIgYSA9IHQucG9zaXRpb25lcihlLCB0KSwgaSA9IGEudngsIG4gPSBhLnZ5O1xuICBpZiAoIWkgJiYgIW4pXG4gICAgcmV0dXJuIHsgeDogYS54LCB5OiBhLnkgfTtcbiAgdmFyIG8gPSByLncsIHMgPSByLmgsIGwgPSB0LnJvdGF0aW9uLCB1ID0gTWF0aC5hYnMobyAvIDIgKiBNYXRoLmNvcyhsKSkgKyBNYXRoLmFicyhzIC8gMiAqIE1hdGguc2luKGwpKSwgdiA9IE1hdGguYWJzKG8gLyAyICogTWF0aC5zaW4obCkpICsgTWF0aC5hYnMocyAvIDIgKiBNYXRoLmNvcyhsKSksIGQgPSAxIC8gTWF0aC5tYXgoTWF0aC5hYnMoaSksIE1hdGguYWJzKG4pKTtcbiAgcmV0dXJuIHUgKj0gaSAqIGQsIHYgKj0gbiAqIGQsIHUgKz0gdC5vZmZzZXQgKiBpLCB2ICs9IHQub2Zmc2V0ICogbiwge1xuICAgIHg6IGEueCArIHUsXG4gICAgeTogYS55ICsgdlxuICB9O1xufVxuZnVuY3Rpb24geGUoZSwgdCkge1xuICB2YXIgciwgYSwgaSwgbjtcbiAgZm9yIChyID0gZS5sZW5ndGggLSAxOyByID49IDA7IC0tcilcbiAgICBmb3IgKGkgPSBlW3JdLiRsYXlvdXQsIGEgPSByIC0gMTsgYSA+PSAwICYmIGkuX3Zpc2libGU7IC0tYSlcbiAgICAgIG4gPSBlW2FdLiRsYXlvdXQsIG4uX3Zpc2libGUgJiYgaS5fYm94LmludGVyc2VjdHMobi5fYm94KSAmJiB0KGksIG4pO1xuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIF9lKGUpIHtcbiAgdmFyIHQsIHIsIGEsIGksIG4sIG8sIHM7XG4gIGZvciAodCA9IDAsIHIgPSBlLmxlbmd0aDsgdCA8IHI7ICsrdClcbiAgICBhID0gZVt0XSwgaSA9IGEuJGxheW91dCwgaS5fdmlzaWJsZSAmJiAocyA9IG5ldyBQcm94eShhLl9lbCwgeyBnZXQ6IChsLCB1KSA9PiBsLmdldFByb3BzKFt1XSwgITApW3VdIH0pLCBuID0gYS5nZW9tZXRyeSgpLCBvID0gSChzLCBhLm1vZGVsKCksIG4pLCBpLl9ib3gudXBkYXRlKG8sIG4sIGEucm90YXRpb24oKSkpO1xuICByZXR1cm4geGUoZSwgZnVuY3Rpb24obCwgdSkge1xuICAgIHZhciB2ID0gbC5faGlkYWJsZSwgZCA9IHUuX2hpZGFibGU7XG4gICAgdiAmJiBkIHx8IGQgPyB1Ll92aXNpYmxlID0gITEgOiB2ICYmIChsLl92aXNpYmxlID0gITEpO1xuICB9KTtcbn1cbnZhciB3ID0ge1xuICBwcmVwYXJlOiBmdW5jdGlvbihlKSB7XG4gICAgdmFyIHQgPSBbXSwgciwgYSwgaSwgbiwgbztcbiAgICBmb3IgKHIgPSAwLCBpID0gZS5sZW5ndGg7IHIgPCBpOyArK3IpXG4gICAgICBmb3IgKGEgPSAwLCBuID0gZVtyXS5sZW5ndGg7IGEgPCBuOyArK2EpXG4gICAgICAgIG8gPSBlW3JdW2FdLCB0LnB1c2gobyksIG8uJGxheW91dCA9IHtcbiAgICAgICAgICBfYm94OiBuZXcgRygpLFxuICAgICAgICAgIF9oaWRhYmxlOiAhMSxcbiAgICAgICAgICBfdmlzaWJsZTogITAsXG4gICAgICAgICAgX3NldDogcixcbiAgICAgICAgICBfaWR4OiBvLl9pbmRleFxuICAgICAgICB9O1xuICAgIHJldHVybiB0LnNvcnQoZnVuY3Rpb24ocywgbCkge1xuICAgICAgdmFyIHUgPSBzLiRsYXlvdXQsIHYgPSBsLiRsYXlvdXQ7XG4gICAgICByZXR1cm4gdS5faWR4ID09PSB2Ll9pZHggPyB2Ll9zZXQgLSB1Ll9zZXQgOiB2Ll9pZHggLSB1Ll9pZHg7XG4gICAgfSksIHRoaXMudXBkYXRlKHQpLCB0O1xuICB9LFxuICB1cGRhdGU6IGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgdCA9ICExLCByLCBhLCBpLCBuLCBvO1xuICAgIGZvciAociA9IDAsIGEgPSBlLmxlbmd0aDsgciA8IGE7ICsrcilcbiAgICAgIGkgPSBlW3JdLCBuID0gaS5tb2RlbCgpLCBvID0gaS4kbGF5b3V0LCBvLl9oaWRhYmxlID0gbiAmJiBuLmRpc3BsYXkgPT09IFwiYXV0b1wiLCBvLl92aXNpYmxlID0gaS52aXNpYmxlKCksIHQgfD0gby5faGlkYWJsZTtcbiAgICB0ICYmIF9lKGUpO1xuICB9LFxuICBsb29rdXA6IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICB2YXIgciwgYTtcbiAgICBmb3IgKHIgPSBlLmxlbmd0aCAtIDE7IHIgPj0gMDsgLS1yKVxuICAgICAgaWYgKGEgPSBlW3JdLiRsYXlvdXQsIGEgJiYgYS5fdmlzaWJsZSAmJiBhLl9ib3guY29udGFpbnModCkpXG4gICAgICAgIHJldHVybiBlW3JdO1xuICAgIHJldHVybiBudWxsO1xuICB9LFxuICBkcmF3OiBmdW5jdGlvbihlLCB0KSB7XG4gICAgdmFyIHIsIGEsIGksIG4sIG8sIHM7XG4gICAgZm9yIChyID0gMCwgYSA9IHQubGVuZ3RoOyByIDwgYTsgKytyKVxuICAgICAgaSA9IHRbcl0sIG4gPSBpLiRsYXlvdXQsIG4uX3Zpc2libGUgJiYgKG8gPSBpLmdlb21ldHJ5KCksIHMgPSBIKGkuX2VsLCBpLm1vZGVsKCksIG8pLCBuLl9ib3gudXBkYXRlKHMsIG8sIGkucm90YXRpb24oKSksIGkuZHJhdyhlLCBzKSk7XG4gIH1cbn0sIGNlID0gZnVuY3Rpb24oZSkge1xuICBpZiAocChlKSlcbiAgICByZXR1cm4gbnVsbDtcbiAgdmFyIHQgPSBlLCByLCBhLCBpO1xuICBpZiAocmUoZSkpXG4gICAgaWYgKCFwKGUubGFiZWwpKVxuICAgICAgdCA9IGUubGFiZWw7XG4gICAgZWxzZSBpZiAoIXAoZS5yKSlcbiAgICAgIHQgPSBlLnI7XG4gICAgZWxzZVxuICAgICAgZm9yICh0ID0gXCJcIiwgciA9IE9iamVjdC5rZXlzKGUpLCBpID0gMCwgYSA9IHIubGVuZ3RoOyBpIDwgYTsgKytpKVxuICAgICAgICB0ICs9IChpICE9PSAwID8gXCIsIFwiIDogXCJcIikgKyByW2ldICsgXCI6IFwiICsgZVtyW2ldXTtcbiAgcmV0dXJuIFwiXCIgKyB0O1xufSwgYmUgPSB7XG4gIGFsaWduOiBcImNlbnRlclwiLFxuICBhbmNob3I6IFwiY2VudGVyXCIsXG4gIGJhY2tncm91bmRDb2xvcjogbnVsbCxcbiAgYm9yZGVyQ29sb3I6IG51bGwsXG4gIGJvcmRlclJhZGl1czogMCxcbiAgYm9yZGVyV2lkdGg6IDAsXG4gIGNsYW1wOiAhMSxcbiAgY2xpcDogITEsXG4gIGNvbG9yOiB2b2lkIDAsXG4gIGRpc3BsYXk6ICEwLFxuICBmb250OiB7XG4gICAgZmFtaWx5OiB2b2lkIDAsXG4gICAgbGluZUhlaWdodDogMS4yLFxuICAgIHNpemU6IHZvaWQgMCxcbiAgICBzdHlsZTogdm9pZCAwLFxuICAgIHdlaWdodDogbnVsbFxuICB9LFxuICBmb3JtYXR0ZXI6IGNlLFxuICBsYWJlbHM6IHZvaWQgMCxcbiAgbGlzdGVuZXJzOiB7fSxcbiAgb2Zmc2V0OiA0LFxuICBvcGFjaXR5OiAxLFxuICBwYWRkaW5nOiB7XG4gICAgdG9wOiA0LFxuICAgIHJpZ2h0OiA0LFxuICAgIGJvdHRvbTogNCxcbiAgICBsZWZ0OiA0XG4gIH0sXG4gIHJvdGF0aW9uOiAwLFxuICB0ZXh0QWxpZ246IFwic3RhcnRcIixcbiAgdGV4dFN0cm9rZUNvbG9yOiB2b2lkIDAsXG4gIHRleHRTdHJva2VXaWR0aDogMCxcbiAgdGV4dFNoYWRvd0JsdXI6IDAsXG4gIHRleHRTaGFkb3dDb2xvcjogdm9pZCAwXG59LCBoID0gXCIkZGF0YWxhYmVsc1wiLCBVID0gXCIkZGVmYXVsdFwiO1xuZnVuY3Rpb24gcGUoZSwgdCkge1xuICB2YXIgciA9IGUuZGF0YWxhYmVscywgYSA9IHt9LCBpID0gW10sIG4sIG87XG4gIHJldHVybiByID09PSAhMSA/IG51bGwgOiAociA9PT0gITAgJiYgKHIgPSB7fSksIHQgPSBnKHt9LCBbdCwgcl0pLCBuID0gdC5sYWJlbHMgfHwge30sIG8gPSBPYmplY3Qua2V5cyhuKSwgZGVsZXRlIHQubGFiZWxzLCBvLmxlbmd0aCA/IG8uZm9yRWFjaChmdW5jdGlvbihzKSB7XG4gICAgbltzXSAmJiBpLnB1c2goZyh7fSwgW1xuICAgICAgdCxcbiAgICAgIG5bc10sXG4gICAgICB7IF9rZXk6IHMgfVxuICAgIF0pKTtcbiAgfSkgOiBpLnB1c2godCksIGEgPSBpLnJlZHVjZShmdW5jdGlvbihzLCBsKSB7XG4gICAgcmV0dXJuIFkobC5saXN0ZW5lcnMgfHwge30sIGZ1bmN0aW9uKHUsIHYpIHtcbiAgICAgIHNbdl0gPSBzW3ZdIHx8IHt9LCBzW3ZdW2wuX2tleSB8fCBVXSA9IHU7XG4gICAgfSksIGRlbGV0ZSBsLmxpc3RlbmVycywgcztcbiAgfSwge30pLCB7XG4gICAgbGFiZWxzOiBpLFxuICAgIGxpc3RlbmVyczogYVxuICB9KTtcbn1cbmZ1bmN0aW9uIFIoZSwgdCwgciwgYSkge1xuICBpZiAodCkge1xuICAgIHZhciBpID0gci4kY29udGV4dCwgbiA9IHIuJGdyb3VwcywgbztcbiAgICB0W24uX3NldF0gJiYgKG8gPSB0W24uX3NldF1bbi5fa2V5XSwgbyAmJiB6KG8sIFtpLCBhXSkgPT09ICEwICYmIChlW2hdLl9kaXJ0eSA9ICEwLCByLnVwZGF0ZShpKSkpO1xuICB9XG59XG5mdW5jdGlvbiBtZShlLCB0LCByLCBhLCBpKSB7XG4gIHZhciBuLCBvO1xuICAhciAmJiAhYSB8fCAociA/IGEgPyByICE9PSBhICYmIChvID0gbiA9ICEwKSA6IG8gPSAhMCA6IG4gPSAhMCwgbyAmJiBSKGUsIHQubGVhdmUsIHIsIGkpLCBuICYmIFIoZSwgdC5lbnRlciwgYSwgaSkpO1xufVxuZnVuY3Rpb24gd2UoZSwgdCkge1xuICB2YXIgciA9IGVbaF0sIGEgPSByLl9saXN0ZW5lcnMsIGksIG47XG4gIGlmICghKCFhLmVudGVyICYmICFhLmxlYXZlKSkge1xuICAgIGlmICh0LnR5cGUgPT09IFwibW91c2Vtb3ZlXCIpXG4gICAgICBuID0gdy5sb29rdXAoci5fbGFiZWxzLCB0KTtcbiAgICBlbHNlIGlmICh0LnR5cGUgIT09IFwibW91c2VvdXRcIilcbiAgICAgIHJldHVybjtcbiAgICBpID0gci5faG92ZXJlZCwgci5faG92ZXJlZCA9IG4sIG1lKGUsIGEsIGksIG4sIHQpO1xuICB9XG59XG5mdW5jdGlvbiBnZShlLCB0KSB7XG4gIHZhciByID0gZVtoXSwgYSA9IHIuX2xpc3RlbmVycy5jbGljaywgaSA9IGEgJiYgdy5sb29rdXAoci5fbGFiZWxzLCB0KTtcbiAgaSAmJiBSKGUsIGEsIGksIHQpO1xufVxudmFyIE1lID0ge1xuICBpZDogXCJkYXRhbGFiZWxzXCIsXG4gIGRlZmF1bHRzOiBiZSxcbiAgYmVmb3JlSW5pdDogZnVuY3Rpb24oZSkge1xuICAgIGVbaF0gPSB7XG4gICAgICBfYWN0aXZlczogW11cbiAgICB9O1xuICB9LFxuICBiZWZvcmVVcGRhdGU6IGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgdCA9IGVbaF07XG4gICAgdC5fbGlzdGVuZWQgPSAhMSwgdC5fbGlzdGVuZXJzID0ge30sIHQuX2RhdGFzZXRzID0gW10sIHQuX2xhYmVscyA9IFtdO1xuICB9LFxuICBhZnRlckRhdGFzZXRVcGRhdGU6IGZ1bmN0aW9uKGUsIHQsIHIpIHtcbiAgICB2YXIgYSA9IHQuaW5kZXgsIGkgPSBlW2hdLCBuID0gaS5fZGF0YXNldHNbYV0gPSBbXSwgbyA9IGUuaXNEYXRhc2V0VmlzaWJsZShhKSwgcyA9IGUuZGF0YS5kYXRhc2V0c1thXSwgbCA9IHBlKHMsIHIpLCB1ID0gdC5tZXRhLmRhdGEgfHwgW10sIHYgPSBlLmN0eCwgZCwgeSwgJCwgVCwgUywgQiwgYywgXztcbiAgICBmb3IgKHYuc2F2ZSgpLCBkID0gMCwgJCA9IHUubGVuZ3RoOyBkIDwgJDsgKytkKVxuICAgICAgaWYgKGMgPSB1W2RdLCBjW2hdID0gW10sIG8gJiYgYyAmJiBlLmdldERhdGFWaXNpYmlsaXR5KGQpICYmICFjLnNraXApXG4gICAgICAgIGZvciAoeSA9IDAsIFQgPSBsLmxhYmVscy5sZW5ndGg7IHkgPCBUOyArK3kpXG4gICAgICAgICAgUyA9IGwubGFiZWxzW3ldLCBCID0gUy5fa2V5LCBfID0gbmV3IEwoUywgdiwgYywgZCksIF8uJGdyb3VwcyA9IHtcbiAgICAgICAgICAgIF9zZXQ6IGEsXG4gICAgICAgICAgICBfa2V5OiBCIHx8IFVcbiAgICAgICAgICB9LCBfLiRjb250ZXh0ID0ge1xuICAgICAgICAgICAgYWN0aXZlOiAhMSxcbiAgICAgICAgICAgIGNoYXJ0OiBlLFxuICAgICAgICAgICAgZGF0YUluZGV4OiBkLFxuICAgICAgICAgICAgZGF0YXNldDogcyxcbiAgICAgICAgICAgIGRhdGFzZXRJbmRleDogYVxuICAgICAgICAgIH0sIF8udXBkYXRlKF8uJGNvbnRleHQpLCBjW2hdLnB1c2goXyksIG4ucHVzaChfKTtcbiAgICB2LnJlc3RvcmUoKSwgZyhpLl9saXN0ZW5lcnMsIGwubGlzdGVuZXJzLCB7XG4gICAgICBtZXJnZXI6IGZ1bmN0aW9uKGssIEMsIFgpIHtcbiAgICAgICAgQ1trXSA9IENba10gfHwge30sIENba11bdC5pbmRleF0gPSBYW2tdLCBpLl9saXN0ZW5lZCA9ICEwO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuICBhZnRlclVwZGF0ZTogZnVuY3Rpb24oZSkge1xuICAgIGVbaF0uX2xhYmVscyA9IHcucHJlcGFyZShlW2hdLl9kYXRhc2V0cyk7XG4gIH0sXG4gIC8vIERyYXcgbGFiZWxzIG9uIHRvcCBvZiBhbGwgZGF0YXNldCBlbGVtZW50c1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9jaGFydGpzLXBsdWdpbi1kYXRhbGFiZWxzL2lzc3Vlcy8yOVxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9jaGFydGpzLXBsdWdpbi1kYXRhbGFiZWxzL2lzc3Vlcy8zMlxuICBhZnRlckRhdGFzZXRzRHJhdzogZnVuY3Rpb24oZSkge1xuICAgIHcuZHJhdyhlLCBlW2hdLl9sYWJlbHMpO1xuICB9LFxuICBiZWZvcmVFdmVudDogZnVuY3Rpb24oZSwgdCkge1xuICAgIGlmIChlW2hdLl9saXN0ZW5lZCkge1xuICAgICAgdmFyIHIgPSB0LmV2ZW50O1xuICAgICAgc3dpdGNoIChyLnR5cGUpIHtcbiAgICAgICAgY2FzZSBcIm1vdXNlbW92ZVwiOlxuICAgICAgICBjYXNlIFwibW91c2VvdXRcIjpcbiAgICAgICAgICB3ZShlLCByKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImNsaWNrXCI6XG4gICAgICAgICAgZ2UoZSwgcik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBhZnRlckV2ZW50OiBmdW5jdGlvbihlKSB7XG4gICAgdmFyIHQgPSBlW2hdLCByID0gdC5fYWN0aXZlcywgYSA9IHQuX2FjdGl2ZXMgPSBlLmdldEFjdGl2ZUVsZW1lbnRzKCksIGkgPSBtLmFycmF5RGlmZihyLCBhKSwgbiwgbywgcywgbCwgdSwgdiwgZDtcbiAgICBmb3IgKG4gPSAwLCBvID0gaS5sZW5ndGg7IG4gPCBvOyArK24pXG4gICAgICBpZiAodSA9IGlbbl0sIHVbMV0pXG4gICAgICAgIGZvciAoZCA9IHVbMF0uZWxlbWVudFtoXSB8fCBbXSwgcyA9IDAsIGwgPSBkLmxlbmd0aDsgcyA8IGw7ICsrcylcbiAgICAgICAgICB2ID0gZFtzXSwgdi4kY29udGV4dC5hY3RpdmUgPSB1WzFdID09PSAxLCB2LnVwZGF0ZSh2LiRjb250ZXh0KTtcbiAgICAodC5fZGlydHkgfHwgaS5sZW5ndGgpICYmICh3LnVwZGF0ZSh0Ll9sYWJlbHMpLCBlLnJlbmRlcigpKSwgZGVsZXRlIHQuX2RpcnR5O1xuICB9XG59O1xuZXhwb3J0IHtcbiAgTWUgYXMgZGVmYXVsdFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoYXJ0anMtcGx1Z2luLWRhdGFsYWJlbHMuZXMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=