"use strict";
(self["webpackChunk"] = self["webpackChunk"] || []).push([["vendors-node_modules_tw-elements_dist_js_chart_es_js"],{

/***/ "./node_modules/tw-elements/dist/js/chart.es.js":
/*!******************************************************!*\
  !*** ./node_modules/tw-elements/dist/js/chart.es.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ ye),
/* harmony export */   B: () => (/* binding */ Me),
/* harmony export */   P: () => (/* binding */ ve),
/* harmony export */   a: () => (/* binding */ K),
/* harmony export */   b: () => (/* binding */ D),
/* harmony export */   c: () => (/* binding */ I),
/* harmony export */   d: () => (/* binding */ O),
/* harmony export */   e: () => (/* binding */ E),
/* harmony export */   f: () => (/* binding */ Yc),
/* harmony export */   i: () => (/* binding */ T),
/* harmony export */   m: () => (/* binding */ ne),
/* harmony export */   r: () => (/* binding */ Zt),
/* harmony export */   t: () => (/* binding */ $),
/* harmony export */   v: () => (/* binding */ C)
/* harmony export */ });
/*!
 * Chart.js v3.9.1
 * https://www.chartjs.org
 * (c) 2022 Chart.js Contributors
 * Released under the MIT License
 */
function ct() {
}
const _o = function() {
  let i = 0;
  return function() {
    return i++;
  };
}();
function T(i) {
  return i === null || typeof i > "u";
}
function z(i) {
  if (Array.isArray && Array.isArray(i))
    return !0;
  const t = Object.prototype.toString.call(i);
  return t.slice(0, 7) === "[object" && t.slice(-6) === "Array]";
}
function D(i) {
  return i !== null && Object.prototype.toString.call(i) === "[object Object]";
}
const N = (i) => (typeof i == "number" || i instanceof Number) && isFinite(+i);
function Q(i, t) {
  return N(i) ? i : t;
}
function C(i, t) {
  return typeof i > "u" ? t : i;
}
const yo = (i, t) => typeof i == "string" && i.endsWith("%") ? parseFloat(i) / 100 : i / t, an = (i, t) => typeof i == "string" && i.endsWith("%") ? parseFloat(i) / 100 * t : +i;
function I(i, t, e) {
  if (i && typeof i.call == "function")
    return i.apply(e, t);
}
function E(i, t, e, s) {
  let n, o, r;
  if (z(i))
    if (o = i.length, s)
      for (n = o - 1; n >= 0; n--)
        t.call(e, i[n], n);
    else
      for (n = 0; n < o; n++)
        t.call(e, i[n], n);
  else if (D(i))
    for (r = Object.keys(i), o = r.length, n = 0; n < o; n++)
      t.call(e, i[r[n]], r[n]);
}
function ze(i, t) {
  let e, s, n, o;
  if (!i || !t || i.length !== t.length)
    return !1;
  for (e = 0, s = i.length; e < s; ++e)
    if (n = i[e], o = t[e], n.datasetIndex !== o.datasetIndex || n.index !== o.index)
      return !1;
  return !0;
}
function Be(i) {
  if (z(i))
    return i.map(Be);
  if (D(i)) {
    const t = /* @__PURE__ */ Object.create(null), e = Object.keys(i), s = e.length;
    let n = 0;
    for (; n < s; ++n)
      t[e[n]] = Be(i[e[n]]);
    return t;
  }
  return i;
}
function ln(i) {
  return ["__proto__", "prototype", "constructor"].indexOf(i) === -1;
}
function vo(i, t, e, s) {
  if (!ln(i))
    return;
  const n = t[i], o = e[i];
  D(n) && D(o) ? ne(n, o, s) : t[i] = Be(o);
}
function ne(i, t, e) {
  const s = z(t) ? t : [t], n = s.length;
  if (!D(i))
    return i;
  e = e || {};
  const o = e.merger || vo;
  for (let r = 0; r < n; ++r) {
    if (t = s[r], !D(t))
      continue;
    const a = Object.keys(t);
    for (let l = 0, c = a.length; l < c; ++l)
      o(a[l], i, t, e);
  }
  return i;
}
function Qt(i, t) {
  return ne(i, t, { merger: Mo });
}
function Mo(i, t, e) {
  if (!ln(i))
    return;
  const s = t[i], n = e[i];
  D(s) && D(n) ? Qt(s, n) : Object.prototype.hasOwnProperty.call(t, i) || (t[i] = Be(n));
}
const Xi = {
  "": (i) => i,
  x: (i) => i.x,
  y: (i) => i.y
};
function _t(i, t) {
  return (Xi[t] || (Xi[t] = ko(t)))(i);
}
function ko(i) {
  const t = wo(i);
  return (e) => {
    for (const s of t) {
      if (s === "")
        break;
      e = e && e[s];
    }
    return e;
  };
}
function wo(i) {
  const t = i.split("."), e = [];
  let s = "";
  for (const n of t)
    s += n, s.endsWith("\\") ? s = s.slice(0, -1) + "." : (e.push(s), s = "");
  return e;
}
function Oi(i) {
  return i.charAt(0).toUpperCase() + i.slice(1);
}
const et = (i) => typeof i < "u", yt = (i) => typeof i == "function", Ui = (i, t) => {
  if (i.size !== t.size)
    return !1;
  for (const e of i)
    if (!t.has(e))
      return !1;
  return !0;
};
function So(i) {
  return i.type === "mouseup" || i.type === "click" || i.type === "contextmenu";
}
const B = Math.PI, F = 2 * B, Po = F + B, Ve = Number.POSITIVE_INFINITY, Co = B / 180, V = B / 2, $t = B / 4, Ki = B * 2 / 3, tt = Math.log10, lt = Math.sign;
function qi(i) {
  const t = Math.round(i);
  i = te(i, t, i / 1e3) ? t : i;
  const e = Math.pow(10, Math.floor(tt(i))), s = i / e;
  return (s <= 1 ? 1 : s <= 2 ? 2 : s <= 5 ? 5 : 10) * e;
}
function Do(i) {
  const t = [], e = Math.sqrt(i);
  let s;
  for (s = 1; s < e; s++)
    i % s === 0 && (t.push(s), t.push(i / s));
  return e === (e | 0) && t.push(e), t.sort((n, o) => n - o).pop(), t;
}
function Bt(i) {
  return !isNaN(parseFloat(i)) && isFinite(i);
}
function te(i, t, e) {
  return Math.abs(i - t) < e;
}
function Oo(i, t) {
  const e = Math.round(i);
  return e - t <= i && e + t >= i;
}
function cn(i, t, e) {
  let s, n, o;
  for (s = 0, n = i.length; s < n; s++)
    o = i[s][e], isNaN(o) || (t.min = Math.min(t.min, o), t.max = Math.max(t.max, o));
}
function nt(i) {
  return i * (B / 180);
}
function Ai(i) {
  return i * (180 / B);
}
function Gi(i) {
  if (!N(i))
    return;
  let t = 1, e = 0;
  for (; Math.round(i * t) / t !== i; )
    t *= 10, e++;
  return e;
}
function hn(i, t) {
  const e = t.x - i.x, s = t.y - i.y, n = Math.sqrt(e * e + s * s);
  let o = Math.atan2(s, e);
  return o < -0.5 * B && (o += F), {
    angle: o,
    distance: n
  };
}
function bi(i, t) {
  return Math.sqrt(Math.pow(t.x - i.x, 2) + Math.pow(t.y - i.y, 2));
}
function Ao(i, t) {
  return (i - t + Po) % F - B;
}
function Z(i) {
  return (i % F + F) % F;
}
function oe(i, t, e, s) {
  const n = Z(i), o = Z(t), r = Z(e), a = Z(o - n), l = Z(r - n), c = Z(n - o), h = Z(n - r);
  return n === o || n === r || s && o === r || a > l && c < h;
}
function Y(i, t, e) {
  return Math.max(t, Math.min(e, i));
}
function To(i) {
  return Y(i, -32768, 32767);
}
function ut(i, t, e, s = 1e-6) {
  return i >= Math.min(t, e) - s && i <= Math.max(t, e) + s;
}
function Ti(i, t, e) {
  e = e || ((r) => i[r] < t);
  let s = i.length - 1, n = 0, o;
  for (; s - n > 1; )
    o = n + s >> 1, e(o) ? n = o : s = o;
  return { lo: n, hi: s };
}
const ft = (i, t, e, s) => Ti(i, e, s ? (n) => i[n][t] <= e : (n) => i[n][t] < e), Lo = (i, t, e) => Ti(i, e, (s) => i[s][t] >= e);
function Ro(i, t, e) {
  let s = 0, n = i.length;
  for (; s < n && i[s] < t; )
    s++;
  for (; n > s && i[n - 1] > e; )
    n--;
  return s > 0 || n < i.length ? i.slice(s, n) : i;
}
const dn = ["push", "pop", "shift", "splice", "unshift"];
function Eo(i, t) {
  if (i._chartjs) {
    i._chartjs.listeners.push(t);
    return;
  }
  Object.defineProperty(i, "_chartjs", {
    configurable: !0,
    enumerable: !1,
    value: {
      listeners: [t]
    }
  }), dn.forEach((e) => {
    const s = "_onData" + Oi(e), n = i[e];
    Object.defineProperty(i, e, {
      configurable: !0,
      enumerable: !1,
      value(...o) {
        const r = n.apply(this, o);
        return i._chartjs.listeners.forEach((a) => {
          typeof a[s] == "function" && a[s](...o);
        }), r;
      }
    });
  });
}
function Zi(i, t) {
  const e = i._chartjs;
  if (!e)
    return;
  const s = e.listeners, n = s.indexOf(t);
  n !== -1 && s.splice(n, 1), !(s.length > 0) && (dn.forEach((o) => {
    delete i[o];
  }), delete i._chartjs);
}
function un(i) {
  const t = /* @__PURE__ */ new Set();
  let e, s;
  for (e = 0, s = i.length; e < s; ++e)
    t.add(i[e]);
  return t.size === s ? i : Array.from(t);
}
const fn = function() {
  return typeof window > "u" ? function(i) {
    return i();
  } : window.requestAnimationFrame;
}();
function gn(i, t, e) {
  const s = e || ((r) => Array.prototype.slice.call(r));
  let n = !1, o = [];
  return function(...r) {
    o = s(r), n || (n = !0, fn.call(window, () => {
      n = !1, i.apply(t, o);
    }));
  };
}
function Fo(i, t) {
  let e;
  return function(...s) {
    return t ? (clearTimeout(e), e = setTimeout(i, t, s)) : i.apply(this, s), t;
  };
}
const Li = (i) => i === "start" ? "left" : i === "end" ? "right" : "center", U = (i, t, e) => i === "start" ? t : i === "end" ? e : (t + e) / 2, Io = (i, t, e, s) => i === (s ? "left" : "right") ? e : i === "center" ? (t + e) / 2 : t;
function pn(i, t, e) {
  const s = t.length;
  let n = 0, o = s;
  if (i._sorted) {
    const { iScale: r, _parsed: a } = i, l = r.axis, { min: c, max: h, minDefined: d, maxDefined: u } = r.getUserBounds();
    d && (n = Y(
      Math.min(
        ft(a, r.axis, c).lo,
        e ? s : ft(t, l, r.getPixelForValue(c)).lo
      ),
      0,
      s - 1
    )), u ? o = Y(
      Math.max(
        ft(a, r.axis, h, !0).hi + 1,
        e ? 0 : ft(t, l, r.getPixelForValue(h), !0).hi + 1
      ),
      n,
      s
    ) - n : o = s - n;
  }
  return { start: n, count: o };
}
function mn(i) {
  const { xScale: t, yScale: e, _scaleRanges: s } = i, n = {
    xmin: t.min,
    xmax: t.max,
    ymin: e.min,
    ymax: e.max
  };
  if (!s)
    return i._scaleRanges = n, !0;
  const o = s.xmin !== t.min || s.xmax !== t.max || s.ymin !== e.min || s.ymax !== e.max;
  return Object.assign(s, n), o;
}
const we = (i) => i === 0 || i === 1, Ji = (i, t, e) => -(Math.pow(2, 10 * (i -= 1)) * Math.sin((i - t) * F / e)), Qi = (i, t, e) => Math.pow(2, -10 * i) * Math.sin((i - t) * F / e) + 1, ee = {
  linear: (i) => i,
  easeInQuad: (i) => i * i,
  easeOutQuad: (i) => -i * (i - 2),
  easeInOutQuad: (i) => (i /= 0.5) < 1 ? 0.5 * i * i : -0.5 * (--i * (i - 2) - 1),
  easeInCubic: (i) => i * i * i,
  easeOutCubic: (i) => (i -= 1) * i * i + 1,
  easeInOutCubic: (i) => (i /= 0.5) < 1 ? 0.5 * i * i * i : 0.5 * ((i -= 2) * i * i + 2),
  easeInQuart: (i) => i * i * i * i,
  easeOutQuart: (i) => -((i -= 1) * i * i * i - 1),
  easeInOutQuart: (i) => (i /= 0.5) < 1 ? 0.5 * i * i * i * i : -0.5 * ((i -= 2) * i * i * i - 2),
  easeInQuint: (i) => i * i * i * i * i,
  easeOutQuint: (i) => (i -= 1) * i * i * i * i + 1,
  easeInOutQuint: (i) => (i /= 0.5) < 1 ? 0.5 * i * i * i * i * i : 0.5 * ((i -= 2) * i * i * i * i + 2),
  easeInSine: (i) => -Math.cos(i * V) + 1,
  easeOutSine: (i) => Math.sin(i * V),
  easeInOutSine: (i) => -0.5 * (Math.cos(B * i) - 1),
  easeInExpo: (i) => i === 0 ? 0 : Math.pow(2, 10 * (i - 1)),
  easeOutExpo: (i) => i === 1 ? 1 : -Math.pow(2, -10 * i) + 1,
  easeInOutExpo: (i) => we(i) ? i : i < 0.5 ? 0.5 * Math.pow(2, 10 * (i * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (i * 2 - 1)) + 2),
  easeInCirc: (i) => i >= 1 ? i : -(Math.sqrt(1 - i * i) - 1),
  easeOutCirc: (i) => Math.sqrt(1 - (i -= 1) * i),
  easeInOutCirc: (i) => (i /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - i * i) - 1) : 0.5 * (Math.sqrt(1 - (i -= 2) * i) + 1),
  easeInElastic: (i) => we(i) ? i : Ji(i, 0.075, 0.3),
  easeOutElastic: (i) => we(i) ? i : Qi(i, 0.075, 0.3),
  easeInOutElastic(i) {
    return we(i) ? i : i < 0.5 ? 0.5 * Ji(i * 2, 0.1125, 0.45) : 0.5 + 0.5 * Qi(i * 2 - 1, 0.1125, 0.45);
  },
  easeInBack(i) {
    return i * i * ((1.70158 + 1) * i - 1.70158);
  },
  easeOutBack(i) {
    return (i -= 1) * i * ((1.70158 + 1) * i + 1.70158) + 1;
  },
  easeInOutBack(i) {
    let t = 1.70158;
    return (i /= 0.5) < 1 ? 0.5 * (i * i * (((t *= 1.525) + 1) * i - t)) : 0.5 * ((i -= 2) * i * (((t *= 1.525) + 1) * i + t) + 2);
  },
  easeInBounce: (i) => 1 - ee.easeOutBounce(1 - i),
  easeOutBounce(i) {
    return i < 1 / 2.75 ? 7.5625 * i * i : i < 2 / 2.75 ? 7.5625 * (i -= 1.5 / 2.75) * i + 0.75 : i < 2.5 / 2.75 ? 7.5625 * (i -= 2.25 / 2.75) * i + 0.9375 : 7.5625 * (i -= 2.625 / 2.75) * i + 0.984375;
  },
  easeInOutBounce: (i) => i < 0.5 ? ee.easeInBounce(i * 2) * 0.5 : ee.easeOutBounce(i * 2 - 1) * 0.5 + 0.5
};
/*!
 * @kurkle/color v0.2.1
 * https://github.com/kurkle/color#readme
 * (c) 2022 Jukka Kurkela
 * Released under the MIT License
 */
function he(i) {
  return i + 0.5 | 0;
}
const mt = (i, t, e) => Math.max(Math.min(i, e), t);
function Gt(i) {
  return mt(he(i * 2.55), 0, 255);
}
function xt(i) {
  return mt(he(i * 255), 0, 255);
}
function dt(i) {
  return mt(he(i / 2.55) / 100, 0, 1);
}
function ts(i) {
  return mt(he(i * 100), 0, 100);
}
const J = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 }, xi = [..."0123456789ABCDEF"], zo = (i) => xi[i & 15], Bo = (i) => xi[(i & 240) >> 4] + xi[i & 15], Se = (i) => (i & 240) >> 4 === (i & 15), Vo = (i) => Se(i.r) && Se(i.g) && Se(i.b) && Se(i.a);
function Wo(i) {
  var t = i.length, e;
  return i[0] === "#" && (t === 4 || t === 5 ? e = {
    r: 255 & J[i[1]] * 17,
    g: 255 & J[i[2]] * 17,
    b: 255 & J[i[3]] * 17,
    a: t === 5 ? J[i[4]] * 17 : 255
  } : (t === 7 || t === 9) && (e = {
    r: J[i[1]] << 4 | J[i[2]],
    g: J[i[3]] << 4 | J[i[4]],
    b: J[i[5]] << 4 | J[i[6]],
    a: t === 9 ? J[i[7]] << 4 | J[i[8]] : 255
  })), e;
}
const No = (i, t) => i < 255 ? t(i) : "";
function Ho(i) {
  var t = Vo(i) ? zo : Bo;
  return i ? "#" + t(i.r) + t(i.g) + t(i.b) + No(i.a, t) : void 0;
}
const jo = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
function bn(i, t, e) {
  const s = t * Math.min(e, 1 - e), n = (o, r = (o + i / 30) % 12) => e - s * Math.max(Math.min(r - 3, 9 - r, 1), -1);
  return [n(0), n(8), n(4)];
}
function $o(i, t, e) {
  const s = (n, o = (n + i / 60) % 6) => e - e * t * Math.max(Math.min(o, 4 - o, 1), 0);
  return [s(5), s(3), s(1)];
}
function Yo(i, t, e) {
  const s = bn(i, 1, 0.5);
  let n;
  for (t + e > 1 && (n = 1 / (t + e), t *= n, e *= n), n = 0; n < 3; n++)
    s[n] *= 1 - t - e, s[n] += t;
  return s;
}
function Xo(i, t, e, s, n) {
  return i === n ? (t - e) / s + (t < e ? 6 : 0) : t === n ? (e - i) / s + 2 : (i - t) / s + 4;
}
function Ri(i) {
  const e = i.r / 255, s = i.g / 255, n = i.b / 255, o = Math.max(e, s, n), r = Math.min(e, s, n), a = (o + r) / 2;
  let l, c, h;
  return o !== r && (h = o - r, c = a > 0.5 ? h / (2 - o - r) : h / (o + r), l = Xo(e, s, n, h, o), l = l * 60 + 0.5), [l | 0, c || 0, a];
}
function Ei(i, t, e, s) {
  return (Array.isArray(t) ? i(t[0], t[1], t[2]) : i(t, e, s)).map(xt);
}
function Fi(i, t, e) {
  return Ei(bn, i, t, e);
}
function Uo(i, t, e) {
  return Ei(Yo, i, t, e);
}
function Ko(i, t, e) {
  return Ei($o, i, t, e);
}
function xn(i) {
  return (i % 360 + 360) % 360;
}
function qo(i) {
  const t = jo.exec(i);
  let e = 255, s;
  if (!t)
    return;
  t[5] !== s && (e = t[6] ? Gt(+t[5]) : xt(+t[5]));
  const n = xn(+t[2]), o = +t[3] / 100, r = +t[4] / 100;
  return t[1] === "hwb" ? s = Uo(n, o, r) : t[1] === "hsv" ? s = Ko(n, o, r) : s = Fi(n, o, r), {
    r: s[0],
    g: s[1],
    b: s[2],
    a: e
  };
}
function Go(i, t) {
  var e = Ri(i);
  e[0] = xn(e[0] + t), e = Fi(e), i.r = e[0], i.g = e[1], i.b = e[2];
}
function Zo(i) {
  if (!i)
    return;
  const t = Ri(i), e = t[0], s = ts(t[1]), n = ts(t[2]);
  return i.a < 255 ? `hsla(${e}, ${s}%, ${n}%, ${dt(i.a)})` : `hsl(${e}, ${s}%, ${n}%)`;
}
const es = {
  x: "dark",
  Z: "light",
  Y: "re",
  X: "blu",
  W: "gr",
  V: "medium",
  U: "slate",
  A: "ee",
  T: "ol",
  S: "or",
  B: "ra",
  C: "lateg",
  D: "ights",
  R: "in",
  Q: "turquois",
  E: "hi",
  P: "ro",
  O: "al",
  N: "le",
  M: "de",
  L: "yello",
  F: "en",
  K: "ch",
  G: "arks",
  H: "ea",
  I: "ightg",
  J: "wh"
}, is = {
  OiceXe: "f0f8ff",
  antiquewEte: "faebd7",
  aqua: "ffff",
  aquamarRe: "7fffd4",
  azuY: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "0",
  blanKedOmond: "ffebcd",
  Xe: "ff",
  XeviTet: "8a2be2",
  bPwn: "a52a2a",
  burlywood: "deb887",
  caMtXe: "5f9ea0",
  KartYuse: "7fff00",
  KocTate: "d2691e",
  cSO: "ff7f50",
  cSnflowerXe: "6495ed",
  cSnsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "ffff",
  xXe: "8b",
  xcyan: "8b8b",
  xgTMnPd: "b8860b",
  xWay: "a9a9a9",
  xgYF: "6400",
  xgYy: "a9a9a9",
  xkhaki: "bdb76b",
  xmagFta: "8b008b",
  xTivegYF: "556b2f",
  xSange: "ff8c00",
  xScEd: "9932cc",
  xYd: "8b0000",
  xsOmon: "e9967a",
  xsHgYF: "8fbc8f",
  xUXe: "483d8b",
  xUWay: "2f4f4f",
  xUgYy: "2f4f4f",
  xQe: "ced1",
  xviTet: "9400d3",
  dAppRk: "ff1493",
  dApskyXe: "bfff",
  dimWay: "696969",
  dimgYy: "696969",
  dodgerXe: "1e90ff",
  fiYbrick: "b22222",
  flSOwEte: "fffaf0",
  foYstWAn: "228b22",
  fuKsia: "ff00ff",
  gaRsbSo: "dcdcdc",
  ghostwEte: "f8f8ff",
  gTd: "ffd700",
  gTMnPd: "daa520",
  Way: "808080",
  gYF: "8000",
  gYFLw: "adff2f",
  gYy: "808080",
  honeyMw: "f0fff0",
  hotpRk: "ff69b4",
  RdianYd: "cd5c5c",
  Rdigo: "4b0082",
  ivSy: "fffff0",
  khaki: "f0e68c",
  lavFMr: "e6e6fa",
  lavFMrXsh: "fff0f5",
  lawngYF: "7cfc00",
  NmoncEffon: "fffacd",
  ZXe: "add8e6",
  ZcSO: "f08080",
  Zcyan: "e0ffff",
  ZgTMnPdLw: "fafad2",
  ZWay: "d3d3d3",
  ZgYF: "90ee90",
  ZgYy: "d3d3d3",
  ZpRk: "ffb6c1",
  ZsOmon: "ffa07a",
  ZsHgYF: "20b2aa",
  ZskyXe: "87cefa",
  ZUWay: "778899",
  ZUgYy: "778899",
  ZstAlXe: "b0c4de",
  ZLw: "ffffe0",
  lime: "ff00",
  limegYF: "32cd32",
  lRF: "faf0e6",
  magFta: "ff00ff",
  maPon: "800000",
  VaquamarRe: "66cdaa",
  VXe: "cd",
  VScEd: "ba55d3",
  VpurpN: "9370db",
  VsHgYF: "3cb371",
  VUXe: "7b68ee",
  VsprRggYF: "fa9a",
  VQe: "48d1cc",
  VviTetYd: "c71585",
  midnightXe: "191970",
  mRtcYam: "f5fffa",
  mistyPse: "ffe4e1",
  moccasR: "ffe4b5",
  navajowEte: "ffdead",
  navy: "80",
  Tdlace: "fdf5e6",
  Tive: "808000",
  TivedBb: "6b8e23",
  Sange: "ffa500",
  SangeYd: "ff4500",
  ScEd: "da70d6",
  pOegTMnPd: "eee8aa",
  pOegYF: "98fb98",
  pOeQe: "afeeee",
  pOeviTetYd: "db7093",
  papayawEp: "ffefd5",
  pHKpuff: "ffdab9",
  peru: "cd853f",
  pRk: "ffc0cb",
  plum: "dda0dd",
  powMrXe: "b0e0e6",
  purpN: "800080",
  YbeccapurpN: "663399",
  Yd: "ff0000",
  Psybrown: "bc8f8f",
  PyOXe: "4169e1",
  saddNbPwn: "8b4513",
  sOmon: "fa8072",
  sandybPwn: "f4a460",
  sHgYF: "2e8b57",
  sHshell: "fff5ee",
  siFna: "a0522d",
  silver: "c0c0c0",
  skyXe: "87ceeb",
  UXe: "6a5acd",
  UWay: "708090",
  UgYy: "708090",
  snow: "fffafa",
  sprRggYF: "ff7f",
  stAlXe: "4682b4",
  tan: "d2b48c",
  teO: "8080",
  tEstN: "d8bfd8",
  tomato: "ff6347",
  Qe: "40e0d0",
  viTet: "ee82ee",
  JHt: "f5deb3",
  wEte: "ffffff",
  wEtesmoke: "f5f5f5",
  Lw: "ffff00",
  LwgYF: "9acd32"
};
function Jo() {
  const i = {}, t = Object.keys(is), e = Object.keys(es);
  let s, n, o, r, a;
  for (s = 0; s < t.length; s++) {
    for (r = a = t[s], n = 0; n < e.length; n++)
      o = e[n], a = a.replace(o, es[o]);
    o = parseInt(is[r], 16), i[a] = [o >> 16 & 255, o >> 8 & 255, o & 255];
  }
  return i;
}
let Pe;
function Qo(i) {
  Pe || (Pe = Jo(), Pe.transparent = [0, 0, 0, 0]);
  const t = Pe[i.toLowerCase()];
  return t && {
    r: t[0],
    g: t[1],
    b: t[2],
    a: t.length === 4 ? t[3] : 255
  };
}
const tr = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
function er(i) {
  const t = tr.exec(i);
  let e = 255, s, n, o;
  if (t) {
    if (t[7] !== s) {
      const r = +t[7];
      e = t[8] ? Gt(r) : mt(r * 255, 0, 255);
    }
    return s = +t[1], n = +t[3], o = +t[5], s = 255 & (t[2] ? Gt(s) : mt(s, 0, 255)), n = 255 & (t[4] ? Gt(n) : mt(n, 0, 255)), o = 255 & (t[6] ? Gt(o) : mt(o, 0, 255)), {
      r: s,
      g: n,
      b: o,
      a: e
    };
  }
}
function ir(i) {
  return i && (i.a < 255 ? `rgba(${i.r}, ${i.g}, ${i.b}, ${dt(i.a)})` : `rgb(${i.r}, ${i.g}, ${i.b})`);
}
const ni = (i) => i <= 31308e-7 ? i * 12.92 : Math.pow(i, 1 / 2.4) * 1.055 - 0.055, Ft = (i) => i <= 0.04045 ? i / 12.92 : Math.pow((i + 0.055) / 1.055, 2.4);
function sr(i, t, e) {
  const s = Ft(dt(i.r)), n = Ft(dt(i.g)), o = Ft(dt(i.b));
  return {
    r: xt(ni(s + e * (Ft(dt(t.r)) - s))),
    g: xt(ni(n + e * (Ft(dt(t.g)) - n))),
    b: xt(ni(o + e * (Ft(dt(t.b)) - o))),
    a: i.a + e * (t.a - i.a)
  };
}
function Ce(i, t, e) {
  if (i) {
    let s = Ri(i);
    s[t] = Math.max(0, Math.min(s[t] + s[t] * e, t === 0 ? 360 : 1)), s = Fi(s), i.r = s[0], i.g = s[1], i.b = s[2];
  }
}
function _n(i, t) {
  return i && Object.assign(t || {}, i);
}
function ss(i) {
  var t = { r: 0, g: 0, b: 0, a: 255 };
  return Array.isArray(i) ? i.length >= 3 && (t = { r: i[0], g: i[1], b: i[2], a: 255 }, i.length > 3 && (t.a = xt(i[3]))) : (t = _n(i, { r: 0, g: 0, b: 0, a: 1 }), t.a = xt(t.a)), t;
}
function nr(i) {
  return i.charAt(0) === "r" ? er(i) : qo(i);
}
class We {
  constructor(t) {
    if (t instanceof We)
      return t;
    const e = typeof t;
    let s;
    e === "object" ? s = ss(t) : e === "string" && (s = Wo(t) || Qo(t) || nr(t)), this._rgb = s, this._valid = !!s;
  }
  get valid() {
    return this._valid;
  }
  get rgb() {
    var t = _n(this._rgb);
    return t && (t.a = dt(t.a)), t;
  }
  set rgb(t) {
    this._rgb = ss(t);
  }
  rgbString() {
    return this._valid ? ir(this._rgb) : void 0;
  }
  hexString() {
    return this._valid ? Ho(this._rgb) : void 0;
  }
  hslString() {
    return this._valid ? Zo(this._rgb) : void 0;
  }
  mix(t, e) {
    if (t) {
      const s = this.rgb, n = t.rgb;
      let o;
      const r = e === o ? 0.5 : e, a = 2 * r - 1, l = s.a - n.a, c = ((a * l === -1 ? a : (a + l) / (1 + a * l)) + 1) / 2;
      o = 1 - c, s.r = 255 & c * s.r + o * n.r + 0.5, s.g = 255 & c * s.g + o * n.g + 0.5, s.b = 255 & c * s.b + o * n.b + 0.5, s.a = r * s.a + (1 - r) * n.a, this.rgb = s;
    }
    return this;
  }
  interpolate(t, e) {
    return t && (this._rgb = sr(this._rgb, t._rgb, e)), this;
  }
  clone() {
    return new We(this.rgb);
  }
  alpha(t) {
    return this._rgb.a = xt(t), this;
  }
  clearer(t) {
    const e = this._rgb;
    return e.a *= 1 - t, this;
  }
  greyscale() {
    const t = this._rgb, e = he(t.r * 0.3 + t.g * 0.59 + t.b * 0.11);
    return t.r = t.g = t.b = e, this;
  }
  opaquer(t) {
    const e = this._rgb;
    return e.a *= 1 + t, this;
  }
  negate() {
    const t = this._rgb;
    return t.r = 255 - t.r, t.g = 255 - t.g, t.b = 255 - t.b, this;
  }
  lighten(t) {
    return Ce(this._rgb, 2, t), this;
  }
  darken(t) {
    return Ce(this._rgb, 2, -t), this;
  }
  saturate(t) {
    return Ce(this._rgb, 1, t), this;
  }
  desaturate(t) {
    return Ce(this._rgb, 1, -t), this;
  }
  rotate(t) {
    return Go(this._rgb, t), this;
  }
}
function yn(i) {
  return new We(i);
}
function vn(i) {
  if (i && typeof i == "object") {
    const t = i.toString();
    return t === "[object CanvasPattern]" || t === "[object CanvasGradient]";
  }
  return !1;
}
function ns(i) {
  return vn(i) ? i : yn(i);
}
function oi(i) {
  return vn(i) ? i : yn(i).saturate(0.5).darken(0.1).hexString();
}
const At = /* @__PURE__ */ Object.create(null), _i = /* @__PURE__ */ Object.create(null);
function ie(i, t) {
  if (!t)
    return i;
  const e = t.split(".");
  for (let s = 0, n = e.length; s < n; ++s) {
    const o = e[s];
    i = i[o] || (i[o] = /* @__PURE__ */ Object.create(null));
  }
  return i;
}
function ri(i, t, e) {
  return typeof t == "string" ? ne(ie(i, t), e) : ne(ie(i, ""), t);
}
class or {
  constructor(t) {
    this.animation = void 0, this.backgroundColor = "rgba(0,0,0,0.1)", this.borderColor = "rgba(0,0,0,0.1)", this.color = "#666", this.datasets = {}, this.devicePixelRatio = (e) => e.chart.platform.getDevicePixelRatio(), this.elements = {}, this.events = [
      "mousemove",
      "mouseout",
      "click",
      "touchstart",
      "touchmove"
    ], this.font = {
      family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
      size: 12,
      style: "normal",
      lineHeight: 1.2,
      weight: null
    }, this.hover = {}, this.hoverBackgroundColor = (e, s) => oi(s.backgroundColor), this.hoverBorderColor = (e, s) => oi(s.borderColor), this.hoverColor = (e, s) => oi(s.color), this.indexAxis = "x", this.interaction = {
      mode: "nearest",
      intersect: !0,
      includeInvisible: !1
    }, this.maintainAspectRatio = !0, this.onHover = null, this.onClick = null, this.parsing = !0, this.plugins = {}, this.responsive = !0, this.scale = void 0, this.scales = {}, this.showLine = !0, this.drawActiveElementsOnTop = !0, this.describe(t);
  }
  set(t, e) {
    return ri(this, t, e);
  }
  get(t) {
    return ie(this, t);
  }
  describe(t, e) {
    return ri(_i, t, e);
  }
  override(t, e) {
    return ri(At, t, e);
  }
  route(t, e, s, n) {
    const o = ie(this, t), r = ie(this, s), a = "_" + e;
    Object.defineProperties(o, {
      [a]: {
        value: o[e],
        writable: !0
      },
      [e]: {
        enumerable: !0,
        get() {
          const l = this[a], c = r[n];
          return D(l) ? Object.assign({}, c, l) : C(l, c);
        },
        set(l) {
          this[a] = l;
        }
      }
    });
  }
}
var O = new or({
  _scriptable: (i) => !i.startsWith("on"),
  _indexable: (i) => i !== "events",
  hover: {
    _fallback: "interaction"
  },
  interaction: {
    _scriptable: !1,
    _indexable: !1
  }
});
function rr(i) {
  return !i || T(i.size) || T(i.family) ? null : (i.style ? i.style + " " : "") + (i.weight ? i.weight + " " : "") + i.size + "px " + i.family;
}
function Ne(i, t, e, s, n) {
  let o = t[n];
  return o || (o = t[n] = i.measureText(n).width, e.push(n)), o > s && (s = o), s;
}
function ar(i, t, e, s) {
  s = s || {};
  let n = s.data = s.data || {}, o = s.garbageCollect = s.garbageCollect || [];
  s.font !== t && (n = s.data = {}, o = s.garbageCollect = [], s.font = t), i.save(), i.font = t;
  let r = 0;
  const a = e.length;
  let l, c, h, d, u;
  for (l = 0; l < a; l++)
    if (d = e[l], d != null && z(d) !== !0)
      r = Ne(i, n, o, r, d);
    else if (z(d))
      for (c = 0, h = d.length; c < h; c++)
        u = d[c], u != null && !z(u) && (r = Ne(i, n, o, r, u));
  i.restore();
  const f = o.length / 2;
  if (f > e.length) {
    for (l = 0; l < f; l++)
      delete n[o[l]];
    o.splice(0, f);
  }
  return r;
}
function wt(i, t, e) {
  const s = i.currentDevicePixelRatio, n = e !== 0 ? Math.max(e / 2, 0.5) : 0;
  return Math.round((t - n) * s) / s + n;
}
function os(i, t) {
  t = t || i.getContext("2d"), t.save(), t.resetTransform(), t.clearRect(0, 0, i.width, i.height), t.restore();
}
function yi(i, t, e, s) {
  Mn(i, t, e, s, null);
}
function Mn(i, t, e, s, n) {
  let o, r, a, l, c, h;
  const d = t.pointStyle, u = t.rotation, f = t.radius;
  let g = (u || 0) * Co;
  if (d && typeof d == "object" && (o = d.toString(), o === "[object HTMLImageElement]" || o === "[object HTMLCanvasElement]")) {
    i.save(), i.translate(e, s), i.rotate(g), i.drawImage(d, -d.width / 2, -d.height / 2, d.width, d.height), i.restore();
    return;
  }
  if (!(isNaN(f) || f <= 0)) {
    switch (i.beginPath(), d) {
      default:
        n ? i.ellipse(e, s, n / 2, f, 0, 0, F) : i.arc(e, s, f, 0, F), i.closePath();
        break;
      case "triangle":
        i.moveTo(e + Math.sin(g) * f, s - Math.cos(g) * f), g += Ki, i.lineTo(e + Math.sin(g) * f, s - Math.cos(g) * f), g += Ki, i.lineTo(e + Math.sin(g) * f, s - Math.cos(g) * f), i.closePath();
        break;
      case "rectRounded":
        c = f * 0.516, l = f - c, r = Math.cos(g + $t) * l, a = Math.sin(g + $t) * l, i.arc(e - r, s - a, c, g - B, g - V), i.arc(e + a, s - r, c, g - V, g), i.arc(e + r, s + a, c, g, g + V), i.arc(e - a, s + r, c, g + V, g + B), i.closePath();
        break;
      case "rect":
        if (!u) {
          l = Math.SQRT1_2 * f, h = n ? n / 2 : l, i.rect(e - h, s - l, 2 * h, 2 * l);
          break;
        }
        g += $t;
      case "rectRot":
        r = Math.cos(g) * f, a = Math.sin(g) * f, i.moveTo(e - r, s - a), i.lineTo(e + a, s - r), i.lineTo(e + r, s + a), i.lineTo(e - a, s + r), i.closePath();
        break;
      case "crossRot":
        g += $t;
      case "cross":
        r = Math.cos(g) * f, a = Math.sin(g) * f, i.moveTo(e - r, s - a), i.lineTo(e + r, s + a), i.moveTo(e + a, s - r), i.lineTo(e - a, s + r);
        break;
      case "star":
        r = Math.cos(g) * f, a = Math.sin(g) * f, i.moveTo(e - r, s - a), i.lineTo(e + r, s + a), i.moveTo(e + a, s - r), i.lineTo(e - a, s + r), g += $t, r = Math.cos(g) * f, a = Math.sin(g) * f, i.moveTo(e - r, s - a), i.lineTo(e + r, s + a), i.moveTo(e + a, s - r), i.lineTo(e - a, s + r);
        break;
      case "line":
        r = n ? n / 2 : Math.cos(g) * f, a = Math.sin(g) * f, i.moveTo(e - r, s - a), i.lineTo(e + r, s + a);
        break;
      case "dash":
        i.moveTo(e, s), i.lineTo(e + Math.cos(g) * f, s + Math.sin(g) * f);
        break;
    }
    i.fill(), t.borderWidth > 0 && i.stroke();
  }
}
function re(i, t, e) {
  return e = e || 0.5, !t || i && i.x > t.left - e && i.x < t.right + e && i.y > t.top - e && i.y < t.bottom + e;
}
function Xe(i, t) {
  i.save(), i.beginPath(), i.rect(t.left, t.top, t.right - t.left, t.bottom - t.top), i.clip();
}
function Ue(i) {
  i.restore();
}
function lr(i, t, e, s, n) {
  if (!t)
    return i.lineTo(e.x, e.y);
  if (n === "middle") {
    const o = (t.x + e.x) / 2;
    i.lineTo(o, t.y), i.lineTo(o, e.y);
  } else
    n === "after" != !!s ? i.lineTo(t.x, e.y) : i.lineTo(e.x, t.y);
  i.lineTo(e.x, e.y);
}
function cr(i, t, e, s) {
  if (!t)
    return i.lineTo(e.x, e.y);
  i.bezierCurveTo(
    s ? t.cp1x : t.cp2x,
    s ? t.cp1y : t.cp2y,
    s ? e.cp2x : e.cp1x,
    s ? e.cp2y : e.cp1y,
    e.x,
    e.y
  );
}
function Tt(i, t, e, s, n, o = {}) {
  const r = z(t) ? t : [t], a = o.strokeWidth > 0 && o.strokeColor !== "";
  let l, c;
  for (i.save(), i.font = n.string, hr(i, o), l = 0; l < r.length; ++l)
    c = r[l], a && (o.strokeColor && (i.strokeStyle = o.strokeColor), T(o.strokeWidth) || (i.lineWidth = o.strokeWidth), i.strokeText(c, e, s, o.maxWidth)), i.fillText(c, e, s, o.maxWidth), dr(i, e, s, c, o), s += n.lineHeight;
  i.restore();
}
function hr(i, t) {
  t.translation && i.translate(t.translation[0], t.translation[1]), T(t.rotation) || i.rotate(t.rotation), t.color && (i.fillStyle = t.color), t.textAlign && (i.textAlign = t.textAlign), t.textBaseline && (i.textBaseline = t.textBaseline);
}
function dr(i, t, e, s, n) {
  if (n.strikethrough || n.underline) {
    const o = i.measureText(s), r = t - o.actualBoundingBoxLeft, a = t + o.actualBoundingBoxRight, l = e - o.actualBoundingBoxAscent, c = e + o.actualBoundingBoxDescent, h = n.strikethrough ? (l + c) / 2 : c;
    i.strokeStyle = i.fillStyle, i.beginPath(), i.lineWidth = n.decorationWidth || 2, i.moveTo(r, h), i.lineTo(a, h), i.stroke();
  }
}
function ae(i, t) {
  const { x: e, y: s, w: n, h: o, radius: r } = t;
  i.arc(e + r.topLeft, s + r.topLeft, r.topLeft, -V, B, !0), i.lineTo(e, s + o - r.bottomLeft), i.arc(e + r.bottomLeft, s + o - r.bottomLeft, r.bottomLeft, B, V, !0), i.lineTo(e + n - r.bottomRight, s + o), i.arc(e + n - r.bottomRight, s + o - r.bottomRight, r.bottomRight, V, 0, !0), i.lineTo(e + n, s + r.topRight), i.arc(e + n - r.topRight, s + r.topRight, r.topRight, 0, -V, !0), i.lineTo(e + r.topLeft, s);
}
const ur = new RegExp(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/), fr = new RegExp(/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/);
function gr(i, t) {
  const e = ("" + i).match(ur);
  if (!e || e[1] === "normal")
    return t * 1.2;
  switch (i = +e[2], e[3]) {
    case "px":
      return i;
    case "%":
      i /= 100;
      break;
  }
  return t * i;
}
const pr = (i) => +i || 0;
function Ii(i, t) {
  const e = {}, s = D(t), n = s ? Object.keys(t) : t, o = D(i) ? s ? (r) => C(i[r], i[t[r]]) : (r) => i[r] : () => i;
  for (const r of n)
    e[r] = pr(o(r));
  return e;
}
function kn(i) {
  return Ii(i, { top: "y", right: "x", bottom: "y", left: "x" });
}
function Dt(i) {
  return Ii(i, ["topLeft", "topRight", "bottomLeft", "bottomRight"]);
}
function K(i) {
  const t = kn(i);
  return t.width = t.left + t.right, t.height = t.top + t.bottom, t;
}
function $(i, t) {
  i = i || {}, t = t || O.font;
  let e = C(i.size, t.size);
  typeof e == "string" && (e = parseInt(e, 10));
  let s = C(i.style, t.style);
  s && !("" + s).match(fr) && (console.warn('Invalid font style specified: "' + s + '"'), s = "");
  const n = {
    family: C(i.family, t.family),
    lineHeight: gr(C(i.lineHeight, t.lineHeight), e),
    size: e,
    style: s,
    weight: C(i.weight, t.weight),
    string: ""
  };
  return n.string = rr(n), n;
}
function Zt(i, t, e, s) {
  let n = !0, o, r, a;
  for (o = 0, r = i.length; o < r; ++o)
    if (a = i[o], a !== void 0 && (t !== void 0 && typeof a == "function" && (a = a(t), n = !1), e !== void 0 && z(a) && (a = a[e % a.length], n = !1), a !== void 0))
      return s && !n && (s.cacheable = !1), a;
}
function mr(i, t, e) {
  const { min: s, max: n } = i, o = an(t, (n - s) / 2), r = (a, l) => e && a === 0 ? 0 : a + l;
  return {
    min: r(s, -Math.abs(o)),
    max: r(n, o)
  };
}
function vt(i, t) {
  return Object.assign(Object.create(i), t);
}
function zi(i, t = [""], e = i, s, n = () => i[0]) {
  et(s) || (s = Cn("_fallback", i));
  const o = {
    [Symbol.toStringTag]: "Object",
    _cacheable: !0,
    _scopes: i,
    _rootScopes: e,
    _fallback: s,
    _getTarget: n,
    override: (r) => zi([r, ...i], t, e, s)
  };
  return new Proxy(o, {
    deleteProperty(r, a) {
      return delete r[a], delete r._keys, delete i[0][a], !0;
    },
    get(r, a) {
      return Sn(
        r,
        a,
        () => wr(a, t, i, r)
      );
    },
    getOwnPropertyDescriptor(r, a) {
      return Reflect.getOwnPropertyDescriptor(r._scopes[0], a);
    },
    getPrototypeOf() {
      return Reflect.getPrototypeOf(i[0]);
    },
    has(r, a) {
      return as(r).includes(a);
    },
    ownKeys(r) {
      return as(r);
    },
    set(r, a, l) {
      const c = r._storage || (r._storage = n());
      return r[a] = c[a] = l, delete r._keys, !0;
    }
  });
}
function Vt(i, t, e, s) {
  const n = {
    _cacheable: !1,
    _proxy: i,
    _context: t,
    _subProxy: e,
    _stack: /* @__PURE__ */ new Set(),
    _descriptors: wn(i, s),
    setContext: (o) => Vt(i, o, e, s),
    override: (o) => Vt(i.override(o), t, e, s)
  };
  return new Proxy(n, {
    deleteProperty(o, r) {
      return delete o[r], delete i[r], !0;
    },
    get(o, r, a) {
      return Sn(
        o,
        r,
        () => xr(o, r, a)
      );
    },
    getOwnPropertyDescriptor(o, r) {
      return o._descriptors.allKeys ? Reflect.has(i, r) ? { enumerable: !0, configurable: !0 } : void 0 : Reflect.getOwnPropertyDescriptor(i, r);
    },
    getPrototypeOf() {
      return Reflect.getPrototypeOf(i);
    },
    has(o, r) {
      return Reflect.has(i, r);
    },
    ownKeys() {
      return Reflect.ownKeys(i);
    },
    set(o, r, a) {
      return i[r] = a, delete o[r], !0;
    }
  });
}
function wn(i, t = { scriptable: !0, indexable: !0 }) {
  const { _scriptable: e = t.scriptable, _indexable: s = t.indexable, _allKeys: n = t.allKeys } = i;
  return {
    allKeys: n,
    scriptable: e,
    indexable: s,
    isScriptable: yt(e) ? e : () => e,
    isIndexable: yt(s) ? s : () => s
  };
}
const br = (i, t) => i ? i + Oi(t) : t, Bi = (i, t) => D(t) && i !== "adapters" && (Object.getPrototypeOf(t) === null || t.constructor === Object);
function Sn(i, t, e) {
  if (Object.prototype.hasOwnProperty.call(i, t))
    return i[t];
  const s = e();
  return i[t] = s, s;
}
function xr(i, t, e) {
  const { _proxy: s, _context: n, _subProxy: o, _descriptors: r } = i;
  let a = s[t];
  return yt(a) && r.isScriptable(t) && (a = _r(t, a, i, e)), z(a) && a.length && (a = yr(t, a, i, r.isIndexable)), Bi(t, a) && (a = Vt(a, n, o && o[t], r)), a;
}
function _r(i, t, e, s) {
  const { _proxy: n, _context: o, _subProxy: r, _stack: a } = e;
  if (a.has(i))
    throw new Error("Recursion detected: " + Array.from(a).join("->") + "->" + i);
  return a.add(i), t = t(o, r || s), a.delete(i), Bi(i, t) && (t = Vi(n._scopes, n, i, t)), t;
}
function yr(i, t, e, s) {
  const { _proxy: n, _context: o, _subProxy: r, _descriptors: a } = e;
  if (et(o.index) && s(i))
    t = t[o.index % t.length];
  else if (D(t[0])) {
    const l = t, c = n._scopes.filter((h) => h !== l);
    t = [];
    for (const h of l) {
      const d = Vi(c, n, i, h);
      t.push(Vt(d, o, r && r[i], a));
    }
  }
  return t;
}
function Pn(i, t, e) {
  return yt(i) ? i(t, e) : i;
}
const vr = (i, t) => i === !0 ? t : typeof i == "string" ? _t(t, i) : void 0;
function Mr(i, t, e, s, n) {
  for (const o of t) {
    const r = vr(e, o);
    if (r) {
      i.add(r);
      const a = Pn(r._fallback, e, n);
      if (et(a) && a !== e && a !== s)
        return a;
    } else if (r === !1 && et(s) && e !== s)
      return null;
  }
  return !1;
}
function Vi(i, t, e, s) {
  const n = t._rootScopes, o = Pn(t._fallback, e, s), r = [...i, ...n], a = /* @__PURE__ */ new Set();
  a.add(s);
  let l = rs(a, r, e, o || e, s);
  return l === null || et(o) && o !== e && (l = rs(a, r, o, l, s), l === null) ? !1 : zi(
    Array.from(a),
    [""],
    n,
    o,
    () => kr(t, e, s)
  );
}
function rs(i, t, e, s, n) {
  for (; e; )
    e = Mr(i, t, e, s, n);
  return e;
}
function kr(i, t, e) {
  const s = i._getTarget();
  t in s || (s[t] = {});
  const n = s[t];
  return z(n) && D(e) ? e : n;
}
function wr(i, t, e, s) {
  let n;
  for (const o of t)
    if (n = Cn(br(o, i), e), et(n))
      return Bi(i, n) ? Vi(e, s, i, n) : n;
}
function Cn(i, t) {
  for (const e of t) {
    if (!e)
      continue;
    const s = e[i];
    if (et(s))
      return s;
  }
}
function as(i) {
  let t = i._keys;
  return t || (t = i._keys = Sr(i._scopes)), t;
}
function Sr(i) {
  const t = /* @__PURE__ */ new Set();
  for (const e of i)
    for (const s of Object.keys(e).filter((n) => !n.startsWith("_")))
      t.add(s);
  return Array.from(t);
}
function Dn(i, t, e, s) {
  const { iScale: n } = i, { key: o = "r" } = this._parsing, r = new Array(s);
  let a, l, c, h;
  for (a = 0, l = s; a < l; ++a)
    c = a + e, h = t[c], r[a] = {
      r: n.parse(_t(h, o), c)
    };
  return r;
}
const Pr = Number.EPSILON || 1e-14, Wt = (i, t) => t < i.length && !i[t].skip && i[t], On = (i) => i === "x" ? "y" : "x";
function Cr(i, t, e, s) {
  const n = i.skip ? t : i, o = t, r = e.skip ? t : e, a = bi(o, n), l = bi(r, o);
  let c = a / (a + l), h = l / (a + l);
  c = isNaN(c) ? 0 : c, h = isNaN(h) ? 0 : h;
  const d = s * c, u = s * h;
  return {
    previous: {
      x: o.x - d * (r.x - n.x),
      y: o.y - d * (r.y - n.y)
    },
    next: {
      x: o.x + u * (r.x - n.x),
      y: o.y + u * (r.y - n.y)
    }
  };
}
function Dr(i, t, e) {
  const s = i.length;
  let n, o, r, a, l, c = Wt(i, 0);
  for (let h = 0; h < s - 1; ++h)
    if (l = c, c = Wt(i, h + 1), !(!l || !c)) {
      if (te(t[h], 0, Pr)) {
        e[h] = e[h + 1] = 0;
        continue;
      }
      n = e[h] / t[h], o = e[h + 1] / t[h], a = Math.pow(n, 2) + Math.pow(o, 2), !(a <= 9) && (r = 3 / Math.sqrt(a), e[h] = n * r * t[h], e[h + 1] = o * r * t[h]);
    }
}
function Or(i, t, e = "x") {
  const s = On(e), n = i.length;
  let o, r, a, l = Wt(i, 0);
  for (let c = 0; c < n; ++c) {
    if (r = a, a = l, l = Wt(i, c + 1), !a)
      continue;
    const h = a[e], d = a[s];
    r && (o = (h - r[e]) / 3, a[`cp1${e}`] = h - o, a[`cp1${s}`] = d - o * t[c]), l && (o = (l[e] - h) / 3, a[`cp2${e}`] = h + o, a[`cp2${s}`] = d + o * t[c]);
  }
}
function Ar(i, t = "x") {
  const e = On(t), s = i.length, n = Array(s).fill(0), o = Array(s);
  let r, a, l, c = Wt(i, 0);
  for (r = 0; r < s; ++r)
    if (a = l, l = c, c = Wt(i, r + 1), !!l) {
      if (c) {
        const h = c[t] - l[t];
        n[r] = h !== 0 ? (c[e] - l[e]) / h : 0;
      }
      o[r] = a ? c ? lt(n[r - 1]) !== lt(n[r]) ? 0 : (n[r - 1] + n[r]) / 2 : n[r - 1] : n[r];
    }
  Dr(i, n, o), Or(i, o, t);
}
function De(i, t, e) {
  return Math.max(Math.min(i, e), t);
}
function Tr(i, t) {
  let e, s, n, o, r, a = re(i[0], t);
  for (e = 0, s = i.length; e < s; ++e)
    r = o, o = a, a = e < s - 1 && re(i[e + 1], t), o && (n = i[e], r && (n.cp1x = De(n.cp1x, t.left, t.right), n.cp1y = De(n.cp1y, t.top, t.bottom)), a && (n.cp2x = De(n.cp2x, t.left, t.right), n.cp2y = De(n.cp2y, t.top, t.bottom)));
}
function Lr(i, t, e, s, n) {
  let o, r, a, l;
  if (t.spanGaps && (i = i.filter((c) => !c.skip)), t.cubicInterpolationMode === "monotone")
    Ar(i, n);
  else {
    let c = s ? i[i.length - 1] : i[0];
    for (o = 0, r = i.length; o < r; ++o)
      a = i[o], l = Cr(
        c,
        a,
        i[Math.min(o + 1, r - (s ? 0 : 1)) % r],
        t.tension
      ), a.cp1x = l.previous.x, a.cp1y = l.previous.y, a.cp2x = l.next.x, a.cp2y = l.next.y, c = a;
  }
  t.capBezierPoints && Tr(i, e);
}
function An() {
  return typeof window < "u" && typeof document < "u";
}
function Wi(i) {
  let t = i.parentNode;
  return t && t.toString() === "[object ShadowRoot]" && (t = t.host), t;
}
function He(i, t, e) {
  let s;
  return typeof i == "string" ? (s = parseInt(i, 10), i.indexOf("%") !== -1 && (s = s / 100 * t.parentNode[e])) : s = i, s;
}
const Ke = (i) => window.getComputedStyle(i, null);
function Rr(i, t) {
  return Ke(i).getPropertyValue(t);
}
const Er = ["top", "right", "bottom", "left"];
function Ot(i, t, e) {
  const s = {};
  e = e ? "-" + e : "";
  for (let n = 0; n < 4; n++) {
    const o = Er[n];
    s[o] = parseFloat(i[t + "-" + o + e]) || 0;
  }
  return s.width = s.left + s.right, s.height = s.top + s.bottom, s;
}
const Fr = (i, t, e) => (i > 0 || t > 0) && (!e || !e.shadowRoot);
function Ir(i, t) {
  const e = i.touches, s = e && e.length ? e[0] : i, { offsetX: n, offsetY: o } = s;
  let r = !1, a, l;
  if (Fr(n, o, i.target))
    a = n, l = o;
  else {
    const c = t.getBoundingClientRect();
    a = s.clientX - c.left, l = s.clientY - c.top, r = !0;
  }
  return { x: a, y: l, box: r };
}
function Pt(i, t) {
  if ("native" in i)
    return i;
  const { canvas: e, currentDevicePixelRatio: s } = t, n = Ke(e), o = n.boxSizing === "border-box", r = Ot(n, "padding"), a = Ot(n, "border", "width"), { x: l, y: c, box: h } = Ir(i, e), d = r.left + (h && a.left), u = r.top + (h && a.top);
  let { width: f, height: g } = t;
  return o && (f -= r.width + a.width, g -= r.height + a.height), {
    x: Math.round((l - d) / f * e.width / s),
    y: Math.round((c - u) / g * e.height / s)
  };
}
function zr(i, t, e) {
  let s, n;
  if (t === void 0 || e === void 0) {
    const o = Wi(i);
    if (!o)
      t = i.clientWidth, e = i.clientHeight;
    else {
      const r = o.getBoundingClientRect(), a = Ke(o), l = Ot(a, "border", "width"), c = Ot(a, "padding");
      t = r.width - c.width - l.width, e = r.height - c.height - l.height, s = He(a.maxWidth, o, "clientWidth"), n = He(a.maxHeight, o, "clientHeight");
    }
  }
  return {
    width: t,
    height: e,
    maxWidth: s || Ve,
    maxHeight: n || Ve
  };
}
const ai = (i) => Math.round(i * 10) / 10;
function Br(i, t, e, s) {
  const n = Ke(i), o = Ot(n, "margin"), r = He(n.maxWidth, i, "clientWidth") || Ve, a = He(n.maxHeight, i, "clientHeight") || Ve, l = zr(i, t, e);
  let { width: c, height: h } = l;
  if (n.boxSizing === "content-box") {
    const d = Ot(n, "border", "width"), u = Ot(n, "padding");
    c -= u.width + d.width, h -= u.height + d.height;
  }
  return c = Math.max(0, c - o.width), h = Math.max(0, s ? Math.floor(c / s) : h - o.height), c = ai(Math.min(c, r, l.maxWidth)), h = ai(Math.min(h, a, l.maxHeight)), c && !h && (h = ai(c / 2)), {
    width: c,
    height: h
  };
}
function ls(i, t, e) {
  const s = t || 1, n = Math.floor(i.height * s), o = Math.floor(i.width * s);
  i.height = n / s, i.width = o / s;
  const r = i.canvas;
  return r.style && (e || !r.style.height && !r.style.width) && (r.style.height = `${i.height}px`, r.style.width = `${i.width}px`), i.currentDevicePixelRatio !== s || r.height !== n || r.width !== o ? (i.currentDevicePixelRatio = s, r.height = n, r.width = o, i.ctx.setTransform(s, 0, 0, s, 0, 0), !0) : !1;
}
const Vr = function() {
  let i = !1;
  try {
    const t = {
      get passive() {
        return i = !0, !1;
      }
    };
    window.addEventListener("test", null, t), window.removeEventListener("test", null, t);
  } catch {
  }
  return i;
}();
function cs(i, t) {
  const e = Rr(i, t), s = e && e.match(/^(\d+)(\.\d+)?px$/);
  return s ? +s[1] : void 0;
}
function Ct(i, t, e, s) {
  return {
    x: i.x + e * (t.x - i.x),
    y: i.y + e * (t.y - i.y)
  };
}
function Wr(i, t, e, s) {
  return {
    x: i.x + e * (t.x - i.x),
    y: s === "middle" ? e < 0.5 ? i.y : t.y : s === "after" ? e < 1 ? i.y : t.y : e > 0 ? t.y : i.y
  };
}
function Nr(i, t, e, s) {
  const n = { x: i.cp2x, y: i.cp2y }, o = { x: t.cp1x, y: t.cp1y }, r = Ct(i, n, e), a = Ct(n, o, e), l = Ct(o, t, e), c = Ct(r, a, e), h = Ct(a, l, e);
  return Ct(c, h, e);
}
const hs = /* @__PURE__ */ new Map();
function Hr(i, t) {
  t = t || {};
  const e = i + JSON.stringify(t);
  let s = hs.get(e);
  return s || (s = new Intl.NumberFormat(i, t), hs.set(e, s)), s;
}
function de(i, t, e) {
  return Hr(t, e).format(i);
}
const jr = function(i, t) {
  return {
    x(e) {
      return i + i + t - e;
    },
    setWidth(e) {
      t = e;
    },
    textAlign(e) {
      return e === "center" ? e : e === "right" ? "left" : "right";
    },
    xPlus(e, s) {
      return e - s;
    },
    leftForLtr(e, s) {
      return e - s;
    }
  };
}, $r = function() {
  return {
    x(i) {
      return i;
    },
    setWidth(i) {
    },
    textAlign(i) {
      return i;
    },
    xPlus(i, t) {
      return i + t;
    },
    leftForLtr(i, t) {
      return i;
    }
  };
};
function zt(i, t, e) {
  return i ? jr(t, e) : $r();
}
function Tn(i, t) {
  let e, s;
  (t === "ltr" || t === "rtl") && (e = i.canvas.style, s = [
    e.getPropertyValue("direction"),
    e.getPropertyPriority("direction")
  ], e.setProperty("direction", t, "important"), i.prevTextDirection = s);
}
function Ln(i, t) {
  t !== void 0 && (delete i.prevTextDirection, i.canvas.style.setProperty("direction", t[0], t[1]));
}
function Rn(i) {
  return i === "angle" ? {
    between: oe,
    compare: Ao,
    normalize: Z
  } : {
    between: ut,
    compare: (t, e) => t - e,
    normalize: (t) => t
  };
}
function ds({ start: i, end: t, count: e, loop: s, style: n }) {
  return {
    start: i % e,
    end: t % e,
    loop: s && (t - i + 1) % e === 0,
    style: n
  };
}
function Yr(i, t, e) {
  const { property: s, start: n, end: o } = e, { between: r, normalize: a } = Rn(s), l = t.length;
  let { start: c, end: h, loop: d } = i, u, f;
  if (d) {
    for (c += l, h += l, u = 0, f = l; u < f && r(a(t[c % l][s]), n, o); ++u)
      c--, h--;
    c %= l, h %= l;
  }
  return h < c && (h += l), { start: c, end: h, loop: d, style: i.style };
}
function En(i, t, e) {
  if (!e)
    return [i];
  const { property: s, start: n, end: o } = e, r = t.length, { compare: a, between: l, normalize: c } = Rn(s), { start: h, end: d, loop: u, style: f } = Yr(i, t, e), g = [];
  let p = !1, m = null, b, x, v;
  const y = () => l(n, v, b) && a(n, v) !== 0, _ = () => a(o, b) === 0 || l(o, v, b), M = () => p || y(), k = () => !p || _();
  for (let S = h, w = h; S <= d; ++S)
    x = t[S % r], !x.skip && (b = c(x[s]), b !== v && (p = l(b, n, o), m === null && M() && (m = a(b, n) === 0 ? S : w), m !== null && k() && (g.push(ds({ start: m, end: S, loop: u, count: r, style: f })), m = null), w = S, v = b));
  return m !== null && g.push(ds({ start: m, end: d, loop: u, count: r, style: f })), g;
}
function Fn(i, t) {
  const e = [], s = i.segments;
  for (let n = 0; n < s.length; n++) {
    const o = En(s[n], i.points, t);
    o.length && e.push(...o);
  }
  return e;
}
function Xr(i, t, e, s) {
  let n = 0, o = t - 1;
  if (e && !s)
    for (; n < t && !i[n].skip; )
      n++;
  for (; n < t && i[n].skip; )
    n++;
  for (n %= t, e && (o += n); o > n && i[o % t].skip; )
    o--;
  return o %= t, { start: n, end: o };
}
function Ur(i, t, e, s) {
  const n = i.length, o = [];
  let r = t, a = i[t], l;
  for (l = t + 1; l <= e; ++l) {
    const c = i[l % n];
    c.skip || c.stop ? a.skip || (s = !1, o.push({ start: t % n, end: (l - 1) % n, loop: s }), t = r = c.stop ? l : null) : (r = l, a.skip && (t = l)), a = c;
  }
  return r !== null && o.push({ start: t % n, end: r % n, loop: s }), o;
}
function Kr(i, t) {
  const e = i.points, s = i.options.spanGaps, n = e.length;
  if (!n)
    return [];
  const o = !!i._loop, { start: r, end: a } = Xr(e, n, o, s);
  if (s === !0)
    return us(i, [{ start: r, end: a, loop: o }], e, t);
  const l = a < r ? a + n : a, c = !!i._fullLoop && r === 0 && a === n - 1;
  return us(i, Ur(e, r, l, c), e, t);
}
function us(i, t, e, s) {
  return !s || !s.setContext || !e ? t : qr(i, t, e, s);
}
function qr(i, t, e, s) {
  const n = i._chart.getContext(), o = fs(i.options), { _datasetIndex: r, options: { spanGaps: a } } = i, l = e.length, c = [];
  let h = o, d = t[0].start, u = d;
  function f(g, p, m, b) {
    const x = a ? -1 : 1;
    if (g !== p) {
      for (g += l; e[g % l].skip; )
        g -= x;
      for (; e[p % l].skip; )
        p += x;
      g % l !== p % l && (c.push({ start: g % l, end: p % l, loop: m, style: b }), h = b, d = p % l);
    }
  }
  for (const g of t) {
    d = a ? d : g.start;
    let p = e[d % l], m;
    for (u = d + 1; u <= g.end; u++) {
      const b = e[u % l];
      m = fs(s.setContext(vt(n, {
        type: "segment",
        p0: p,
        p1: b,
        p0DataIndex: (u - 1) % l,
        p1DataIndex: u % l,
        datasetIndex: r
      }))), Gr(m, h) && f(d, u - 1, g.loop, h), p = b, h = m;
    }
    d < u - 1 && f(d, u - 1, g.loop, h);
  }
  return c;
}
function fs(i) {
  return {
    backgroundColor: i.backgroundColor,
    borderCapStyle: i.borderCapStyle,
    borderDash: i.borderDash,
    borderDashOffset: i.borderDashOffset,
    borderJoinStyle: i.borderJoinStyle,
    borderWidth: i.borderWidth,
    borderColor: i.borderColor
  };
}
function Gr(i, t) {
  return t && JSON.stringify(i) !== JSON.stringify(t);
}
/*!
 * Chart.js v3.9.1
 * https://www.chartjs.org
 * (c) 2022 Chart.js Contributors
 * Released under the MIT License
 */
class Zr {
  constructor() {
    this._request = null, this._charts = /* @__PURE__ */ new Map(), this._running = !1, this._lastDate = void 0;
  }
  _notify(t, e, s, n) {
    const o = e.listeners[n], r = e.duration;
    o.forEach((a) => a({
      chart: t,
      initial: e.initial,
      numSteps: r,
      currentStep: Math.min(s - e.start, r)
    }));
  }
  _refresh() {
    this._request || (this._running = !0, this._request = fn.call(window, () => {
      this._update(), this._request = null, this._running && this._refresh();
    }));
  }
  _update(t = Date.now()) {
    let e = 0;
    this._charts.forEach((s, n) => {
      if (!s.running || !s.items.length)
        return;
      const o = s.items;
      let r = o.length - 1, a = !1, l;
      for (; r >= 0; --r)
        l = o[r], l._active ? (l._total > s.duration && (s.duration = l._total), l.tick(t), a = !0) : (o[r] = o[o.length - 1], o.pop());
      a && (n.draw(), this._notify(n, s, t, "progress")), o.length || (s.running = !1, this._notify(n, s, t, "complete"), s.initial = !1), e += o.length;
    }), this._lastDate = t, e === 0 && (this._running = !1);
  }
  _getAnims(t) {
    const e = this._charts;
    let s = e.get(t);
    return s || (s = {
      running: !1,
      initial: !0,
      items: [],
      listeners: {
        complete: [],
        progress: []
      }
    }, e.set(t, s)), s;
  }
  listen(t, e, s) {
    this._getAnims(t).listeners[e].push(s);
  }
  add(t, e) {
    !e || !e.length || this._getAnims(t).items.push(...e);
  }
  has(t) {
    return this._getAnims(t).items.length > 0;
  }
  start(t) {
    const e = this._charts.get(t);
    e && (e.running = !0, e.start = Date.now(), e.duration = e.items.reduce((s, n) => Math.max(s, n._duration), 0), this._refresh());
  }
  running(t) {
    if (!this._running)
      return !1;
    const e = this._charts.get(t);
    return !(!e || !e.running || !e.items.length);
  }
  stop(t) {
    const e = this._charts.get(t);
    if (!e || !e.items.length)
      return;
    const s = e.items;
    let n = s.length - 1;
    for (; n >= 0; --n)
      s[n].cancel();
    e.items = [], this._notify(t, e, Date.now(), "complete");
  }
  remove(t) {
    return this._charts.delete(t);
  }
}
var at = new Zr();
const gs = "transparent", Jr = {
  boolean(i, t, e) {
    return e > 0.5 ? t : i;
  },
  color(i, t, e) {
    const s = ns(i || gs), n = s.valid && ns(t || gs);
    return n && n.valid ? n.mix(s, e).hexString() : t;
  },
  number(i, t, e) {
    return i + (t - i) * e;
  }
};
class In {
  constructor(t, e, s, n) {
    const o = e[s];
    n = Zt([t.to, n, o, t.from]);
    const r = Zt([t.from, o, n]);
    this._active = !0, this._fn = t.fn || Jr[t.type || typeof r], this._easing = ee[t.easing] || ee.linear, this._start = Math.floor(Date.now() + (t.delay || 0)), this._duration = this._total = Math.floor(t.duration), this._loop = !!t.loop, this._target = e, this._prop = s, this._from = r, this._to = n, this._promises = void 0;
  }
  active() {
    return this._active;
  }
  update(t, e, s) {
    if (this._active) {
      this._notify(!1);
      const n = this._target[this._prop], o = s - this._start, r = this._duration - o;
      this._start = s, this._duration = Math.floor(Math.max(r, t.duration)), this._total += o, this._loop = !!t.loop, this._to = Zt([t.to, e, n, t.from]), this._from = Zt([t.from, n, e]);
    }
  }
  cancel() {
    this._active && (this.tick(Date.now()), this._active = !1, this._notify(!1));
  }
  tick(t) {
    const e = t - this._start, s = this._duration, n = this._prop, o = this._from, r = this._loop, a = this._to;
    let l;
    if (this._active = o !== a && (r || e < s), !this._active) {
      this._target[n] = a, this._notify(!0);
      return;
    }
    if (e < 0) {
      this._target[n] = o;
      return;
    }
    l = e / s % 2, l = r && l > 1 ? 2 - l : l, l = this._easing(Math.min(1, Math.max(0, l))), this._target[n] = this._fn(o, a, l);
  }
  wait() {
    const t = this._promises || (this._promises = []);
    return new Promise((e, s) => {
      t.push({ res: e, rej: s });
    });
  }
  _notify(t) {
    const e = t ? "res" : "rej", s = this._promises || [];
    for (let n = 0; n < s.length; n++)
      s[n][e]();
  }
}
const Qr = ["x", "y", "borderWidth", "radius", "tension"], ta = ["color", "borderColor", "backgroundColor"];
O.set("animation", {
  delay: void 0,
  duration: 1e3,
  easing: "easeOutQuart",
  fn: void 0,
  from: void 0,
  loop: void 0,
  to: void 0,
  type: void 0
});
const ea = Object.keys(O.animation);
O.describe("animation", {
  _fallback: !1,
  _indexable: !1,
  _scriptable: (i) => i !== "onProgress" && i !== "onComplete" && i !== "fn"
});
O.set("animations", {
  colors: {
    type: "color",
    properties: ta
  },
  numbers: {
    type: "number",
    properties: Qr
  }
});
O.describe("animations", {
  _fallback: "animation"
});
O.set("transitions", {
  active: {
    animation: {
      duration: 400
    }
  },
  resize: {
    animation: {
      duration: 0
    }
  },
  show: {
    animations: {
      colors: {
        from: "transparent"
      },
      visible: {
        type: "boolean",
        duration: 0
      }
    }
  },
  hide: {
    animations: {
      colors: {
        to: "transparent"
      },
      visible: {
        type: "boolean",
        easing: "linear",
        fn: (i) => i | 0
      }
    }
  }
});
class Ni {
  constructor(t, e) {
    this._chart = t, this._properties = /* @__PURE__ */ new Map(), this.configure(e);
  }
  configure(t) {
    if (!D(t))
      return;
    const e = this._properties;
    Object.getOwnPropertyNames(t).forEach((s) => {
      const n = t[s];
      if (!D(n))
        return;
      const o = {};
      for (const r of ea)
        o[r] = n[r];
      (z(n.properties) && n.properties || [s]).forEach((r) => {
        (r === s || !e.has(r)) && e.set(r, o);
      });
    });
  }
  _animateOptions(t, e) {
    const s = e.options, n = sa(t, s);
    if (!n)
      return [];
    const o = this._createAnimations(n, s);
    return s.$shared && ia(t.options.$animations, s).then(() => {
      t.options = s;
    }, () => {
    }), o;
  }
  _createAnimations(t, e) {
    const s = this._properties, n = [], o = t.$animations || (t.$animations = {}), r = Object.keys(e), a = Date.now();
    let l;
    for (l = r.length - 1; l >= 0; --l) {
      const c = r[l];
      if (c.charAt(0) === "$")
        continue;
      if (c === "options") {
        n.push(...this._animateOptions(t, e));
        continue;
      }
      const h = e[c];
      let d = o[c];
      const u = s.get(c);
      if (d)
        if (u && d.active()) {
          d.update(u, h, a);
          continue;
        } else
          d.cancel();
      if (!u || !u.duration) {
        t[c] = h;
        continue;
      }
      o[c] = d = new In(u, t, c, h), n.push(d);
    }
    return n;
  }
  update(t, e) {
    if (this._properties.size === 0) {
      Object.assign(t, e);
      return;
    }
    const s = this._createAnimations(t, e);
    if (s.length)
      return at.add(this._chart, s), !0;
  }
}
function ia(i, t) {
  const e = [], s = Object.keys(t);
  for (let n = 0; n < s.length; n++) {
    const o = i[s[n]];
    o && o.active() && e.push(o.wait());
  }
  return Promise.all(e);
}
function sa(i, t) {
  if (!t)
    return;
  let e = i.options;
  if (!e) {
    i.options = t;
    return;
  }
  return e.$shared && (i.options = e = Object.assign({}, e, { $shared: !1, $animations: {} })), e;
}
function ps(i, t) {
  const e = i && i.options || {}, s = e.reverse, n = e.min === void 0 ? t : 0, o = e.max === void 0 ? t : 0;
  return {
    start: s ? o : n,
    end: s ? n : o
  };
}
function na(i, t, e) {
  if (e === !1)
    return !1;
  const s = ps(i, e), n = ps(t, e);
  return {
    top: n.end,
    right: s.end,
    bottom: n.start,
    left: s.start
  };
}
function oa(i) {
  let t, e, s, n;
  return D(i) ? (t = i.top, e = i.right, s = i.bottom, n = i.left) : t = e = s = n = i, {
    top: t,
    right: e,
    bottom: s,
    left: n,
    disabled: i === !1
  };
}
function zn(i, t) {
  const e = [], s = i._getSortedDatasetMetas(t);
  let n, o;
  for (n = 0, o = s.length; n < o; ++n)
    e.push(s[n].index);
  return e;
}
function ms(i, t, e, s = {}) {
  const n = i.keys, o = s.mode === "single";
  let r, a, l, c;
  if (t !== null) {
    for (r = 0, a = n.length; r < a; ++r) {
      if (l = +n[r], l === e) {
        if (s.all)
          continue;
        break;
      }
      c = i.values[l], N(c) && (o || t === 0 || lt(t) === lt(c)) && (t += c);
    }
    return t;
  }
}
function ra(i) {
  const t = Object.keys(i), e = new Array(t.length);
  let s, n, o;
  for (s = 0, n = t.length; s < n; ++s)
    o = t[s], e[s] = {
      x: o,
      y: i[o]
    };
  return e;
}
function bs(i, t) {
  const e = i && i.options.stacked;
  return e || e === void 0 && t.stack !== void 0;
}
function aa(i, t, e) {
  return `${i.id}.${t.id}.${e.stack || e.type}`;
}
function la(i) {
  const { min: t, max: e, minDefined: s, maxDefined: n } = i.getUserBounds();
  return {
    min: s ? t : Number.NEGATIVE_INFINITY,
    max: n ? e : Number.POSITIVE_INFINITY
  };
}
function ca(i, t, e) {
  const s = i[t] || (i[t] = {});
  return s[e] || (s[e] = {});
}
function xs(i, t, e, s) {
  for (const n of t.getMatchingVisibleMetas(s).reverse()) {
    const o = i[n.index];
    if (e && o > 0 || !e && o < 0)
      return n.index;
  }
  return null;
}
function _s(i, t) {
  const { chart: e, _cachedMeta: s } = i, n = e._stacks || (e._stacks = {}), { iScale: o, vScale: r, index: a } = s, l = o.axis, c = r.axis, h = aa(o, r, s), d = t.length;
  let u;
  for (let f = 0; f < d; ++f) {
    const g = t[f], { [l]: p, [c]: m } = g, b = g._stacks || (g._stacks = {});
    u = b[c] = ca(n, h, p), u[a] = m, u._top = xs(u, r, !0, s.type), u._bottom = xs(u, r, !1, s.type);
  }
}
function li(i, t) {
  const e = i.scales;
  return Object.keys(e).filter((s) => e[s].axis === t).shift();
}
function ha(i, t) {
  return vt(
    i,
    {
      active: !1,
      dataset: void 0,
      datasetIndex: t,
      index: t,
      mode: "default",
      type: "dataset"
    }
  );
}
function da(i, t, e) {
  return vt(i, {
    active: !1,
    dataIndex: t,
    parsed: void 0,
    raw: void 0,
    element: e,
    index: t,
    mode: "default",
    type: "data"
  });
}
function Yt(i, t) {
  const e = i.controller.index, s = i.vScale && i.vScale.axis;
  if (s) {
    t = t || i._parsed;
    for (const n of t) {
      const o = n._stacks;
      if (!o || o[s] === void 0 || o[s][e] === void 0)
        return;
      delete o[s][e];
    }
  }
}
const ci = (i) => i === "reset" || i === "none", ys = (i, t) => t ? i : Object.assign({}, i), ua = (i, t, e) => i && !t.hidden && t._stacked && { keys: zn(e, !0), values: null };
class it {
  constructor(t, e) {
    this.chart = t, this._ctx = t.ctx, this.index = e, this._cachedDataOpts = {}, this._cachedMeta = this.getMeta(), this._type = this._cachedMeta.type, this.options = void 0, this._parsing = !1, this._data = void 0, this._objectData = void 0, this._sharedOptions = void 0, this._drawStart = void 0, this._drawCount = void 0, this.enableOptionSharing = !1, this.supportsDecimation = !1, this.$context = void 0, this._syncList = [], this.initialize();
  }
  initialize() {
    const t = this._cachedMeta;
    this.configure(), this.linkScales(), t._stacked = bs(t.vScale, t), this.addElements();
  }
  updateIndex(t) {
    this.index !== t && Yt(this._cachedMeta), this.index = t;
  }
  linkScales() {
    const t = this.chart, e = this._cachedMeta, s = this.getDataset(), n = (d, u, f, g) => d === "x" ? u : d === "r" ? g : f, o = e.xAxisID = C(s.xAxisID, li(t, "x")), r = e.yAxisID = C(s.yAxisID, li(t, "y")), a = e.rAxisID = C(s.rAxisID, li(t, "r")), l = e.indexAxis, c = e.iAxisID = n(l, o, r, a), h = e.vAxisID = n(l, r, o, a);
    e.xScale = this.getScaleForId(o), e.yScale = this.getScaleForId(r), e.rScale = this.getScaleForId(a), e.iScale = this.getScaleForId(c), e.vScale = this.getScaleForId(h);
  }
  getDataset() {
    return this.chart.data.datasets[this.index];
  }
  getMeta() {
    return this.chart.getDatasetMeta(this.index);
  }
  getScaleForId(t) {
    return this.chart.scales[t];
  }
  _getOtherScale(t) {
    const e = this._cachedMeta;
    return t === e.iScale ? e.vScale : e.iScale;
  }
  reset() {
    this._update("reset");
  }
  _destroy() {
    const t = this._cachedMeta;
    this._data && Zi(this._data, this), t._stacked && Yt(t);
  }
  _dataCheck() {
    const t = this.getDataset(), e = t.data || (t.data = []), s = this._data;
    if (D(e))
      this._data = ra(e);
    else if (s !== e) {
      if (s) {
        Zi(s, this);
        const n = this._cachedMeta;
        Yt(n), n._parsed = [];
      }
      e && Object.isExtensible(e) && Eo(e, this), this._syncList = [], this._data = e;
    }
  }
  addElements() {
    const t = this._cachedMeta;
    this._dataCheck(), this.datasetElementType && (t.dataset = new this.datasetElementType());
  }
  buildOrUpdateElements(t) {
    const e = this._cachedMeta, s = this.getDataset();
    let n = !1;
    this._dataCheck();
    const o = e._stacked;
    e._stacked = bs(e.vScale, e), e.stack !== s.stack && (n = !0, Yt(e), e.stack = s.stack), this._resyncElements(t), (n || o !== e._stacked) && _s(this, e._parsed);
  }
  configure() {
    const t = this.chart.config, e = t.datasetScopeKeys(this._type), s = t.getOptionScopes(this.getDataset(), e, !0);
    this.options = t.createResolver(s, this.getContext()), this._parsing = this.options.parsing, this._cachedDataOpts = {};
  }
  parse(t, e) {
    const { _cachedMeta: s, _data: n } = this, { iScale: o, _stacked: r } = s, a = o.axis;
    let l = t === 0 && e === n.length ? !0 : s._sorted, c = t > 0 && s._parsed[t - 1], h, d, u;
    if (this._parsing === !1)
      s._parsed = n, s._sorted = !0, u = n;
    else {
      z(n[t]) ? u = this.parseArrayData(s, n, t, e) : D(n[t]) ? u = this.parseObjectData(s, n, t, e) : u = this.parsePrimitiveData(s, n, t, e);
      const f = () => d[a] === null || c && d[a] < c[a];
      for (h = 0; h < e; ++h)
        s._parsed[h + t] = d = u[h], l && (f() && (l = !1), c = d);
      s._sorted = l;
    }
    r && _s(this, u);
  }
  parsePrimitiveData(t, e, s, n) {
    const { iScale: o, vScale: r } = t, a = o.axis, l = r.axis, c = o.getLabels(), h = o === r, d = new Array(n);
    let u, f, g;
    for (u = 0, f = n; u < f; ++u)
      g = u + s, d[u] = {
        [a]: h || o.parse(c[g], g),
        [l]: r.parse(e[g], g)
      };
    return d;
  }
  parseArrayData(t, e, s, n) {
    const { xScale: o, yScale: r } = t, a = new Array(n);
    let l, c, h, d;
    for (l = 0, c = n; l < c; ++l)
      h = l + s, d = e[h], a[l] = {
        x: o.parse(d[0], h),
        y: r.parse(d[1], h)
      };
    return a;
  }
  parseObjectData(t, e, s, n) {
    const { xScale: o, yScale: r } = t, { xAxisKey: a = "x", yAxisKey: l = "y" } = this._parsing, c = new Array(n);
    let h, d, u, f;
    for (h = 0, d = n; h < d; ++h)
      u = h + s, f = e[u], c[h] = {
        x: o.parse(_t(f, a), u),
        y: r.parse(_t(f, l), u)
      };
    return c;
  }
  getParsed(t) {
    return this._cachedMeta._parsed[t];
  }
  getDataElement(t) {
    return this._cachedMeta.data[t];
  }
  applyStack(t, e, s) {
    const n = this.chart, o = this._cachedMeta, r = e[t.axis], a = {
      keys: zn(n, !0),
      values: e._stacks[t.axis]
    };
    return ms(a, r, o.index, { mode: s });
  }
  updateRangeFromParsed(t, e, s, n) {
    const o = s[e.axis];
    let r = o === null ? NaN : o;
    const a = n && s._stacks[e.axis];
    n && a && (n.values = a, r = ms(n, o, this._cachedMeta.index)), t.min = Math.min(t.min, r), t.max = Math.max(t.max, r);
  }
  getMinMax(t, e) {
    const s = this._cachedMeta, n = s._parsed, o = s._sorted && t === s.iScale, r = n.length, a = this._getOtherScale(t), l = ua(e, s, this.chart), c = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY }, { min: h, max: d } = la(a);
    let u, f;
    function g() {
      f = n[u];
      const p = f[a.axis];
      return !N(f[t.axis]) || h > p || d < p;
    }
    for (u = 0; u < r && !(!g() && (this.updateRangeFromParsed(c, t, f, l), o)); ++u)
      ;
    if (o) {
      for (u = r - 1; u >= 0; --u)
        if (!g()) {
          this.updateRangeFromParsed(c, t, f, l);
          break;
        }
    }
    return c;
  }
  getAllParsedValues(t) {
    const e = this._cachedMeta._parsed, s = [];
    let n, o, r;
    for (n = 0, o = e.length; n < o; ++n)
      r = e[n][t.axis], N(r) && s.push(r);
    return s;
  }
  getMaxOverflow() {
    return !1;
  }
  getLabelAndValue(t) {
    const e = this._cachedMeta, s = e.iScale, n = e.vScale, o = this.getParsed(t);
    return {
      label: s ? "" + s.getLabelForValue(o[s.axis]) : "",
      value: n ? "" + n.getLabelForValue(o[n.axis]) : ""
    };
  }
  _update(t) {
    const e = this._cachedMeta;
    this.update(t || "default"), e._clip = oa(C(this.options.clip, na(e.xScale, e.yScale, this.getMaxOverflow())));
  }
  update(t) {
  }
  draw() {
    const t = this._ctx, e = this.chart, s = this._cachedMeta, n = s.data || [], o = e.chartArea, r = [], a = this._drawStart || 0, l = this._drawCount || n.length - a, c = this.options.drawActiveElementsOnTop;
    let h;
    for (s.dataset && s.dataset.draw(t, o, a, l), h = a; h < a + l; ++h) {
      const d = n[h];
      d.hidden || (d.active && c ? r.push(d) : d.draw(t, o));
    }
    for (h = 0; h < r.length; ++h)
      r[h].draw(t, o);
  }
  getStyle(t, e) {
    const s = e ? "active" : "default";
    return t === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(s) : this.resolveDataElementOptions(t || 0, s);
  }
  getContext(t, e, s) {
    const n = this.getDataset();
    let o;
    if (t >= 0 && t < this._cachedMeta.data.length) {
      const r = this._cachedMeta.data[t];
      o = r.$context || (r.$context = da(this.getContext(), t, r)), o.parsed = this.getParsed(t), o.raw = n.data[t], o.index = o.dataIndex = t;
    } else
      o = this.$context || (this.$context = ha(this.chart.getContext(), this.index)), o.dataset = n, o.index = o.datasetIndex = this.index;
    return o.active = !!e, o.mode = s, o;
  }
  resolveDatasetElementOptions(t) {
    return this._resolveElementOptions(this.datasetElementType.id, t);
  }
  resolveDataElementOptions(t, e) {
    return this._resolveElementOptions(this.dataElementType.id, e, t);
  }
  _resolveElementOptions(t, e = "default", s) {
    const n = e === "active", o = this._cachedDataOpts, r = t + "-" + e, a = o[r], l = this.enableOptionSharing && et(s);
    if (a)
      return ys(a, l);
    const c = this.chart.config, h = c.datasetElementScopeKeys(this._type, t), d = n ? [`${t}Hover`, "hover", t, ""] : [t, ""], u = c.getOptionScopes(this.getDataset(), h), f = Object.keys(O.elements[t]), g = () => this.getContext(s, n), p = c.resolveNamedOptions(u, f, g, d);
    return p.$shared && (p.$shared = l, o[r] = Object.freeze(ys(p, l))), p;
  }
  _resolveAnimations(t, e, s) {
    const n = this.chart, o = this._cachedDataOpts, r = `animation-${e}`, a = o[r];
    if (a)
      return a;
    let l;
    if (n.options.animation !== !1) {
      const h = this.chart.config, d = h.datasetAnimationScopeKeys(this._type, e), u = h.getOptionScopes(this.getDataset(), d);
      l = h.createResolver(u, this.getContext(t, s, e));
    }
    const c = new Ni(n, l && l.animations);
    return l && l._cacheable && (o[r] = Object.freeze(c)), c;
  }
  getSharedOptions(t) {
    if (t.$shared)
      return this._sharedOptions || (this._sharedOptions = Object.assign({}, t));
  }
  includeOptions(t, e) {
    return !e || ci(t) || this.chart._animationsDisabled;
  }
  _getSharedOptions(t, e) {
    const s = this.resolveDataElementOptions(t, e), n = this._sharedOptions, o = this.getSharedOptions(s), r = this.includeOptions(e, o) || o !== n;
    return this.updateSharedOptions(o, e, s), { sharedOptions: o, includeOptions: r };
  }
  updateElement(t, e, s, n) {
    ci(n) ? Object.assign(t, s) : this._resolveAnimations(e, n).update(t, s);
  }
  updateSharedOptions(t, e, s) {
    t && !ci(e) && this._resolveAnimations(void 0, e).update(t, s);
  }
  _setStyle(t, e, s, n) {
    t.active = n;
    const o = this.getStyle(e, n);
    this._resolveAnimations(e, s, n).update(t, {
      options: !n && this.getSharedOptions(o) || o
    });
  }
  removeHoverStyle(t, e, s) {
    this._setStyle(t, s, "active", !1);
  }
  setHoverStyle(t, e, s) {
    this._setStyle(t, s, "active", !0);
  }
  _removeDatasetHoverStyle() {
    const t = this._cachedMeta.dataset;
    t && this._setStyle(t, void 0, "active", !1);
  }
  _setDatasetHoverStyle() {
    const t = this._cachedMeta.dataset;
    t && this._setStyle(t, void 0, "active", !0);
  }
  _resyncElements(t) {
    const e = this._data, s = this._cachedMeta.data;
    for (const [a, l, c] of this._syncList)
      this[a](l, c);
    this._syncList = [];
    const n = s.length, o = e.length, r = Math.min(o, n);
    r && this.parse(0, r), o > n ? this._insertElements(n, o - n, t) : o < n && this._removeElements(o, n - o);
  }
  _insertElements(t, e, s = !0) {
    const n = this._cachedMeta, o = n.data, r = t + e;
    let a;
    const l = (c) => {
      for (c.length += e, a = c.length - 1; a >= r; a--)
        c[a] = c[a - e];
    };
    for (l(o), a = t; a < r; ++a)
      o[a] = new this.dataElementType();
    this._parsing && l(n._parsed), this.parse(t, e), s && this.updateElements(o, t, e, "reset");
  }
  updateElements(t, e, s, n) {
  }
  _removeElements(t, e) {
    const s = this._cachedMeta;
    if (this._parsing) {
      const n = s._parsed.splice(t, e);
      s._stacked && Yt(s, n);
    }
    s.data.splice(t, e);
  }
  _sync(t) {
    if (this._parsing)
      this._syncList.push(t);
    else {
      const [e, s, n] = t;
      this[e](s, n);
    }
    this.chart._dataChanges.push([this.index, ...t]);
  }
  _onDataPush() {
    const t = arguments.length;
    this._sync(["_insertElements", this.getDataset().data.length - t, t]);
  }
  _onDataPop() {
    this._sync(["_removeElements", this._cachedMeta.data.length - 1, 1]);
  }
  _onDataShift() {
    this._sync(["_removeElements", 0, 1]);
  }
  _onDataSplice(t, e) {
    e && this._sync(["_removeElements", t, e]);
    const s = arguments.length - 2;
    s && this._sync(["_insertElements", t, s]);
  }
  _onDataUnshift() {
    this._sync(["_insertElements", 0, arguments.length]);
  }
}
it.defaults = {};
it.prototype.datasetElementType = null;
it.prototype.dataElementType = null;
function fa(i, t) {
  if (!i._cache.$bar) {
    const e = i.getMatchingVisibleMetas(t);
    let s = [];
    for (let n = 0, o = e.length; n < o; n++)
      s = s.concat(e[n].controller.getAllParsedValues(i));
    i._cache.$bar = un(s.sort((n, o) => n - o));
  }
  return i._cache.$bar;
}
function ga(i) {
  const t = i.iScale, e = fa(t, i.type);
  let s = t._length, n, o, r, a;
  const l = () => {
    r === 32767 || r === -32768 || (et(a) && (s = Math.min(s, Math.abs(r - a) || s)), a = r);
  };
  for (n = 0, o = e.length; n < o; ++n)
    r = t.getPixelForValue(e[n]), l();
  for (a = void 0, n = 0, o = t.ticks.length; n < o; ++n)
    r = t.getPixelForTick(n), l();
  return s;
}
function pa(i, t, e, s) {
  const n = e.barThickness;
  let o, r;
  return T(n) ? (o = t.min * e.categoryPercentage, r = e.barPercentage) : (o = n * s, r = 1), {
    chunk: o / s,
    ratio: r,
    start: t.pixels[i] - o / 2
  };
}
function ma(i, t, e, s) {
  const n = t.pixels, o = n[i];
  let r = i > 0 ? n[i - 1] : null, a = i < n.length - 1 ? n[i + 1] : null;
  const l = e.categoryPercentage;
  r === null && (r = o - (a === null ? t.end - t.start : a - o)), a === null && (a = o + o - r);
  const c = o - (o - Math.min(r, a)) / 2 * l;
  return {
    chunk: Math.abs(a - r) / 2 * l / s,
    ratio: e.barPercentage,
    start: c
  };
}
function ba(i, t, e, s) {
  const n = e.parse(i[0], s), o = e.parse(i[1], s), r = Math.min(n, o), a = Math.max(n, o);
  let l = r, c = a;
  Math.abs(r) > Math.abs(a) && (l = a, c = r), t[e.axis] = c, t._custom = {
    barStart: l,
    barEnd: c,
    start: n,
    end: o,
    min: r,
    max: a
  };
}
function Bn(i, t, e, s) {
  return z(i) ? ba(i, t, e, s) : t[e.axis] = e.parse(i, s), t;
}
function vs(i, t, e, s) {
  const n = i.iScale, o = i.vScale, r = n.getLabels(), a = n === o, l = [];
  let c, h, d, u;
  for (c = e, h = e + s; c < h; ++c)
    u = t[c], d = {}, d[n.axis] = a || n.parse(r[c], c), l.push(Bn(u, d, o, c));
  return l;
}
function hi(i) {
  return i && i.barStart !== void 0 && i.barEnd !== void 0;
}
function xa(i, t, e) {
  return i !== 0 ? lt(i) : (t.isHorizontal() ? 1 : -1) * (t.min >= e ? 1 : -1);
}
function _a(i) {
  let t, e, s, n, o;
  return i.horizontal ? (t = i.base > i.x, e = "left", s = "right") : (t = i.base < i.y, e = "bottom", s = "top"), t ? (n = "end", o = "start") : (n = "start", o = "end"), { start: e, end: s, reverse: t, top: n, bottom: o };
}
function ya(i, t, e, s) {
  let n = t.borderSkipped;
  const o = {};
  if (!n) {
    i.borderSkipped = o;
    return;
  }
  if (n === !0) {
    i.borderSkipped = { top: !0, right: !0, bottom: !0, left: !0 };
    return;
  }
  const { start: r, end: a, reverse: l, top: c, bottom: h } = _a(i);
  n === "middle" && e && (i.enableBorderRadius = !0, (e._top || 0) === s ? n = c : (e._bottom || 0) === s ? n = h : (o[Ms(h, r, a, l)] = !0, n = c)), o[Ms(n, r, a, l)] = !0, i.borderSkipped = o;
}
function Ms(i, t, e, s) {
  return s ? (i = va(i, t, e), i = ks(i, e, t)) : i = ks(i, t, e), i;
}
function va(i, t, e) {
  return i === t ? e : i === e ? t : i;
}
function ks(i, t, e) {
  return i === "start" ? t : i === "end" ? e : i;
}
function Ma(i, { inflateAmount: t }, e) {
  i.inflateAmount = t === "auto" ? e === 1 ? 0.33 : 0 : t;
}
class ue extends it {
  parsePrimitiveData(t, e, s, n) {
    return vs(t, e, s, n);
  }
  parseArrayData(t, e, s, n) {
    return vs(t, e, s, n);
  }
  parseObjectData(t, e, s, n) {
    const { iScale: o, vScale: r } = t, { xAxisKey: a = "x", yAxisKey: l = "y" } = this._parsing, c = o.axis === "x" ? a : l, h = r.axis === "x" ? a : l, d = [];
    let u, f, g, p;
    for (u = s, f = s + n; u < f; ++u)
      p = e[u], g = {}, g[o.axis] = o.parse(_t(p, c), u), d.push(Bn(_t(p, h), g, r, u));
    return d;
  }
  updateRangeFromParsed(t, e, s, n) {
    super.updateRangeFromParsed(t, e, s, n);
    const o = s._custom;
    o && e === this._cachedMeta.vScale && (t.min = Math.min(t.min, o.min), t.max = Math.max(t.max, o.max));
  }
  getMaxOverflow() {
    return 0;
  }
  getLabelAndValue(t) {
    const e = this._cachedMeta, { iScale: s, vScale: n } = e, o = this.getParsed(t), r = o._custom, a = hi(r) ? "[" + r.start + ", " + r.end + "]" : "" + n.getLabelForValue(o[n.axis]);
    return {
      label: "" + s.getLabelForValue(o[s.axis]),
      value: a
    };
  }
  initialize() {
    this.enableOptionSharing = !0, super.initialize();
    const t = this._cachedMeta;
    t.stack = this.getDataset().stack;
  }
  update(t) {
    const e = this._cachedMeta;
    this.updateElements(e.data, 0, e.data.length, t);
  }
  updateElements(t, e, s, n) {
    const o = n === "reset", { index: r, _cachedMeta: { vScale: a } } = this, l = a.getBasePixel(), c = a.isHorizontal(), h = this._getRuler(), { sharedOptions: d, includeOptions: u } = this._getSharedOptions(e, n);
    for (let f = e; f < e + s; f++) {
      const g = this.getParsed(f), p = o || T(g[a.axis]) ? { base: l, head: l } : this._calculateBarValuePixels(f), m = this._calculateBarIndexPixels(f, h), b = (g._stacks || {})[a.axis], x = {
        horizontal: c,
        base: p.base,
        enableBorderRadius: !b || hi(g._custom) || r === b._top || r === b._bottom,
        x: c ? p.head : m.center,
        y: c ? m.center : p.head,
        height: c ? m.size : Math.abs(p.size),
        width: c ? Math.abs(p.size) : m.size
      };
      u && (x.options = d || this.resolveDataElementOptions(f, t[f].active ? "active" : n));
      const v = x.options || t[f].options;
      ya(x, v, b, r), Ma(x, v, h.ratio), this.updateElement(t[f], f, x, n);
    }
  }
  _getStacks(t, e) {
    const { iScale: s } = this._cachedMeta, n = s.getMatchingVisibleMetas(this._type).filter((l) => l.controller.options.grouped), o = s.options.stacked, r = [], a = (l) => {
      const c = l.controller.getParsed(e), h = c && c[l.vScale.axis];
      if (T(h) || isNaN(h))
        return !0;
    };
    for (const l of n)
      if (!(e !== void 0 && a(l)) && ((o === !1 || r.indexOf(l.stack) === -1 || o === void 0 && l.stack === void 0) && r.push(l.stack), l.index === t))
        break;
    return r.length || r.push(void 0), r;
  }
  _getStackCount(t) {
    return this._getStacks(void 0, t).length;
  }
  _getStackIndex(t, e, s) {
    const n = this._getStacks(t, s), o = e !== void 0 ? n.indexOf(e) : -1;
    return o === -1 ? n.length - 1 : o;
  }
  _getRuler() {
    const t = this.options, e = this._cachedMeta, s = e.iScale, n = [];
    let o, r;
    for (o = 0, r = e.data.length; o < r; ++o)
      n.push(s.getPixelForValue(this.getParsed(o)[s.axis], o));
    const a = t.barThickness;
    return {
      min: a || ga(e),
      pixels: n,
      start: s._startPixel,
      end: s._endPixel,
      stackCount: this._getStackCount(),
      scale: s,
      grouped: t.grouped,
      ratio: a ? 1 : t.categoryPercentage * t.barPercentage
    };
  }
  _calculateBarValuePixels(t) {
    const { _cachedMeta: { vScale: e, _stacked: s }, options: { base: n, minBarLength: o } } = this, r = n || 0, a = this.getParsed(t), l = a._custom, c = hi(l);
    let h = a[e.axis], d = 0, u = s ? this.applyStack(e, a, s) : h, f, g;
    u !== h && (d = u - h, u = h), c && (h = l.barStart, u = l.barEnd - l.barStart, h !== 0 && lt(h) !== lt(l.barEnd) && (d = 0), d += h);
    const p = !T(n) && !c ? n : d;
    let m = e.getPixelForValue(p);
    if (this.chart.getDataVisibility(t) ? f = e.getPixelForValue(d + u) : f = m, g = f - m, Math.abs(g) < o) {
      g = xa(g, e, r) * o, h === r && (m -= g / 2);
      const b = e.getPixelForDecimal(0), x = e.getPixelForDecimal(1), v = Math.min(b, x), y = Math.max(b, x);
      m = Math.max(Math.min(m, y), v), f = m + g;
    }
    if (m === e.getPixelForValue(r)) {
      const b = lt(g) * e.getLineWidthForValue(r) / 2;
      m += b, g -= b;
    }
    return {
      size: g,
      base: m,
      head: f,
      center: f + g / 2
    };
  }
  _calculateBarIndexPixels(t, e) {
    const s = e.scale, n = this.options, o = n.skipNull, r = C(n.maxBarThickness, 1 / 0);
    let a, l;
    if (e.grouped) {
      const c = o ? this._getStackCount(t) : e.stackCount, h = n.barThickness === "flex" ? ma(t, e, n, c) : pa(t, e, n, c), d = this._getStackIndex(this.index, this._cachedMeta.stack, o ? t : void 0);
      a = h.start + h.chunk * d + h.chunk / 2, l = Math.min(r, h.chunk * h.ratio);
    } else
      a = s.getPixelForValue(this.getParsed(t)[s.axis], t), l = Math.min(r, e.min * e.ratio);
    return {
      base: a - l / 2,
      head: a + l / 2,
      center: a,
      size: l
    };
  }
  draw() {
    const t = this._cachedMeta, e = t.vScale, s = t.data, n = s.length;
    let o = 0;
    for (; o < n; ++o)
      this.getParsed(o)[e.axis] !== null && s[o].draw(this._ctx);
  }
}
ue.id = "bar";
ue.defaults = {
  datasetElementType: !1,
  dataElementType: "bar",
  categoryPercentage: 0.8,
  barPercentage: 0.9,
  grouped: !0,
  animations: {
    numbers: {
      type: "number",
      properties: ["x", "y", "base", "width", "height"]
    }
  }
};
ue.overrides = {
  scales: {
    _index_: {
      type: "category",
      offset: !0,
      grid: {
        offset: !0
      }
    },
    _value_: {
      type: "linear",
      beginAtZero: !0
    }
  }
};
class fe extends it {
  initialize() {
    this.enableOptionSharing = !0, super.initialize();
  }
  parsePrimitiveData(t, e, s, n) {
    const o = super.parsePrimitiveData(t, e, s, n);
    for (let r = 0; r < o.length; r++)
      o[r]._custom = this.resolveDataElementOptions(r + s).radius;
    return o;
  }
  parseArrayData(t, e, s, n) {
    const o = super.parseArrayData(t, e, s, n);
    for (let r = 0; r < o.length; r++) {
      const a = e[s + r];
      o[r]._custom = C(a[2], this.resolveDataElementOptions(r + s).radius);
    }
    return o;
  }
  parseObjectData(t, e, s, n) {
    const o = super.parseObjectData(t, e, s, n);
    for (let r = 0; r < o.length; r++) {
      const a = e[s + r];
      o[r]._custom = C(a && a.r && +a.r, this.resolveDataElementOptions(r + s).radius);
    }
    return o;
  }
  getMaxOverflow() {
    const t = this._cachedMeta.data;
    let e = 0;
    for (let s = t.length - 1; s >= 0; --s)
      e = Math.max(e, t[s].size(this.resolveDataElementOptions(s)) / 2);
    return e > 0 && e;
  }
  getLabelAndValue(t) {
    const e = this._cachedMeta, { xScale: s, yScale: n } = e, o = this.getParsed(t), r = s.getLabelForValue(o.x), a = n.getLabelForValue(o.y), l = o._custom;
    return {
      label: e.label,
      value: "(" + r + ", " + a + (l ? ", " + l : "") + ")"
    };
  }
  update(t) {
    const e = this._cachedMeta.data;
    this.updateElements(e, 0, e.length, t);
  }
  updateElements(t, e, s, n) {
    const o = n === "reset", { iScale: r, vScale: a } = this._cachedMeta, { sharedOptions: l, includeOptions: c } = this._getSharedOptions(e, n), h = r.axis, d = a.axis;
    for (let u = e; u < e + s; u++) {
      const f = t[u], g = !o && this.getParsed(u), p = {}, m = p[h] = o ? r.getPixelForDecimal(0.5) : r.getPixelForValue(g[h]), b = p[d] = o ? a.getBasePixel() : a.getPixelForValue(g[d]);
      p.skip = isNaN(m) || isNaN(b), c && (p.options = l || this.resolveDataElementOptions(u, f.active ? "active" : n), o && (p.options.radius = 0)), this.updateElement(f, u, p, n);
    }
  }
  resolveDataElementOptions(t, e) {
    const s = this.getParsed(t);
    let n = super.resolveDataElementOptions(t, e);
    n.$shared && (n = Object.assign({}, n, { $shared: !1 }));
    const o = n.radius;
    return e !== "active" && (n.radius = 0), n.radius += C(s && s._custom, o), n;
  }
}
fe.id = "bubble";
fe.defaults = {
  datasetElementType: !1,
  dataElementType: "point",
  animations: {
    numbers: {
      type: "number",
      properties: ["x", "y", "borderWidth", "radius"]
    }
  }
};
fe.overrides = {
  scales: {
    x: {
      type: "linear"
    },
    y: {
      type: "linear"
    }
  },
  plugins: {
    tooltip: {
      callbacks: {
        title() {
          return "";
        }
      }
    }
  }
};
function ka(i, t, e) {
  let s = 1, n = 1, o = 0, r = 0;
  if (t < F) {
    const a = i, l = a + t, c = Math.cos(a), h = Math.sin(a), d = Math.cos(l), u = Math.sin(l), f = (v, y, _) => oe(v, a, l, !0) ? 1 : Math.max(y, y * e, _, _ * e), g = (v, y, _) => oe(v, a, l, !0) ? -1 : Math.min(y, y * e, _, _ * e), p = f(0, c, d), m = f(V, h, u), b = g(B, c, d), x = g(B + V, h, u);
    s = (p - b) / 2, n = (m - x) / 2, o = -(p + b) / 2, r = -(m + x) / 2;
  }
  return { ratioX: s, ratioY: n, offsetX: o, offsetY: r };
}
class Lt extends it {
  constructor(t, e) {
    super(t, e), this.enableOptionSharing = !0, this.innerRadius = void 0, this.outerRadius = void 0, this.offsetX = void 0, this.offsetY = void 0;
  }
  linkScales() {
  }
  parse(t, e) {
    const s = this.getDataset().data, n = this._cachedMeta;
    if (this._parsing === !1)
      n._parsed = s;
    else {
      let o = (l) => +s[l];
      if (D(s[t])) {
        const { key: l = "value" } = this._parsing;
        o = (c) => +_t(s[c], l);
      }
      let r, a;
      for (r = t, a = t + e; r < a; ++r)
        n._parsed[r] = o(r);
    }
  }
  _getRotation() {
    return nt(this.options.rotation - 90);
  }
  _getCircumference() {
    return nt(this.options.circumference);
  }
  _getRotationExtents() {
    let t = F, e = -F;
    for (let s = 0; s < this.chart.data.datasets.length; ++s)
      if (this.chart.isDatasetVisible(s)) {
        const n = this.chart.getDatasetMeta(s).controller, o = n._getRotation(), r = n._getCircumference();
        t = Math.min(t, o), e = Math.max(e, o + r);
      }
    return {
      rotation: t,
      circumference: e - t
    };
  }
  update(t) {
    const e = this.chart, { chartArea: s } = e, n = this._cachedMeta, o = n.data, r = this.getMaxBorderWidth() + this.getMaxOffset(o) + this.options.spacing, a = Math.max((Math.min(s.width, s.height) - r) / 2, 0), l = Math.min(yo(this.options.cutout, a), 1), c = this._getRingWeight(this.index), { circumference: h, rotation: d } = this._getRotationExtents(), { ratioX: u, ratioY: f, offsetX: g, offsetY: p } = ka(d, h, l), m = (s.width - r) / u, b = (s.height - r) / f, x = Math.max(Math.min(m, b) / 2, 0), v = an(this.options.radius, x), y = Math.max(v * l, 0), _ = (v - y) / this._getVisibleDatasetWeightTotal();
    this.offsetX = g * v, this.offsetY = p * v, n.total = this.calculateTotal(), this.outerRadius = v - _ * this._getRingWeightOffset(this.index), this.innerRadius = Math.max(this.outerRadius - _ * c, 0), this.updateElements(o, 0, o.length, t);
  }
  _circumference(t, e) {
    const s = this.options, n = this._cachedMeta, o = this._getCircumference();
    return e && s.animation.animateRotate || !this.chart.getDataVisibility(t) || n._parsed[t] === null || n.data[t].hidden ? 0 : this.calculateCircumference(n._parsed[t] * o / F);
  }
  updateElements(t, e, s, n) {
    const o = n === "reset", r = this.chart, a = r.chartArea, c = r.options.animation, h = (a.left + a.right) / 2, d = (a.top + a.bottom) / 2, u = o && c.animateScale, f = u ? 0 : this.innerRadius, g = u ? 0 : this.outerRadius, { sharedOptions: p, includeOptions: m } = this._getSharedOptions(e, n);
    let b = this._getRotation(), x;
    for (x = 0; x < e; ++x)
      b += this._circumference(x, o);
    for (x = e; x < e + s; ++x) {
      const v = this._circumference(x, o), y = t[x], _ = {
        x: h + this.offsetX,
        y: d + this.offsetY,
        startAngle: b,
        endAngle: b + v,
        circumference: v,
        outerRadius: g,
        innerRadius: f
      };
      m && (_.options = p || this.resolveDataElementOptions(x, y.active ? "active" : n)), b += v, this.updateElement(y, x, _, n);
    }
  }
  calculateTotal() {
    const t = this._cachedMeta, e = t.data;
    let s = 0, n;
    for (n = 0; n < e.length; n++) {
      const o = t._parsed[n];
      o !== null && !isNaN(o) && this.chart.getDataVisibility(n) && !e[n].hidden && (s += Math.abs(o));
    }
    return s;
  }
  calculateCircumference(t) {
    const e = this._cachedMeta.total;
    return e > 0 && !isNaN(t) ? F * (Math.abs(t) / e) : 0;
  }
  getLabelAndValue(t) {
    const e = this._cachedMeta, s = this.chart, n = s.data.labels || [], o = de(e._parsed[t], s.options.locale);
    return {
      label: n[t] || "",
      value: o
    };
  }
  getMaxBorderWidth(t) {
    let e = 0;
    const s = this.chart;
    let n, o, r, a, l;
    if (!t) {
      for (n = 0, o = s.data.datasets.length; n < o; ++n)
        if (s.isDatasetVisible(n)) {
          r = s.getDatasetMeta(n), t = r.data, a = r.controller;
          break;
        }
    }
    if (!t)
      return 0;
    for (n = 0, o = t.length; n < o; ++n)
      l = a.resolveDataElementOptions(n), l.borderAlign !== "inner" && (e = Math.max(e, l.borderWidth || 0, l.hoverBorderWidth || 0));
    return e;
  }
  getMaxOffset(t) {
    let e = 0;
    for (let s = 0, n = t.length; s < n; ++s) {
      const o = this.resolveDataElementOptions(s);
      e = Math.max(e, o.offset || 0, o.hoverOffset || 0);
    }
    return e;
  }
  _getRingWeightOffset(t) {
    let e = 0;
    for (let s = 0; s < t; ++s)
      this.chart.isDatasetVisible(s) && (e += this._getRingWeight(s));
    return e;
  }
  _getRingWeight(t) {
    return Math.max(C(this.chart.data.datasets[t].weight, 1), 0);
  }
  _getVisibleDatasetWeightTotal() {
    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
  }
}
Lt.id = "doughnut";
Lt.defaults = {
  datasetElementType: !1,
  dataElementType: "arc",
  animation: {
    animateRotate: !0,
    animateScale: !1
  },
  animations: {
    numbers: {
      type: "number",
      properties: ["circumference", "endAngle", "innerRadius", "outerRadius", "startAngle", "x", "y", "offset", "borderWidth", "spacing"]
    }
  },
  cutout: "50%",
  rotation: 0,
  circumference: 360,
  radius: "100%",
  spacing: 0,
  indexAxis: "r"
};
Lt.descriptors = {
  _scriptable: (i) => i !== "spacing",
  _indexable: (i) => i !== "spacing"
};
Lt.overrides = {
  aspectRatio: 1,
  plugins: {
    legend: {
      labels: {
        generateLabels(i) {
          const t = i.data;
          if (t.labels.length && t.datasets.length) {
            const { labels: { pointStyle: e } } = i.legend.options;
            return t.labels.map((s, n) => {
              const r = i.getDatasetMeta(0).controller.getStyle(n);
              return {
                text: s,
                fillStyle: r.backgroundColor,
                strokeStyle: r.borderColor,
                lineWidth: r.borderWidth,
                pointStyle: e,
                hidden: !i.getDataVisibility(n),
                index: n
              };
            });
          }
          return [];
        }
      },
      onClick(i, t, e) {
        e.chart.toggleDataVisibility(t.index), e.chart.update();
      }
    },
    tooltip: {
      callbacks: {
        title() {
          return "";
        },
        label(i) {
          let t = i.label;
          const e = ": " + i.formattedValue;
          return z(t) ? (t = t.slice(), t[0] += e) : t += e, t;
        }
      }
    }
  }
};
class ge extends it {
  initialize() {
    this.enableOptionSharing = !0, this.supportsDecimation = !0, super.initialize();
  }
  update(t) {
    const e = this._cachedMeta, { dataset: s, data: n = [], _dataset: o } = e, r = this.chart._animationsDisabled;
    let { start: a, count: l } = pn(e, n, r);
    this._drawStart = a, this._drawCount = l, mn(e) && (a = 0, l = n.length), s._chart = this.chart, s._datasetIndex = this.index, s._decimated = !!o._decimated, s.points = n;
    const c = this.resolveDatasetElementOptions(t);
    this.options.showLine || (c.borderWidth = 0), c.segment = this.options.segment, this.updateElement(s, void 0, {
      animated: !r,
      options: c
    }, t), this.updateElements(n, a, l, t);
  }
  updateElements(t, e, s, n) {
    const o = n === "reset", { iScale: r, vScale: a, _stacked: l, _dataset: c } = this._cachedMeta, { sharedOptions: h, includeOptions: d } = this._getSharedOptions(e, n), u = r.axis, f = a.axis, { spanGaps: g, segment: p } = this.options, m = Bt(g) ? g : Number.POSITIVE_INFINITY, b = this.chart._animationsDisabled || o || n === "none";
    let x = e > 0 && this.getParsed(e - 1);
    for (let v = e; v < e + s; ++v) {
      const y = t[v], _ = this.getParsed(v), M = b ? y : {}, k = T(_[f]), S = M[u] = r.getPixelForValue(_[u], v), w = M[f] = o || k ? a.getBasePixel() : a.getPixelForValue(l ? this.applyStack(a, _, l) : _[f], v);
      M.skip = isNaN(S) || isNaN(w) || k, M.stop = v > 0 && Math.abs(_[u] - x[u]) > m, p && (M.parsed = _, M.raw = c.data[v]), d && (M.options = h || this.resolveDataElementOptions(v, y.active ? "active" : n)), b || this.updateElement(y, v, M, n), x = _;
    }
  }
  getMaxOverflow() {
    const t = this._cachedMeta, e = t.dataset, s = e.options && e.options.borderWidth || 0, n = t.data || [];
    if (!n.length)
      return s;
    const o = n[0].size(this.resolveDataElementOptions(0)), r = n[n.length - 1].size(this.resolveDataElementOptions(n.length - 1));
    return Math.max(s, o, r) / 2;
  }
  draw() {
    const t = this._cachedMeta;
    t.dataset.updateControlPoints(this.chart.chartArea, t.iScale.axis), super.draw();
  }
}
ge.id = "line";
ge.defaults = {
  datasetElementType: "line",
  dataElementType: "point",
  showLine: !0,
  spanGaps: !1
};
ge.overrides = {
  scales: {
    _index_: {
      type: "category"
    },
    _value_: {
      type: "linear"
    }
  }
};
class pe extends it {
  constructor(t, e) {
    super(t, e), this.innerRadius = void 0, this.outerRadius = void 0;
  }
  getLabelAndValue(t) {
    const e = this._cachedMeta, s = this.chart, n = s.data.labels || [], o = de(e._parsed[t].r, s.options.locale);
    return {
      label: n[t] || "",
      value: o
    };
  }
  parseObjectData(t, e, s, n) {
    return Dn.bind(this)(t, e, s, n);
  }
  update(t) {
    const e = this._cachedMeta.data;
    this._updateRadius(), this.updateElements(e, 0, e.length, t);
  }
  getMinMax() {
    const t = this._cachedMeta, e = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY };
    return t.data.forEach((s, n) => {
      const o = this.getParsed(n).r;
      !isNaN(o) && this.chart.getDataVisibility(n) && (o < e.min && (e.min = o), o > e.max && (e.max = o));
    }), e;
  }
  _updateRadius() {
    const t = this.chart, e = t.chartArea, s = t.options, n = Math.min(e.right - e.left, e.bottom - e.top), o = Math.max(n / 2, 0), r = Math.max(s.cutoutPercentage ? o / 100 * s.cutoutPercentage : 1, 0), a = (o - r) / t.getVisibleDatasetCount();
    this.outerRadius = o - a * this.index, this.innerRadius = this.outerRadius - a;
  }
  updateElements(t, e, s, n) {
    const o = n === "reset", r = this.chart, l = r.options.animation, c = this._cachedMeta.rScale, h = c.xCenter, d = c.yCenter, u = c.getIndexAngle(0) - 0.5 * B;
    let f = u, g;
    const p = 360 / this.countVisibleElements();
    for (g = 0; g < e; ++g)
      f += this._computeAngle(g, n, p);
    for (g = e; g < e + s; g++) {
      const m = t[g];
      let b = f, x = f + this._computeAngle(g, n, p), v = r.getDataVisibility(g) ? c.getDistanceFromCenterForValue(this.getParsed(g).r) : 0;
      f = x, o && (l.animateScale && (v = 0), l.animateRotate && (b = x = u));
      const y = {
        x: h,
        y: d,
        innerRadius: 0,
        outerRadius: v,
        startAngle: b,
        endAngle: x,
        options: this.resolveDataElementOptions(g, m.active ? "active" : n)
      };
      this.updateElement(m, g, y, n);
    }
  }
  countVisibleElements() {
    const t = this._cachedMeta;
    let e = 0;
    return t.data.forEach((s, n) => {
      !isNaN(this.getParsed(n).r) && this.chart.getDataVisibility(n) && e++;
    }), e;
  }
  _computeAngle(t, e, s) {
    return this.chart.getDataVisibility(t) ? nt(this.resolveDataElementOptions(t, e).angle || s) : 0;
  }
}
pe.id = "polarArea";
pe.defaults = {
  dataElementType: "arc",
  animation: {
    animateRotate: !0,
    animateScale: !0
  },
  animations: {
    numbers: {
      type: "number",
      properties: ["x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius"]
    }
  },
  indexAxis: "r",
  startAngle: 0
};
pe.overrides = {
  aspectRatio: 1,
  plugins: {
    legend: {
      labels: {
        generateLabels(i) {
          const t = i.data;
          if (t.labels.length && t.datasets.length) {
            const { labels: { pointStyle: e } } = i.legend.options;
            return t.labels.map((s, n) => {
              const r = i.getDatasetMeta(0).controller.getStyle(n);
              return {
                text: s,
                fillStyle: r.backgroundColor,
                strokeStyle: r.borderColor,
                lineWidth: r.borderWidth,
                pointStyle: e,
                hidden: !i.getDataVisibility(n),
                index: n
              };
            });
          }
          return [];
        }
      },
      onClick(i, t, e) {
        e.chart.toggleDataVisibility(t.index), e.chart.update();
      }
    },
    tooltip: {
      callbacks: {
        title() {
          return "";
        },
        label(i) {
          return i.chart.data.labels[i.dataIndex] + ": " + i.formattedValue;
        }
      }
    }
  },
  scales: {
    r: {
      type: "radialLinear",
      angleLines: {
        display: !1
      },
      beginAtZero: !0,
      grid: {
        circular: !0
      },
      pointLabels: {
        display: !1
      },
      startAngle: 0
    }
  }
};
class qe extends Lt {
}
qe.id = "pie";
qe.defaults = {
  cutout: 0,
  rotation: 0,
  circumference: 360,
  radius: "100%"
};
class me extends it {
  getLabelAndValue(t) {
    const e = this._cachedMeta.vScale, s = this.getParsed(t);
    return {
      label: e.getLabels()[t],
      value: "" + e.getLabelForValue(s[e.axis])
    };
  }
  parseObjectData(t, e, s, n) {
    return Dn.bind(this)(t, e, s, n);
  }
  update(t) {
    const e = this._cachedMeta, s = e.dataset, n = e.data || [], o = e.iScale.getLabels();
    if (s.points = n, t !== "resize") {
      const r = this.resolveDatasetElementOptions(t);
      this.options.showLine || (r.borderWidth = 0);
      const a = {
        _loop: !0,
        _fullLoop: o.length === n.length,
        options: r
      };
      this.updateElement(s, void 0, a, t);
    }
    this.updateElements(n, 0, n.length, t);
  }
  updateElements(t, e, s, n) {
    const o = this._cachedMeta.rScale, r = n === "reset";
    for (let a = e; a < e + s; a++) {
      const l = t[a], c = this.resolveDataElementOptions(a, l.active ? "active" : n), h = o.getPointPositionForValue(a, this.getParsed(a).r), d = r ? o.xCenter : h.x, u = r ? o.yCenter : h.y, f = {
        x: d,
        y: u,
        angle: h.angle,
        skip: isNaN(d) || isNaN(u),
        options: c
      };
      this.updateElement(l, a, f, n);
    }
  }
}
me.id = "radar";
me.defaults = {
  datasetElementType: "line",
  dataElementType: "point",
  indexAxis: "r",
  showLine: !0,
  elements: {
    line: {
      fill: "start"
    }
  }
};
me.overrides = {
  aspectRatio: 1,
  scales: {
    r: {
      type: "radialLinear"
    }
  }
};
class st {
  constructor() {
    this.x = void 0, this.y = void 0, this.active = !1, this.options = void 0, this.$animations = void 0;
  }
  tooltipPosition(t) {
    const { x: e, y: s } = this.getProps(["x", "y"], t);
    return { x: e, y: s };
  }
  hasValue() {
    return Bt(this.x) && Bt(this.y);
  }
  getProps(t, e) {
    const s = this.$animations;
    if (!e || !s)
      return this;
    const n = {};
    return t.forEach((o) => {
      n[o] = s[o] && s[o].active() ? s[o]._to : this[o];
    }), n;
  }
}
st.defaults = {};
st.defaultRoutes = void 0;
const Vn = {
  values(i) {
    return z(i) ? i : "" + i;
  },
  numeric(i, t, e) {
    if (i === 0)
      return "0";
    const s = this.chart.options.locale;
    let n, o = i;
    if (e.length > 1) {
      const c = Math.max(Math.abs(e[0].value), Math.abs(e[e.length - 1].value));
      (c < 1e-4 || c > 1e15) && (n = "scientific"), o = wa(i, e);
    }
    const r = tt(Math.abs(o)), a = Math.max(Math.min(-1 * Math.floor(r), 20), 0), l = { notation: n, minimumFractionDigits: a, maximumFractionDigits: a };
    return Object.assign(l, this.options.ticks.format), de(i, s, l);
  },
  logarithmic(i, t, e) {
    if (i === 0)
      return "0";
    const s = i / Math.pow(10, Math.floor(tt(i)));
    return s === 1 || s === 2 || s === 5 ? Vn.numeric.call(this, i, t, e) : "";
  }
};
function wa(i, t) {
  let e = t.length > 3 ? t[2].value - t[1].value : t[1].value - t[0].value;
  return Math.abs(e) >= 1 && i !== Math.floor(i) && (e = i - Math.floor(i)), e;
}
var be = { formatters: Vn };
O.set("scale", {
  display: !0,
  offset: !1,
  reverse: !1,
  beginAtZero: !1,
  bounds: "ticks",
  grace: 0,
  grid: {
    display: !0,
    lineWidth: 1,
    drawBorder: !0,
    drawOnChartArea: !0,
    drawTicks: !0,
    tickLength: 8,
    tickWidth: (i, t) => t.lineWidth,
    tickColor: (i, t) => t.color,
    offset: !1,
    borderDash: [],
    borderDashOffset: 0,
    borderWidth: 1
  },
  title: {
    display: !1,
    text: "",
    padding: {
      top: 4,
      bottom: 4
    }
  },
  ticks: {
    minRotation: 0,
    maxRotation: 50,
    mirror: !1,
    textStrokeWidth: 0,
    textStrokeColor: "",
    padding: 3,
    display: !0,
    autoSkip: !0,
    autoSkipPadding: 3,
    labelOffset: 0,
    callback: be.formatters.values,
    minor: {},
    major: {},
    align: "center",
    crossAlign: "near",
    showLabelBackdrop: !1,
    backdropColor: "rgba(255, 255, 255, 0.75)",
    backdropPadding: 2
  }
});
O.route("scale.ticks", "color", "", "color");
O.route("scale.grid", "color", "", "borderColor");
O.route("scale.grid", "borderColor", "", "borderColor");
O.route("scale.title", "color", "", "color");
O.describe("scale", {
  _fallback: !1,
  _scriptable: (i) => !i.startsWith("before") && !i.startsWith("after") && i !== "callback" && i !== "parser",
  _indexable: (i) => i !== "borderDash" && i !== "tickBorderDash"
});
O.describe("scales", {
  _fallback: "scale"
});
O.describe("scale.ticks", {
  _scriptable: (i) => i !== "backdropPadding" && i !== "callback",
  _indexable: (i) => i !== "backdropPadding"
});
function Sa(i, t) {
  const e = i.options.ticks, s = e.maxTicksLimit || Pa(i), n = e.major.enabled ? Da(t) : [], o = n.length, r = n[0], a = n[o - 1], l = [];
  if (o > s)
    return Oa(t, l, n, o / s), l;
  const c = Ca(n, t, s);
  if (o > 0) {
    let h, d;
    const u = o > 1 ? Math.round((a - r) / (o - 1)) : null;
    for (Oe(t, l, c, T(u) ? 0 : r - u, r), h = 0, d = o - 1; h < d; h++)
      Oe(t, l, c, n[h], n[h + 1]);
    return Oe(t, l, c, a, T(u) ? t.length : a + u), l;
  }
  return Oe(t, l, c), l;
}
function Pa(i) {
  const t = i.options.offset, e = i._tickSize(), s = i._length / e + (t ? 0 : 1), n = i._maxLength / e;
  return Math.floor(Math.min(s, n));
}
function Ca(i, t, e) {
  const s = Aa(i), n = t.length / e;
  if (!s)
    return Math.max(n, 1);
  const o = Do(s);
  for (let r = 0, a = o.length - 1; r < a; r++) {
    const l = o[r];
    if (l > n)
      return l;
  }
  return Math.max(n, 1);
}
function Da(i) {
  const t = [];
  let e, s;
  for (e = 0, s = i.length; e < s; e++)
    i[e].major && t.push(e);
  return t;
}
function Oa(i, t, e, s) {
  let n = 0, o = e[0], r;
  for (s = Math.ceil(s), r = 0; r < i.length; r++)
    r === o && (t.push(i[r]), n++, o = e[n * s]);
}
function Oe(i, t, e, s, n) {
  const o = C(s, 0), r = Math.min(C(n, i.length), i.length);
  let a = 0, l, c, h;
  for (e = Math.ceil(e), n && (l = n - s, e = l / Math.floor(l / e)), h = o; h < 0; )
    a++, h = Math.round(o + a * e);
  for (c = Math.max(o, 0); c < r; c++)
    c === h && (t.push(i[c]), a++, h = Math.round(o + a * e));
}
function Aa(i) {
  const t = i.length;
  let e, s;
  if (t < 2)
    return !1;
  for (s = i[0], e = 1; e < t; ++e)
    if (i[e] - i[e - 1] !== s)
      return !1;
  return s;
}
const Ta = (i) => i === "left" ? "right" : i === "right" ? "left" : i, ws = (i, t, e) => t === "top" || t === "left" ? i[t] + e : i[t] - e;
function Ss(i, t) {
  const e = [], s = i.length / t, n = i.length;
  let o = 0;
  for (; o < n; o += s)
    e.push(i[Math.floor(o)]);
  return e;
}
function La(i, t, e) {
  const s = i.ticks.length, n = Math.min(t, s - 1), o = i._startPixel, r = i._endPixel, a = 1e-6;
  let l = i.getPixelForTick(n), c;
  if (!(e && (s === 1 ? c = Math.max(l - o, r - l) : t === 0 ? c = (i.getPixelForTick(1) - l) / 2 : c = (l - i.getPixelForTick(n - 1)) / 2, l += n < t ? c : -c, l < o - a || l > r + a)))
    return l;
}
function Ra(i, t) {
  E(i, (e) => {
    const s = e.gc, n = s.length / 2;
    let o;
    if (n > t) {
      for (o = 0; o < n; ++o)
        delete e.data[s[o]];
      s.splice(0, n);
    }
  });
}
function Xt(i) {
  return i.drawTicks ? i.tickLength : 0;
}
function Ps(i, t) {
  if (!i.display)
    return 0;
  const e = $(i.font, t), s = K(i.padding);
  return (z(i.text) ? i.text.length : 1) * e.lineHeight + s.height;
}
function Ea(i, t) {
  return vt(i, {
    scale: t,
    type: "scale"
  });
}
function Fa(i, t, e) {
  return vt(i, {
    tick: e,
    index: t,
    type: "tick"
  });
}
function Ia(i, t, e) {
  let s = Li(i);
  return (e && t !== "right" || !e && t === "right") && (s = Ta(s)), s;
}
function za(i, t, e, s) {
  const { top: n, left: o, bottom: r, right: a, chart: l } = i, { chartArea: c, scales: h } = l;
  let d = 0, u, f, g;
  const p = r - n, m = a - o;
  if (i.isHorizontal()) {
    if (f = U(s, o, a), D(e)) {
      const b = Object.keys(e)[0], x = e[b];
      g = h[b].getPixelForValue(x) + p - t;
    } else
      e === "center" ? g = (c.bottom + c.top) / 2 + p - t : g = ws(i, e, t);
    u = a - o;
  } else {
    if (D(e)) {
      const b = Object.keys(e)[0], x = e[b];
      f = h[b].getPixelForValue(x) - m + t;
    } else
      e === "center" ? f = (c.left + c.right) / 2 - m + t : f = ws(i, e, t);
    g = U(s, r, n), d = e === "left" ? -V : V;
  }
  return { titleX: f, titleY: g, maxWidth: u, rotation: d };
}
class Mt extends st {
  constructor(t) {
    super(), this.id = t.id, this.type = t.type, this.options = void 0, this.ctx = t.ctx, this.chart = t.chart, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this._margins = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, this.maxWidth = void 0, this.maxHeight = void 0, this.paddingTop = void 0, this.paddingBottom = void 0, this.paddingLeft = void 0, this.paddingRight = void 0, this.axis = void 0, this.labelRotation = void 0, this.min = void 0, this.max = void 0, this._range = void 0, this.ticks = [], this._gridLineItems = null, this._labelItems = null, this._labelSizes = null, this._length = 0, this._maxLength = 0, this._longestTextCache = {}, this._startPixel = void 0, this._endPixel = void 0, this._reversePixels = !1, this._userMax = void 0, this._userMin = void 0, this._suggestedMax = void 0, this._suggestedMin = void 0, this._ticksLength = 0, this._borderValue = 0, this._cache = {}, this._dataLimitsCached = !1, this.$context = void 0;
  }
  init(t) {
    this.options = t.setContext(this.getContext()), this.axis = t.axis, this._userMin = this.parse(t.min), this._userMax = this.parse(t.max), this._suggestedMin = this.parse(t.suggestedMin), this._suggestedMax = this.parse(t.suggestedMax);
  }
  parse(t, e) {
    return t;
  }
  getUserBounds() {
    let { _userMin: t, _userMax: e, _suggestedMin: s, _suggestedMax: n } = this;
    return t = Q(t, Number.POSITIVE_INFINITY), e = Q(e, Number.NEGATIVE_INFINITY), s = Q(s, Number.POSITIVE_INFINITY), n = Q(n, Number.NEGATIVE_INFINITY), {
      min: Q(t, s),
      max: Q(e, n),
      minDefined: N(t),
      maxDefined: N(e)
    };
  }
  getMinMax(t) {
    let { min: e, max: s, minDefined: n, maxDefined: o } = this.getUserBounds(), r;
    if (n && o)
      return { min: e, max: s };
    const a = this.getMatchingVisibleMetas();
    for (let l = 0, c = a.length; l < c; ++l)
      r = a[l].controller.getMinMax(this, t), n || (e = Math.min(e, r.min)), o || (s = Math.max(s, r.max));
    return e = o && e > s ? s : e, s = n && e > s ? e : s, {
      min: Q(e, Q(s, e)),
      max: Q(s, Q(e, s))
    };
  }
  getPadding() {
    return {
      left: this.paddingLeft || 0,
      top: this.paddingTop || 0,
      right: this.paddingRight || 0,
      bottom: this.paddingBottom || 0
    };
  }
  getTicks() {
    return this.ticks;
  }
  getLabels() {
    const t = this.chart.data;
    return this.options.labels || (this.isHorizontal() ? t.xLabels : t.yLabels) || t.labels || [];
  }
  beforeLayout() {
    this._cache = {}, this._dataLimitsCached = !1;
  }
  beforeUpdate() {
    I(this.options.beforeUpdate, [this]);
  }
  update(t, e, s) {
    const { beginAtZero: n, grace: o, ticks: r } = this.options, a = r.sampleSize;
    this.beforeUpdate(), this.maxWidth = t, this.maxHeight = e, this._margins = s = Object.assign({
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, s), this.ticks = null, this._labelSizes = null, this._gridLineItems = null, this._labelItems = null, this.beforeSetDimensions(), this.setDimensions(), this.afterSetDimensions(), this._maxLength = this.isHorizontal() ? this.width + s.left + s.right : this.height + s.top + s.bottom, this._dataLimitsCached || (this.beforeDataLimits(), this.determineDataLimits(), this.afterDataLimits(), this._range = mr(this, o, n), this._dataLimitsCached = !0), this.beforeBuildTicks(), this.ticks = this.buildTicks() || [], this.afterBuildTicks();
    const l = a < this.ticks.length;
    this._convertTicksToLabels(l ? Ss(this.ticks, a) : this.ticks), this.configure(), this.beforeCalculateLabelRotation(), this.calculateLabelRotation(), this.afterCalculateLabelRotation(), r.display && (r.autoSkip || r.source === "auto") && (this.ticks = Sa(this, this.ticks), this._labelSizes = null, this.afterAutoSkip()), l && this._convertTicksToLabels(this.ticks), this.beforeFit(), this.fit(), this.afterFit(), this.afterUpdate();
  }
  configure() {
    let t = this.options.reverse, e, s;
    this.isHorizontal() ? (e = this.left, s = this.right) : (e = this.top, s = this.bottom, t = !t), this._startPixel = e, this._endPixel = s, this._reversePixels = t, this._length = s - e, this._alignToPixels = this.options.alignToPixels;
  }
  afterUpdate() {
    I(this.options.afterUpdate, [this]);
  }
  beforeSetDimensions() {
    I(this.options.beforeSetDimensions, [this]);
  }
  setDimensions() {
    this.isHorizontal() ? (this.width = this.maxWidth, this.left = 0, this.right = this.width) : (this.height = this.maxHeight, this.top = 0, this.bottom = this.height), this.paddingLeft = 0, this.paddingTop = 0, this.paddingRight = 0, this.paddingBottom = 0;
  }
  afterSetDimensions() {
    I(this.options.afterSetDimensions, [this]);
  }
  _callHooks(t) {
    this.chart.notifyPlugins(t, this.getContext()), I(this.options[t], [this]);
  }
  beforeDataLimits() {
    this._callHooks("beforeDataLimits");
  }
  determineDataLimits() {
  }
  afterDataLimits() {
    this._callHooks("afterDataLimits");
  }
  beforeBuildTicks() {
    this._callHooks("beforeBuildTicks");
  }
  buildTicks() {
    return [];
  }
  afterBuildTicks() {
    this._callHooks("afterBuildTicks");
  }
  beforeTickToLabelConversion() {
    I(this.options.beforeTickToLabelConversion, [this]);
  }
  generateTickLabels(t) {
    const e = this.options.ticks;
    let s, n, o;
    for (s = 0, n = t.length; s < n; s++)
      o = t[s], o.label = I(e.callback, [o.value, s, t], this);
  }
  afterTickToLabelConversion() {
    I(this.options.afterTickToLabelConversion, [this]);
  }
  beforeCalculateLabelRotation() {
    I(this.options.beforeCalculateLabelRotation, [this]);
  }
  calculateLabelRotation() {
    const t = this.options, e = t.ticks, s = this.ticks.length, n = e.minRotation || 0, o = e.maxRotation;
    let r = n, a, l, c;
    if (!this._isVisible() || !e.display || n >= o || s <= 1 || !this.isHorizontal()) {
      this.labelRotation = n;
      return;
    }
    const h = this._getLabelSizes(), d = h.widest.width, u = h.highest.height, f = Y(this.chart.width - d, 0, this.maxWidth);
    a = t.offset ? this.maxWidth / s : f / (s - 1), d + 6 > a && (a = f / (s - (t.offset ? 0.5 : 1)), l = this.maxHeight - Xt(t.grid) - e.padding - Ps(t.title, this.chart.options.font), c = Math.sqrt(d * d + u * u), r = Ai(Math.min(
      Math.asin(Y((h.highest.height + 6) / a, -1, 1)),
      Math.asin(Y(l / c, -1, 1)) - Math.asin(Y(u / c, -1, 1))
    )), r = Math.max(n, Math.min(o, r))), this.labelRotation = r;
  }
  afterCalculateLabelRotation() {
    I(this.options.afterCalculateLabelRotation, [this]);
  }
  afterAutoSkip() {
  }
  beforeFit() {
    I(this.options.beforeFit, [this]);
  }
  fit() {
    const t = {
      width: 0,
      height: 0
    }, { chart: e, options: { ticks: s, title: n, grid: o } } = this, r = this._isVisible(), a = this.isHorizontal();
    if (r) {
      const l = Ps(n, e.options.font);
      if (a ? (t.width = this.maxWidth, t.height = Xt(o) + l) : (t.height = this.maxHeight, t.width = Xt(o) + l), s.display && this.ticks.length) {
        const { first: c, last: h, widest: d, highest: u } = this._getLabelSizes(), f = s.padding * 2, g = nt(this.labelRotation), p = Math.cos(g), m = Math.sin(g);
        if (a) {
          const b = s.mirror ? 0 : m * d.width + p * u.height;
          t.height = Math.min(this.maxHeight, t.height + b + f);
        } else {
          const b = s.mirror ? 0 : p * d.width + m * u.height;
          t.width = Math.min(this.maxWidth, t.width + b + f);
        }
        this._calculatePadding(c, h, m, p);
      }
    }
    this._handleMargins(), a ? (this.width = this._length = e.width - this._margins.left - this._margins.right, this.height = t.height) : (this.width = t.width, this.height = this._length = e.height - this._margins.top - this._margins.bottom);
  }
  _calculatePadding(t, e, s, n) {
    const { ticks: { align: o, padding: r }, position: a } = this.options, l = this.labelRotation !== 0, c = a !== "top" && this.axis === "x";
    if (this.isHorizontal()) {
      const h = this.getPixelForTick(0) - this.left, d = this.right - this.getPixelForTick(this.ticks.length - 1);
      let u = 0, f = 0;
      l ? c ? (u = n * t.width, f = s * e.height) : (u = s * t.height, f = n * e.width) : o === "start" ? f = e.width : o === "end" ? u = t.width : o !== "inner" && (u = t.width / 2, f = e.width / 2), this.paddingLeft = Math.max((u - h + r) * this.width / (this.width - h), 0), this.paddingRight = Math.max((f - d + r) * this.width / (this.width - d), 0);
    } else {
      let h = e.height / 2, d = t.height / 2;
      o === "start" ? (h = 0, d = t.height) : o === "end" && (h = e.height, d = 0), this.paddingTop = h + r, this.paddingBottom = d + r;
    }
  }
  _handleMargins() {
    this._margins && (this._margins.left = Math.max(this.paddingLeft, this._margins.left), this._margins.top = Math.max(this.paddingTop, this._margins.top), this._margins.right = Math.max(this.paddingRight, this._margins.right), this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom));
  }
  afterFit() {
    I(this.options.afterFit, [this]);
  }
  isHorizontal() {
    const { axis: t, position: e } = this.options;
    return e === "top" || e === "bottom" || t === "x";
  }
  isFullSize() {
    return this.options.fullSize;
  }
  _convertTicksToLabels(t) {
    this.beforeTickToLabelConversion(), this.generateTickLabels(t);
    let e, s;
    for (e = 0, s = t.length; e < s; e++)
      T(t[e].label) && (t.splice(e, 1), s--, e--);
    this.afterTickToLabelConversion();
  }
  _getLabelSizes() {
    let t = this._labelSizes;
    if (!t) {
      const e = this.options.ticks.sampleSize;
      let s = this.ticks;
      e < s.length && (s = Ss(s, e)), this._labelSizes = t = this._computeLabelSizes(s, s.length);
    }
    return t;
  }
  _computeLabelSizes(t, e) {
    const { ctx: s, _longestTextCache: n } = this, o = [], r = [];
    let a = 0, l = 0, c, h, d, u, f, g, p, m, b, x, v;
    for (c = 0; c < e; ++c) {
      if (u = t[c].label, f = this._resolveTickFontOptions(c), s.font = g = f.string, p = n[g] = n[g] || { data: {}, gc: [] }, m = f.lineHeight, b = x = 0, !T(u) && !z(u))
        b = Ne(s, p.data, p.gc, b, u), x = m;
      else if (z(u))
        for (h = 0, d = u.length; h < d; ++h)
          v = u[h], !T(v) && !z(v) && (b = Ne(s, p.data, p.gc, b, v), x += m);
      o.push(b), r.push(x), a = Math.max(b, a), l = Math.max(x, l);
    }
    Ra(n, e);
    const y = o.indexOf(a), _ = r.indexOf(l), M = (k) => ({ width: o[k] || 0, height: r[k] || 0 });
    return {
      first: M(0),
      last: M(e - 1),
      widest: M(y),
      highest: M(_),
      widths: o,
      heights: r
    };
  }
  getLabelForValue(t) {
    return t;
  }
  getPixelForValue(t, e) {
    return NaN;
  }
  getValueForPixel(t) {
  }
  getPixelForTick(t) {
    const e = this.ticks;
    return t < 0 || t > e.length - 1 ? null : this.getPixelForValue(e[t].value);
  }
  getPixelForDecimal(t) {
    this._reversePixels && (t = 1 - t);
    const e = this._startPixel + t * this._length;
    return To(this._alignToPixels ? wt(this.chart, e, 0) : e);
  }
  getDecimalForPixel(t) {
    const e = (t - this._startPixel) / this._length;
    return this._reversePixels ? 1 - e : e;
  }
  getBasePixel() {
    return this.getPixelForValue(this.getBaseValue());
  }
  getBaseValue() {
    const { min: t, max: e } = this;
    return t < 0 && e < 0 ? e : t > 0 && e > 0 ? t : 0;
  }
  getContext(t) {
    const e = this.ticks || [];
    if (t >= 0 && t < e.length) {
      const s = e[t];
      return s.$context || (s.$context = Fa(this.getContext(), t, s));
    }
    return this.$context || (this.$context = Ea(this.chart.getContext(), this));
  }
  _tickSize() {
    const t = this.options.ticks, e = nt(this.labelRotation), s = Math.abs(Math.cos(e)), n = Math.abs(Math.sin(e)), o = this._getLabelSizes(), r = t.autoSkipPadding || 0, a = o ? o.widest.width + r : 0, l = o ? o.highest.height + r : 0;
    return this.isHorizontal() ? l * s > a * n ? a / s : l / n : l * n < a * s ? l / s : a / n;
  }
  _isVisible() {
    const t = this.options.display;
    return t !== "auto" ? !!t : this.getMatchingVisibleMetas().length > 0;
  }
  _computeGridLineItems(t) {
    const e = this.axis, s = this.chart, n = this.options, { grid: o, position: r } = n, a = o.offset, l = this.isHorizontal(), h = this.ticks.length + (a ? 1 : 0), d = Xt(o), u = [], f = o.setContext(this.getContext()), g = f.drawBorder ? f.borderWidth : 0, p = g / 2, m = function(P) {
      return wt(s, P, g);
    };
    let b, x, v, y, _, M, k, S, w, L, R, A;
    if (r === "top")
      b = m(this.bottom), M = this.bottom - d, S = b - p, L = m(t.top) + p, A = t.bottom;
    else if (r === "bottom")
      b = m(this.top), L = t.top, A = m(t.bottom) - p, M = b + p, S = this.top + d;
    else if (r === "left")
      b = m(this.right), _ = this.right - d, k = b - p, w = m(t.left) + p, R = t.right;
    else if (r === "right")
      b = m(this.left), w = t.left, R = m(t.right) - p, _ = b + p, k = this.left + d;
    else if (e === "x") {
      if (r === "center")
        b = m((t.top + t.bottom) / 2 + 0.5);
      else if (D(r)) {
        const P = Object.keys(r)[0], j = r[P];
        b = m(this.chart.scales[P].getPixelForValue(j));
      }
      L = t.top, A = t.bottom, M = b + p, S = M + d;
    } else if (e === "y") {
      if (r === "center")
        b = m((t.left + t.right) / 2);
      else if (D(r)) {
        const P = Object.keys(r)[0], j = r[P];
        b = m(this.chart.scales[P].getPixelForValue(j));
      }
      _ = b - p, k = _ - d, w = t.left, R = t.right;
    }
    const H = C(n.ticks.maxTicksLimit, h), q = Math.max(1, Math.ceil(h / H));
    for (x = 0; x < h; x += q) {
      const P = o.setContext(this.getContext(x)), j = P.lineWidth, W = P.color, kt = P.borderDash || [], ti = P.borderDashOffset, Rt = P.tickWidth, ke = P.tickColor, Et = P.tickBorderDash || [], jt = P.tickBorderDashOffset;
      v = La(this, x, a), v !== void 0 && (y = wt(s, v, j), l ? _ = k = w = R = y : M = S = L = A = y, u.push({
        tx1: _,
        ty1: M,
        tx2: k,
        ty2: S,
        x1: w,
        y1: L,
        x2: R,
        y2: A,
        width: j,
        color: W,
        borderDash: kt,
        borderDashOffset: ti,
        tickWidth: Rt,
        tickColor: ke,
        tickBorderDash: Et,
        tickBorderDashOffset: jt
      }));
    }
    return this._ticksLength = h, this._borderValue = b, u;
  }
  _computeLabelItems(t) {
    const e = this.axis, s = this.options, { position: n, ticks: o } = s, r = this.isHorizontal(), a = this.ticks, { align: l, crossAlign: c, padding: h, mirror: d } = o, u = Xt(s.grid), f = u + h, g = d ? -h : f, p = -nt(this.labelRotation), m = [];
    let b, x, v, y, _, M, k, S, w, L, R, A, H = "middle";
    if (n === "top")
      M = this.bottom - g, k = this._getXAxisLabelAlignment();
    else if (n === "bottom")
      M = this.top + g, k = this._getXAxisLabelAlignment();
    else if (n === "left") {
      const P = this._getYAxisLabelAlignment(u);
      k = P.textAlign, _ = P.x;
    } else if (n === "right") {
      const P = this._getYAxisLabelAlignment(u);
      k = P.textAlign, _ = P.x;
    } else if (e === "x") {
      if (n === "center")
        M = (t.top + t.bottom) / 2 + f;
      else if (D(n)) {
        const P = Object.keys(n)[0], j = n[P];
        M = this.chart.scales[P].getPixelForValue(j) + f;
      }
      k = this._getXAxisLabelAlignment();
    } else if (e === "y") {
      if (n === "center")
        _ = (t.left + t.right) / 2 - f;
      else if (D(n)) {
        const P = Object.keys(n)[0], j = n[P];
        _ = this.chart.scales[P].getPixelForValue(j);
      }
      k = this._getYAxisLabelAlignment(u).textAlign;
    }
    e === "y" && (l === "start" ? H = "top" : l === "end" && (H = "bottom"));
    const q = this._getLabelSizes();
    for (b = 0, x = a.length; b < x; ++b) {
      v = a[b], y = v.label;
      const P = o.setContext(this.getContext(b));
      S = this.getPixelForTick(b) + o.labelOffset, w = this._resolveTickFontOptions(b), L = w.lineHeight, R = z(y) ? y.length : 1;
      const j = R / 2, W = P.color, kt = P.textStrokeColor, ti = P.textStrokeWidth;
      let Rt = k;
      r ? (_ = S, k === "inner" && (b === x - 1 ? Rt = this.options.reverse ? "left" : "right" : b === 0 ? Rt = this.options.reverse ? "right" : "left" : Rt = "center"), n === "top" ? c === "near" || p !== 0 ? A = -R * L + L / 2 : c === "center" ? A = -q.highest.height / 2 - j * L + L : A = -q.highest.height + L / 2 : c === "near" || p !== 0 ? A = L / 2 : c === "center" ? A = q.highest.height / 2 - j * L : A = q.highest.height - R * L, d && (A *= -1)) : (M = S, A = (1 - R) * L / 2);
      let ke;
      if (P.showLabelBackdrop) {
        const Et = K(P.backdropPadding), jt = q.heights[b], ei = q.widths[b];
        let ii = M + A - Et.top, si = _ - Et.left;
        switch (H) {
          case "middle":
            ii -= jt / 2;
            break;
          case "bottom":
            ii -= jt;
            break;
        }
        switch (k) {
          case "center":
            si -= ei / 2;
            break;
          case "right":
            si -= ei;
            break;
        }
        ke = {
          left: si,
          top: ii,
          width: ei + Et.width,
          height: jt + Et.height,
          color: P.backdropColor
        };
      }
      m.push({
        rotation: p,
        label: y,
        font: w,
        color: W,
        strokeColor: kt,
        strokeWidth: ti,
        textOffset: A,
        textAlign: Rt,
        textBaseline: H,
        translation: [_, M],
        backdrop: ke
      });
    }
    return m;
  }
  _getXAxisLabelAlignment() {
    const { position: t, ticks: e } = this.options;
    if (-nt(this.labelRotation))
      return t === "top" ? "left" : "right";
    let n = "center";
    return e.align === "start" ? n = "left" : e.align === "end" ? n = "right" : e.align === "inner" && (n = "inner"), n;
  }
  _getYAxisLabelAlignment(t) {
    const { position: e, ticks: { crossAlign: s, mirror: n, padding: o } } = this.options, r = this._getLabelSizes(), a = t + o, l = r.widest.width;
    let c, h;
    return e === "left" ? n ? (h = this.right + o, s === "near" ? c = "left" : s === "center" ? (c = "center", h += l / 2) : (c = "right", h += l)) : (h = this.right - a, s === "near" ? c = "right" : s === "center" ? (c = "center", h -= l / 2) : (c = "left", h = this.left)) : e === "right" ? n ? (h = this.left + o, s === "near" ? c = "right" : s === "center" ? (c = "center", h -= l / 2) : (c = "left", h -= l)) : (h = this.left + a, s === "near" ? c = "left" : s === "center" ? (c = "center", h += l / 2) : (c = "right", h = this.right)) : c = "right", { textAlign: c, x: h };
  }
  _computeLabelArea() {
    if (this.options.ticks.mirror)
      return;
    const t = this.chart, e = this.options.position;
    if (e === "left" || e === "right")
      return { top: 0, left: this.left, bottom: t.height, right: this.right };
    if (e === "top" || e === "bottom")
      return { top: this.top, left: 0, bottom: this.bottom, right: t.width };
  }
  drawBackground() {
    const { ctx: t, options: { backgroundColor: e }, left: s, top: n, width: o, height: r } = this;
    e && (t.save(), t.fillStyle = e, t.fillRect(s, n, o, r), t.restore());
  }
  getLineWidthForValue(t) {
    const e = this.options.grid;
    if (!this._isVisible() || !e.display)
      return 0;
    const n = this.ticks.findIndex((o) => o.value === t);
    return n >= 0 ? e.setContext(this.getContext(n)).lineWidth : 0;
  }
  drawGrid(t) {
    const e = this.options.grid, s = this.ctx, n = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(t));
    let o, r;
    const a = (l, c, h) => {
      !h.width || !h.color || (s.save(), s.lineWidth = h.width, s.strokeStyle = h.color, s.setLineDash(h.borderDash || []), s.lineDashOffset = h.borderDashOffset, s.beginPath(), s.moveTo(l.x, l.y), s.lineTo(c.x, c.y), s.stroke(), s.restore());
    };
    if (e.display)
      for (o = 0, r = n.length; o < r; ++o) {
        const l = n[o];
        e.drawOnChartArea && a(
          { x: l.x1, y: l.y1 },
          { x: l.x2, y: l.y2 },
          l
        ), e.drawTicks && a(
          { x: l.tx1, y: l.ty1 },
          { x: l.tx2, y: l.ty2 },
          {
            color: l.tickColor,
            width: l.tickWidth,
            borderDash: l.tickBorderDash,
            borderDashOffset: l.tickBorderDashOffset
          }
        );
      }
  }
  drawBorder() {
    const { chart: t, ctx: e, options: { grid: s } } = this, n = s.setContext(this.getContext()), o = s.drawBorder ? n.borderWidth : 0;
    if (!o)
      return;
    const r = s.setContext(this.getContext(0)).lineWidth, a = this._borderValue;
    let l, c, h, d;
    this.isHorizontal() ? (l = wt(t, this.left, o) - o / 2, c = wt(t, this.right, r) + r / 2, h = d = a) : (h = wt(t, this.top, o) - o / 2, d = wt(t, this.bottom, r) + r / 2, l = c = a), e.save(), e.lineWidth = n.borderWidth, e.strokeStyle = n.borderColor, e.beginPath(), e.moveTo(l, h), e.lineTo(c, d), e.stroke(), e.restore();
  }
  drawLabels(t) {
    if (!this.options.ticks.display)
      return;
    const s = this.ctx, n = this._computeLabelArea();
    n && Xe(s, n);
    const o = this._labelItems || (this._labelItems = this._computeLabelItems(t));
    let r, a;
    for (r = 0, a = o.length; r < a; ++r) {
      const l = o[r], c = l.font, h = l.label;
      l.backdrop && (s.fillStyle = l.backdrop.color, s.fillRect(l.backdrop.left, l.backdrop.top, l.backdrop.width, l.backdrop.height));
      let d = l.textOffset;
      Tt(s, h, 0, d, c, l);
    }
    n && Ue(s);
  }
  drawTitle() {
    const { ctx: t, options: { position: e, title: s, reverse: n } } = this;
    if (!s.display)
      return;
    const o = $(s.font), r = K(s.padding), a = s.align;
    let l = o.lineHeight / 2;
    e === "bottom" || e === "center" || D(e) ? (l += r.bottom, z(s.text) && (l += o.lineHeight * (s.text.length - 1))) : l += r.top;
    const { titleX: c, titleY: h, maxWidth: d, rotation: u } = za(this, l, e, a);
    Tt(t, s.text, 0, 0, o, {
      color: s.color,
      maxWidth: d,
      rotation: u,
      textAlign: Ia(a, e, n),
      textBaseline: "middle",
      translation: [c, h]
    });
  }
  draw(t) {
    this._isVisible() && (this.drawBackground(), this.drawGrid(t), this.drawBorder(), this.drawTitle(), this.drawLabels(t));
  }
  _layers() {
    const t = this.options, e = t.ticks && t.ticks.z || 0, s = C(t.grid && t.grid.z, -1);
    return !this._isVisible() || this.draw !== Mt.prototype.draw ? [{
      z: e,
      draw: (n) => {
        this.draw(n);
      }
    }] : [{
      z: s,
      draw: (n) => {
        this.drawBackground(), this.drawGrid(n), this.drawTitle();
      }
    }, {
      z: s + 1,
      draw: () => {
        this.drawBorder();
      }
    }, {
      z: e,
      draw: (n) => {
        this.drawLabels(n);
      }
    }];
  }
  getMatchingVisibleMetas(t) {
    const e = this.chart.getSortedVisibleDatasetMetas(), s = this.axis + "AxisID", n = [];
    let o, r;
    for (o = 0, r = e.length; o < r; ++o) {
      const a = e[o];
      a[s] === this.id && (!t || a.type === t) && n.push(a);
    }
    return n;
  }
  _resolveTickFontOptions(t) {
    const e = this.options.ticks.setContext(this.getContext(t));
    return $(e.font);
  }
  _maxDigits() {
    const t = this._resolveTickFontOptions(0).lineHeight;
    return (this.isHorizontal() ? this.width : this.height) / t;
  }
}
class Ae {
  constructor(t, e, s) {
    this.type = t, this.scope = e, this.override = s, this.items = /* @__PURE__ */ Object.create(null);
  }
  isForType(t) {
    return Object.prototype.isPrototypeOf.call(this.type.prototype, t.prototype);
  }
  register(t) {
    const e = Object.getPrototypeOf(t);
    let s;
    Wa(e) && (s = this.register(e));
    const n = this.items, o = t.id, r = this.scope + "." + o;
    if (!o)
      throw new Error("class does not have id: " + t);
    return o in n || (n[o] = t, Ba(t, r, s), this.override && O.override(t.id, t.overrides)), r;
  }
  get(t) {
    return this.items[t];
  }
  unregister(t) {
    const e = this.items, s = t.id, n = this.scope;
    s in e && delete e[s], n && s in O[n] && (delete O[n][s], this.override && delete At[s]);
  }
}
function Ba(i, t, e) {
  const s = ne(/* @__PURE__ */ Object.create(null), [
    e ? O.get(e) : {},
    O.get(t),
    i.defaults
  ]);
  O.set(t, s), i.defaultRoutes && Va(t, i.defaultRoutes), i.descriptors && O.describe(t, i.descriptors);
}
function Va(i, t) {
  Object.keys(t).forEach((e) => {
    const s = e.split("."), n = s.pop(), o = [i].concat(s).join("."), r = t[e].split("."), a = r.pop(), l = r.join(".");
    O.route(o, n, l, a);
  });
}
function Wa(i) {
  return "id" in i && "defaults" in i;
}
class Na {
  constructor() {
    this.controllers = new Ae(it, "datasets", !0), this.elements = new Ae(st, "elements"), this.plugins = new Ae(Object, "plugins"), this.scales = new Ae(Mt, "scales"), this._typedRegistries = [this.controllers, this.scales, this.elements];
  }
  add(...t) {
    this._each("register", t);
  }
  remove(...t) {
    this._each("unregister", t);
  }
  addControllers(...t) {
    this._each("register", t, this.controllers);
  }
  addElements(...t) {
    this._each("register", t, this.elements);
  }
  addPlugins(...t) {
    this._each("register", t, this.plugins);
  }
  addScales(...t) {
    this._each("register", t, this.scales);
  }
  getController(t) {
    return this._get(t, this.controllers, "controller");
  }
  getElement(t) {
    return this._get(t, this.elements, "element");
  }
  getPlugin(t) {
    return this._get(t, this.plugins, "plugin");
  }
  getScale(t) {
    return this._get(t, this.scales, "scale");
  }
  removeControllers(...t) {
    this._each("unregister", t, this.controllers);
  }
  removeElements(...t) {
    this._each("unregister", t, this.elements);
  }
  removePlugins(...t) {
    this._each("unregister", t, this.plugins);
  }
  removeScales(...t) {
    this._each("unregister", t, this.scales);
  }
  _each(t, e, s) {
    [...e].forEach((n) => {
      const o = s || this._getRegistryForType(n);
      s || o.isForType(n) || o === this.plugins && n.id ? this._exec(t, o, n) : E(n, (r) => {
        const a = s || this._getRegistryForType(r);
        this._exec(t, a, r);
      });
    });
  }
  _exec(t, e, s) {
    const n = Oi(t);
    I(s["before" + n], [], s), e[t](s), I(s["after" + n], [], s);
  }
  _getRegistryForType(t) {
    for (let e = 0; e < this._typedRegistries.length; e++) {
      const s = this._typedRegistries[e];
      if (s.isForType(t))
        return s;
    }
    return this.plugins;
  }
  _get(t, e, s) {
    const n = e.get(t);
    if (n === void 0)
      throw new Error('"' + t + '" is not a registered ' + s + ".");
    return n;
  }
}
var ot = new Na();
class xe extends it {
  update(t) {
    const e = this._cachedMeta, { data: s = [] } = e, n = this.chart._animationsDisabled;
    let { start: o, count: r } = pn(e, s, n);
    if (this._drawStart = o, this._drawCount = r, mn(e) && (o = 0, r = s.length), this.options.showLine) {
      const { dataset: a, _dataset: l } = e;
      a._chart = this.chart, a._datasetIndex = this.index, a._decimated = !!l._decimated, a.points = s;
      const c = this.resolveDatasetElementOptions(t);
      c.segment = this.options.segment, this.updateElement(a, void 0, {
        animated: !n,
        options: c
      }, t);
    }
    this.updateElements(s, o, r, t);
  }
  addElements() {
    const { showLine: t } = this.options;
    !this.datasetElementType && t && (this.datasetElementType = ot.getElement("line")), super.addElements();
  }
  updateElements(t, e, s, n) {
    const o = n === "reset", { iScale: r, vScale: a, _stacked: l, _dataset: c } = this._cachedMeta, h = this.resolveDataElementOptions(e, n), d = this.getSharedOptions(h), u = this.includeOptions(n, d), f = r.axis, g = a.axis, { spanGaps: p, segment: m } = this.options, b = Bt(p) ? p : Number.POSITIVE_INFINITY, x = this.chart._animationsDisabled || o || n === "none";
    let v = e > 0 && this.getParsed(e - 1);
    for (let y = e; y < e + s; ++y) {
      const _ = t[y], M = this.getParsed(y), k = x ? _ : {}, S = T(M[g]), w = k[f] = r.getPixelForValue(M[f], y), L = k[g] = o || S ? a.getBasePixel() : a.getPixelForValue(l ? this.applyStack(a, M, l) : M[g], y);
      k.skip = isNaN(w) || isNaN(L) || S, k.stop = y > 0 && Math.abs(M[f] - v[f]) > b, m && (k.parsed = M, k.raw = c.data[y]), u && (k.options = d || this.resolveDataElementOptions(y, _.active ? "active" : n)), x || this.updateElement(_, y, k, n), v = M;
    }
    this.updateSharedOptions(d, n, h);
  }
  getMaxOverflow() {
    const t = this._cachedMeta, e = t.data || [];
    if (!this.options.showLine) {
      let a = 0;
      for (let l = e.length - 1; l >= 0; --l)
        a = Math.max(a, e[l].size(this.resolveDataElementOptions(l)) / 2);
      return a > 0 && a;
    }
    const s = t.dataset, n = s.options && s.options.borderWidth || 0;
    if (!e.length)
      return n;
    const o = e[0].size(this.resolveDataElementOptions(0)), r = e[e.length - 1].size(this.resolveDataElementOptions(e.length - 1));
    return Math.max(n, o, r) / 2;
  }
}
xe.id = "scatter";
xe.defaults = {
  datasetElementType: !1,
  dataElementType: "point",
  showLine: !1,
  fill: !1
};
xe.overrides = {
  interaction: {
    mode: "point"
  },
  plugins: {
    tooltip: {
      callbacks: {
        title() {
          return "";
        },
        label(i) {
          return "(" + i.label + ", " + i.formattedValue + ")";
        }
      }
    }
  },
  scales: {
    x: {
      type: "linear"
    },
    y: {
      type: "linear"
    }
  }
};
var Wn = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  BarController: ue,
  BubbleController: fe,
  DoughnutController: Lt,
  LineController: ge,
  PolarAreaController: pe,
  PieController: qe,
  RadarController: me,
  ScatterController: xe
});
function St() {
  throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
}
class vi {
  constructor(t) {
    this.options = t || {};
  }
  init(t) {
  }
  formats() {
    return St();
  }
  parse(t, e) {
    return St();
  }
  format(t, e) {
    return St();
  }
  add(t, e, s) {
    return St();
  }
  diff(t, e, s) {
    return St();
  }
  startOf(t, e, s) {
    return St();
  }
  endOf(t, e) {
    return St();
  }
}
vi.override = function(i) {
  Object.assign(vi.prototype, i);
};
var Nn = {
  _date: vi
};
function Ha(i, t, e, s) {
  const { controller: n, data: o, _sorted: r } = i, a = n._cachedMeta.iScale;
  if (a && t === a.axis && t !== "r" && r && o.length) {
    const l = a._reversePixels ? Lo : ft;
    if (s) {
      if (n._sharedOptions) {
        const c = o[0], h = typeof c.getRange == "function" && c.getRange(t);
        if (h) {
          const d = l(o, t, e - h), u = l(o, t, e + h);
          return { lo: d.lo, hi: u.hi };
        }
      }
    } else
      return l(o, t, e);
  }
  return { lo: 0, hi: o.length - 1 };
}
function _e(i, t, e, s, n) {
  const o = i.getSortedVisibleDatasetMetas(), r = e[t];
  for (let a = 0, l = o.length; a < l; ++a) {
    const { index: c, data: h } = o[a], { lo: d, hi: u } = Ha(o[a], t, r, n);
    for (let f = d; f <= u; ++f) {
      const g = h[f];
      g.skip || s(g, c, f);
    }
  }
}
function ja(i) {
  const t = i.indexOf("x") !== -1, e = i.indexOf("y") !== -1;
  return function(s, n) {
    const o = t ? Math.abs(s.x - n.x) : 0, r = e ? Math.abs(s.y - n.y) : 0;
    return Math.sqrt(Math.pow(o, 2) + Math.pow(r, 2));
  };
}
function di(i, t, e, s, n) {
  const o = [];
  return !n && !i.isPointInArea(t) || _e(i, e, t, function(a, l, c) {
    !n && !re(a, i.chartArea, 0) || a.inRange(t.x, t.y, s) && o.push({ element: a, datasetIndex: l, index: c });
  }, !0), o;
}
function $a(i, t, e, s) {
  let n = [];
  function o(r, a, l) {
    const { startAngle: c, endAngle: h } = r.getProps(["startAngle", "endAngle"], s), { angle: d } = hn(r, { x: t.x, y: t.y });
    oe(d, c, h) && n.push({ element: r, datasetIndex: a, index: l });
  }
  return _e(i, e, t, o), n;
}
function Ya(i, t, e, s, n, o) {
  let r = [];
  const a = ja(e);
  let l = Number.POSITIVE_INFINITY;
  function c(h, d, u) {
    const f = h.inRange(t.x, t.y, n);
    if (s && !f)
      return;
    const g = h.getCenterPoint(n);
    if (!(!!o || i.isPointInArea(g)) && !f)
      return;
    const m = a(t, g);
    m < l ? (r = [{ element: h, datasetIndex: d, index: u }], l = m) : m === l && r.push({ element: h, datasetIndex: d, index: u });
  }
  return _e(i, e, t, c), r;
}
function ui(i, t, e, s, n, o) {
  return !o && !i.isPointInArea(t) ? [] : e === "r" && !s ? $a(i, t, e, n) : Ya(i, t, e, s, n, o);
}
function Cs(i, t, e, s, n) {
  const o = [], r = e === "x" ? "inXRange" : "inYRange";
  let a = !1;
  return _e(i, e, t, (l, c, h) => {
    l[r](t[e], n) && (o.push({ element: l, datasetIndex: c, index: h }), a = a || l.inRange(t.x, t.y, n));
  }), s && !a ? [] : o;
}
var Hn = {
  evaluateInteractionItems: _e,
  modes: {
    index(i, t, e, s) {
      const n = Pt(t, i), o = e.axis || "x", r = e.includeInvisible || !1, a = e.intersect ? di(i, n, o, s, r) : ui(i, n, o, !1, s, r), l = [];
      return a.length ? (i.getSortedVisibleDatasetMetas().forEach((c) => {
        const h = a[0].index, d = c.data[h];
        d && !d.skip && l.push({ element: d, datasetIndex: c.index, index: h });
      }), l) : [];
    },
    dataset(i, t, e, s) {
      const n = Pt(t, i), o = e.axis || "xy", r = e.includeInvisible || !1;
      let a = e.intersect ? di(i, n, o, s, r) : ui(i, n, o, !1, s, r);
      if (a.length > 0) {
        const l = a[0].datasetIndex, c = i.getDatasetMeta(l).data;
        a = [];
        for (let h = 0; h < c.length; ++h)
          a.push({ element: c[h], datasetIndex: l, index: h });
      }
      return a;
    },
    point(i, t, e, s) {
      const n = Pt(t, i), o = e.axis || "xy", r = e.includeInvisible || !1;
      return di(i, n, o, s, r);
    },
    nearest(i, t, e, s) {
      const n = Pt(t, i), o = e.axis || "xy", r = e.includeInvisible || !1;
      return ui(i, n, o, e.intersect, s, r);
    },
    x(i, t, e, s) {
      const n = Pt(t, i);
      return Cs(i, n, "x", e.intersect, s);
    },
    y(i, t, e, s) {
      const n = Pt(t, i);
      return Cs(i, n, "y", e.intersect, s);
    }
  }
};
const jn = ["left", "top", "right", "bottom"];
function Ut(i, t) {
  return i.filter((e) => e.pos === t);
}
function Ds(i, t) {
  return i.filter((e) => jn.indexOf(e.pos) === -1 && e.box.axis === t);
}
function Kt(i, t) {
  return i.sort((e, s) => {
    const n = t ? s : e, o = t ? e : s;
    return n.weight === o.weight ? n.index - o.index : n.weight - o.weight;
  });
}
function Xa(i) {
  const t = [];
  let e, s, n, o, r, a;
  for (e = 0, s = (i || []).length; e < s; ++e)
    n = i[e], { position: o, options: { stack: r, stackWeight: a = 1 } } = n, t.push({
      index: e,
      box: n,
      pos: o,
      horizontal: n.isHorizontal(),
      weight: n.weight,
      stack: r && o + r,
      stackWeight: a
    });
  return t;
}
function Ua(i) {
  const t = {};
  for (const e of i) {
    const { stack: s, pos: n, stackWeight: o } = e;
    if (!s || !jn.includes(n))
      continue;
    const r = t[s] || (t[s] = { count: 0, placed: 0, weight: 0, size: 0 });
    r.count++, r.weight += o;
  }
  return t;
}
function Ka(i, t) {
  const e = Ua(i), { vBoxMaxWidth: s, hBoxMaxHeight: n } = t;
  let o, r, a;
  for (o = 0, r = i.length; o < r; ++o) {
    a = i[o];
    const { fullSize: l } = a.box, c = e[a.stack], h = c && a.stackWeight / c.weight;
    a.horizontal ? (a.width = h ? h * s : l && t.availableWidth, a.height = n) : (a.width = s, a.height = h ? h * n : l && t.availableHeight);
  }
  return e;
}
function qa(i) {
  const t = Xa(i), e = Kt(t.filter((c) => c.box.fullSize), !0), s = Kt(Ut(t, "left"), !0), n = Kt(Ut(t, "right")), o = Kt(Ut(t, "top"), !0), r = Kt(Ut(t, "bottom")), a = Ds(t, "x"), l = Ds(t, "y");
  return {
    fullSize: e,
    leftAndTop: s.concat(o),
    rightAndBottom: n.concat(l).concat(r).concat(a),
    chartArea: Ut(t, "chartArea"),
    vertical: s.concat(n).concat(l),
    horizontal: o.concat(r).concat(a)
  };
}
function Os(i, t, e, s) {
  return Math.max(i[e], t[e]) + Math.max(i[s], t[s]);
}
function $n(i, t) {
  i.top = Math.max(i.top, t.top), i.left = Math.max(i.left, t.left), i.bottom = Math.max(i.bottom, t.bottom), i.right = Math.max(i.right, t.right);
}
function Ga(i, t, e, s) {
  const { pos: n, box: o } = e, r = i.maxPadding;
  if (!D(n)) {
    e.size && (i[n] -= e.size);
    const d = s[e.stack] || { size: 0, count: 1 };
    d.size = Math.max(d.size, e.horizontal ? o.height : o.width), e.size = d.size / d.count, i[n] += e.size;
  }
  o.getPadding && $n(r, o.getPadding());
  const a = Math.max(0, t.outerWidth - Os(r, i, "left", "right")), l = Math.max(0, t.outerHeight - Os(r, i, "top", "bottom")), c = a !== i.w, h = l !== i.h;
  return i.w = a, i.h = l, e.horizontal ? { same: c, other: h } : { same: h, other: c };
}
function Za(i) {
  const t = i.maxPadding;
  function e(s) {
    const n = Math.max(t[s] - i[s], 0);
    return i[s] += n, n;
  }
  i.y += e("top"), i.x += e("left"), e("right"), e("bottom");
}
function Ja(i, t) {
  const e = t.maxPadding;
  function s(n) {
    const o = { left: 0, top: 0, right: 0, bottom: 0 };
    return n.forEach((r) => {
      o[r] = Math.max(t[r], e[r]);
    }), o;
  }
  return s(i ? ["left", "right"] : ["top", "bottom"]);
}
function Jt(i, t, e, s) {
  const n = [];
  let o, r, a, l, c, h;
  for (o = 0, r = i.length, c = 0; o < r; ++o) {
    a = i[o], l = a.box, l.update(
      a.width || t.w,
      a.height || t.h,
      Ja(a.horizontal, t)
    );
    const { same: d, other: u } = Ga(t, e, a, s);
    c |= d && n.length, h = h || u, l.fullSize || n.push(a);
  }
  return c && Jt(n, t, e, s) || h;
}
function Te(i, t, e, s, n) {
  i.top = e, i.left = t, i.right = t + s, i.bottom = e + n, i.width = s, i.height = n;
}
function As(i, t, e, s) {
  const n = e.padding;
  let { x: o, y: r } = t;
  for (const a of i) {
    const l = a.box, c = s[a.stack] || { count: 1, placed: 0, weight: 1 }, h = a.stackWeight / c.weight || 1;
    if (a.horizontal) {
      const d = t.w * h, u = c.size || l.height;
      et(c.start) && (r = c.start), l.fullSize ? Te(l, n.left, r, e.outerWidth - n.right - n.left, u) : Te(l, t.left + c.placed, r, d, u), c.start = r, c.placed += d, r = l.bottom;
    } else {
      const d = t.h * h, u = c.size || l.width;
      et(c.start) && (o = c.start), l.fullSize ? Te(l, o, n.top, u, e.outerHeight - n.bottom - n.top) : Te(l, o, t.top + c.placed, u, d), c.start = o, c.placed += d, o = l.right;
    }
  }
  t.x = o, t.y = r;
}
O.set("layout", {
  autoPadding: !0,
  padding: {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  }
});
var X = {
  addBox(i, t) {
    i.boxes || (i.boxes = []), t.fullSize = t.fullSize || !1, t.position = t.position || "top", t.weight = t.weight || 0, t._layers = t._layers || function() {
      return [{
        z: 0,
        draw(e) {
          t.draw(e);
        }
      }];
    }, i.boxes.push(t);
  },
  removeBox(i, t) {
    const e = i.boxes ? i.boxes.indexOf(t) : -1;
    e !== -1 && i.boxes.splice(e, 1);
  },
  configure(i, t, e) {
    t.fullSize = e.fullSize, t.position = e.position, t.weight = e.weight;
  },
  update(i, t, e, s) {
    if (!i)
      return;
    const n = K(i.options.layout.padding), o = Math.max(t - n.width, 0), r = Math.max(e - n.height, 0), a = qa(i.boxes), l = a.vertical, c = a.horizontal;
    E(i.boxes, (p) => {
      typeof p.beforeLayout == "function" && p.beforeLayout();
    });
    const h = l.reduce((p, m) => m.box.options && m.box.options.display === !1 ? p : p + 1, 0) || 1, d = Object.freeze({
      outerWidth: t,
      outerHeight: e,
      padding: n,
      availableWidth: o,
      availableHeight: r,
      vBoxMaxWidth: o / 2 / h,
      hBoxMaxHeight: r / 2
    }), u = Object.assign({}, n);
    $n(u, K(s));
    const f = Object.assign({
      maxPadding: u,
      w: o,
      h: r,
      x: n.left,
      y: n.top
    }, n), g = Ka(l.concat(c), d);
    Jt(a.fullSize, f, d, g), Jt(l, f, d, g), Jt(c, f, d, g) && Jt(l, f, d, g), Za(f), As(a.leftAndTop, f, d, g), f.x += f.w, f.y += f.h, As(a.rightAndBottom, f, d, g), i.chartArea = {
      left: f.left,
      top: f.top,
      right: f.left + f.w,
      bottom: f.top + f.h,
      height: f.h,
      width: f.w
    }, E(a.chartArea, (p) => {
      const m = p.box;
      Object.assign(m, i.chartArea), m.update(f.w, f.h, { left: 0, top: 0, right: 0, bottom: 0 });
    });
  }
};
class Hi {
  acquireContext(t, e) {
  }
  releaseContext(t) {
    return !1;
  }
  addEventListener(t, e, s) {
  }
  removeEventListener(t, e, s) {
  }
  getDevicePixelRatio() {
    return 1;
  }
  getMaximumSize(t, e, s, n) {
    return e = Math.max(0, e || t.width), s = s || t.height, {
      width: e,
      height: Math.max(0, n ? Math.floor(e / n) : s)
    };
  }
  isAttached(t) {
    return !0;
  }
  updateConfig(t) {
  }
}
class Yn extends Hi {
  acquireContext(t) {
    return t && t.getContext && t.getContext("2d") || null;
  }
  updateConfig(t) {
    t.options.animation = !1;
  }
}
const Ie = "$chartjs", Qa = {
  touchstart: "mousedown",
  touchmove: "mousemove",
  touchend: "mouseup",
  pointerenter: "mouseenter",
  pointerdown: "mousedown",
  pointermove: "mousemove",
  pointerup: "mouseup",
  pointerleave: "mouseout",
  pointerout: "mouseout"
}, Ts = (i) => i === null || i === "";
function tl(i, t) {
  const e = i.style, s = i.getAttribute("height"), n = i.getAttribute("width");
  if (i[Ie] = {
    initial: {
      height: s,
      width: n,
      style: {
        display: e.display,
        height: e.height,
        width: e.width
      }
    }
  }, e.display = e.display || "block", e.boxSizing = e.boxSizing || "border-box", Ts(n)) {
    const o = cs(i, "width");
    o !== void 0 && (i.width = o);
  }
  if (Ts(s))
    if (i.style.height === "")
      i.height = i.width / (t || 2);
    else {
      const o = cs(i, "height");
      o !== void 0 && (i.height = o);
    }
  return i;
}
const Xn = Vr ? { passive: !0 } : !1;
function el(i, t, e) {
  i.addEventListener(t, e, Xn);
}
function il(i, t, e) {
  i.canvas.removeEventListener(t, e, Xn);
}
function sl(i, t) {
  const e = Qa[i.type] || i.type, { x: s, y: n } = Pt(i, t);
  return {
    type: e,
    chart: t,
    native: i,
    x: s !== void 0 ? s : null,
    y: n !== void 0 ? n : null
  };
}
function je(i, t) {
  for (const e of i)
    if (e === t || e.contains(t))
      return !0;
}
function nl(i, t, e) {
  const s = i.canvas, n = new MutationObserver((o) => {
    let r = !1;
    for (const a of o)
      r = r || je(a.addedNodes, s), r = r && !je(a.removedNodes, s);
    r && e();
  });
  return n.observe(document, { childList: !0, subtree: !0 }), n;
}
function ol(i, t, e) {
  const s = i.canvas, n = new MutationObserver((o) => {
    let r = !1;
    for (const a of o)
      r = r || je(a.removedNodes, s), r = r && !je(a.addedNodes, s);
    r && e();
  });
  return n.observe(document, { childList: !0, subtree: !0 }), n;
}
const le = /* @__PURE__ */ new Map();
let Ls = 0;
function Un() {
  const i = window.devicePixelRatio;
  i !== Ls && (Ls = i, le.forEach((t, e) => {
    e.currentDevicePixelRatio !== i && t();
  }));
}
function rl(i, t) {
  le.size || window.addEventListener("resize", Un), le.set(i, t);
}
function al(i) {
  le.delete(i), le.size || window.removeEventListener("resize", Un);
}
function ll(i, t, e) {
  const s = i.canvas, n = s && Wi(s);
  if (!n)
    return;
  const o = gn((a, l) => {
    const c = n.clientWidth;
    e(a, l), c < n.clientWidth && e();
  }, window), r = new ResizeObserver((a) => {
    const l = a[0], c = l.contentRect.width, h = l.contentRect.height;
    c === 0 && h === 0 || o(c, h);
  });
  return r.observe(n), rl(i, o), r;
}
function fi(i, t, e) {
  e && e.disconnect(), t === "resize" && al(i);
}
function cl(i, t, e) {
  const s = i.canvas, n = gn((o) => {
    i.ctx !== null && e(sl(o, i));
  }, i, (o) => {
    const r = o[0];
    return [r, r.offsetX, r.offsetY];
  });
  return el(s, t, n), n;
}
class Kn extends Hi {
  acquireContext(t, e) {
    const s = t && t.getContext && t.getContext("2d");
    return s && s.canvas === t ? (tl(t, e), s) : null;
  }
  releaseContext(t) {
    const e = t.canvas;
    if (!e[Ie])
      return !1;
    const s = e[Ie].initial;
    ["height", "width"].forEach((o) => {
      const r = s[o];
      T(r) ? e.removeAttribute(o) : e.setAttribute(o, r);
    });
    const n = s.style || {};
    return Object.keys(n).forEach((o) => {
      e.style[o] = n[o];
    }), e.width = e.width, delete e[Ie], !0;
  }
  addEventListener(t, e, s) {
    this.removeEventListener(t, e);
    const n = t.$proxies || (t.$proxies = {}), r = {
      attach: nl,
      detach: ol,
      resize: ll
    }[e] || cl;
    n[e] = r(t, e, s);
  }
  removeEventListener(t, e) {
    const s = t.$proxies || (t.$proxies = {}), n = s[e];
    if (!n)
      return;
    ({
      attach: fi,
      detach: fi,
      resize: fi
    }[e] || il)(t, e, n), s[e] = void 0;
  }
  getDevicePixelRatio() {
    return window.devicePixelRatio;
  }
  getMaximumSize(t, e, s, n) {
    return Br(t, e, s, n);
  }
  isAttached(t) {
    const e = Wi(t);
    return !!(e && e.isConnected);
  }
}
function qn(i) {
  return !An() || typeof OffscreenCanvas < "u" && i instanceof OffscreenCanvas ? Yn : Kn;
}
class hl {
  constructor() {
    this._init = [];
  }
  notify(t, e, s, n) {
    e === "beforeInit" && (this._init = this._createDescriptors(t, !0), this._notify(this._init, t, "install"));
    const o = n ? this._descriptors(t).filter(n) : this._descriptors(t), r = this._notify(o, t, e, s);
    return e === "afterDestroy" && (this._notify(o, t, "stop"), this._notify(this._init, t, "uninstall")), r;
  }
  _notify(t, e, s, n) {
    n = n || {};
    for (const o of t) {
      const r = o.plugin, a = r[s], l = [e, n, o.options];
      if (I(a, l, r) === !1 && n.cancelable)
        return !1;
    }
    return !0;
  }
  invalidate() {
    T(this._cache) || (this._oldCache = this._cache, this._cache = void 0);
  }
  _descriptors(t) {
    if (this._cache)
      return this._cache;
    const e = this._cache = this._createDescriptors(t);
    return this._notifyStateChanges(t), e;
  }
  _createDescriptors(t, e) {
    const s = t && t.config, n = C(s.options && s.options.plugins, {}), o = dl(s);
    return n === !1 && !e ? [] : fl(t, o, n, e);
  }
  _notifyStateChanges(t) {
    const e = this._oldCache || [], s = this._cache, n = (o, r) => o.filter((a) => !r.some((l) => a.plugin.id === l.plugin.id));
    this._notify(n(e, s), t, "stop"), this._notify(n(s, e), t, "start");
  }
}
function dl(i) {
  const t = {}, e = [], s = Object.keys(ot.plugins.items);
  for (let o = 0; o < s.length; o++)
    e.push(ot.getPlugin(s[o]));
  const n = i.plugins || [];
  for (let o = 0; o < n.length; o++) {
    const r = n[o];
    e.indexOf(r) === -1 && (e.push(r), t[r.id] = !0);
  }
  return { plugins: e, localIds: t };
}
function ul(i, t) {
  return !t && i === !1 ? null : i === !0 ? {} : i;
}
function fl(i, { plugins: t, localIds: e }, s, n) {
  const o = [], r = i.getContext();
  for (const a of t) {
    const l = a.id, c = ul(s[l], n);
    c !== null && o.push({
      plugin: a,
      options: gl(i.config, { plugin: a, local: e[l] }, c, r)
    });
  }
  return o;
}
function gl(i, { plugin: t, local: e }, s, n) {
  const o = i.pluginScopeKeys(t), r = i.getOptionScopes(s, o);
  return e && t.defaults && r.push(t.defaults), i.createResolver(r, n, [""], {
    scriptable: !1,
    indexable: !1,
    allKeys: !0
  });
}
function Mi(i, t) {
  const e = O.datasets[i] || {};
  return ((t.datasets || {})[i] || {}).indexAxis || t.indexAxis || e.indexAxis || "x";
}
function pl(i, t) {
  let e = i;
  return i === "_index_" ? e = t : i === "_value_" && (e = t === "x" ? "y" : "x"), e;
}
function ml(i, t) {
  return i === t ? "_index_" : "_value_";
}
function bl(i) {
  if (i === "top" || i === "bottom")
    return "x";
  if (i === "left" || i === "right")
    return "y";
}
function ki(i, t) {
  return i === "x" || i === "y" ? i : t.axis || bl(t.position) || i.charAt(0).toLowerCase();
}
function xl(i, t) {
  const e = At[i.type] || { scales: {} }, s = t.scales || {}, n = Mi(i.type, t), o = /* @__PURE__ */ Object.create(null), r = /* @__PURE__ */ Object.create(null);
  return Object.keys(s).forEach((a) => {
    const l = s[a];
    if (!D(l))
      return console.error(`Invalid scale configuration for scale: ${a}`);
    if (l._proxy)
      return console.warn(`Ignoring resolver passed as options for scale: ${a}`);
    const c = ki(a, l), h = ml(c, n), d = e.scales || {};
    o[c] = o[c] || a, r[a] = Qt(/* @__PURE__ */ Object.create(null), [{ axis: c }, l, d[c], d[h]]);
  }), i.data.datasets.forEach((a) => {
    const l = a.type || i.type, c = a.indexAxis || Mi(l, t), d = (At[l] || {}).scales || {};
    Object.keys(d).forEach((u) => {
      const f = pl(u, c), g = a[f + "AxisID"] || o[f] || f;
      r[g] = r[g] || /* @__PURE__ */ Object.create(null), Qt(r[g], [{ axis: f }, s[g], d[u]]);
    });
  }), Object.keys(r).forEach((a) => {
    const l = r[a];
    Qt(l, [O.scales[l.type], O.scale]);
  }), r;
}
function Gn(i) {
  const t = i.options || (i.options = {});
  t.plugins = C(t.plugins, {}), t.scales = xl(i, t);
}
function Zn(i) {
  return i = i || {}, i.datasets = i.datasets || [], i.labels = i.labels || [], i;
}
function _l(i) {
  return i = i || {}, i.data = Zn(i.data), Gn(i), i;
}
const Rs = /* @__PURE__ */ new Map(), Jn = /* @__PURE__ */ new Set();
function Le(i, t) {
  let e = Rs.get(i);
  return e || (e = t(), Rs.set(i, e), Jn.add(e)), e;
}
const qt = (i, t, e) => {
  const s = _t(t, e);
  s !== void 0 && i.add(s);
};
class yl {
  constructor(t) {
    this._config = _l(t), this._scopeCache = /* @__PURE__ */ new Map(), this._resolverCache = /* @__PURE__ */ new Map();
  }
  get platform() {
    return this._config.platform;
  }
  get type() {
    return this._config.type;
  }
  set type(t) {
    this._config.type = t;
  }
  get data() {
    return this._config.data;
  }
  set data(t) {
    this._config.data = Zn(t);
  }
  get options() {
    return this._config.options;
  }
  set options(t) {
    this._config.options = t;
  }
  get plugins() {
    return this._config.plugins;
  }
  update() {
    const t = this._config;
    this.clearCache(), Gn(t);
  }
  clearCache() {
    this._scopeCache.clear(), this._resolverCache.clear();
  }
  datasetScopeKeys(t) {
    return Le(
      t,
      () => [[
        `datasets.${t}`,
        ""
      ]]
    );
  }
  datasetAnimationScopeKeys(t, e) {
    return Le(
      `${t}.transition.${e}`,
      () => [
        [
          `datasets.${t}.transitions.${e}`,
          `transitions.${e}`
        ],
        [
          `datasets.${t}`,
          ""
        ]
      ]
    );
  }
  datasetElementScopeKeys(t, e) {
    return Le(
      `${t}-${e}`,
      () => [[
        `datasets.${t}.elements.${e}`,
        `datasets.${t}`,
        `elements.${e}`,
        ""
      ]]
    );
  }
  pluginScopeKeys(t) {
    const e = t.id, s = this.type;
    return Le(
      `${s}-plugin-${e}`,
      () => [[
        `plugins.${e}`,
        ...t.additionalOptionScopes || []
      ]]
    );
  }
  _cachedScopes(t, e) {
    const s = this._scopeCache;
    let n = s.get(t);
    return (!n || e) && (n = /* @__PURE__ */ new Map(), s.set(t, n)), n;
  }
  getOptionScopes(t, e, s) {
    const { options: n, type: o } = this, r = this._cachedScopes(t, s), a = r.get(e);
    if (a)
      return a;
    const l = /* @__PURE__ */ new Set();
    e.forEach((h) => {
      t && (l.add(t), h.forEach((d) => qt(l, t, d))), h.forEach((d) => qt(l, n, d)), h.forEach((d) => qt(l, At[o] || {}, d)), h.forEach((d) => qt(l, O, d)), h.forEach((d) => qt(l, _i, d));
    });
    const c = Array.from(l);
    return c.length === 0 && c.push(/* @__PURE__ */ Object.create(null)), Jn.has(e) && r.set(e, c), c;
  }
  chartOptionScopes() {
    const { options: t, type: e } = this;
    return [
      t,
      At[e] || {},
      O.datasets[e] || {},
      { type: e },
      O,
      _i
    ];
  }
  resolveNamedOptions(t, e, s, n = [""]) {
    const o = { $shared: !0 }, { resolver: r, subPrefixes: a } = Es(this._resolverCache, t, n);
    let l = r;
    if (Ml(r, e)) {
      o.$shared = !1, s = yt(s) ? s() : s;
      const c = this.createResolver(t, s, a);
      l = Vt(r, s, c);
    }
    for (const c of e)
      o[c] = l[c];
    return o;
  }
  createResolver(t, e, s = [""], n) {
    const { resolver: o } = Es(this._resolverCache, t, s);
    return D(e) ? Vt(o, e, void 0, n) : o;
  }
}
function Es(i, t, e) {
  let s = i.get(t);
  s || (s = /* @__PURE__ */ new Map(), i.set(t, s));
  const n = e.join();
  let o = s.get(n);
  return o || (o = {
    resolver: zi(t, e),
    subPrefixes: e.filter((a) => !a.toLowerCase().includes("hover"))
  }, s.set(n, o)), o;
}
const vl = (i) => D(i) && Object.getOwnPropertyNames(i).reduce((t, e) => t || yt(i[e]), !1);
function Ml(i, t) {
  const { isScriptable: e, isIndexable: s } = wn(i);
  for (const n of t) {
    const o = e(n), r = s(n), a = (r || o) && i[n];
    if (o && (yt(a) || vl(a)) || r && z(a))
      return !0;
  }
  return !1;
}
var kl = "3.9.1";
const wl = ["top", "bottom", "left", "right", "chartArea"];
function Fs(i, t) {
  return i === "top" || i === "bottom" || wl.indexOf(i) === -1 && t === "x";
}
function Is(i, t) {
  return function(e, s) {
    return e[i] === s[i] ? e[t] - s[t] : e[i] - s[i];
  };
}
function zs(i) {
  const t = i.chart, e = t.options.animation;
  t.notifyPlugins("afterRender"), I(e && e.onComplete, [i], t);
}
function Sl(i) {
  const t = i.chart, e = t.options.animation;
  I(e && e.onProgress, [i], t);
}
function Qn(i) {
  return An() && typeof i == "string" ? i = document.getElementById(i) : i && i.length && (i = i[0]), i && i.canvas && (i = i.canvas), i;
}
const $e = {}, to = (i) => {
  const t = Qn(i);
  return Object.values($e).filter((e) => e.canvas === t).pop();
};
function Pl(i, t, e) {
  const s = Object.keys(i);
  for (const n of s) {
    const o = +n;
    if (o >= t) {
      const r = i[n];
      delete i[n], (e > 0 || o > t) && (i[o + e] = r);
    }
  }
}
function Cl(i, t, e, s) {
  return !e || i.type === "mouseout" ? null : s ? t : i;
}
class ji {
  constructor(t, e) {
    const s = this.config = new yl(e), n = Qn(t), o = to(n);
    if (o)
      throw new Error(
        "Canvas is already in use. Chart with ID '" + o.id + "' must be destroyed before the canvas with ID '" + o.canvas.id + "' can be reused."
      );
    const r = s.createResolver(s.chartOptionScopes(), this.getContext());
    this.platform = new (s.platform || qn(n))(), this.platform.updateConfig(s);
    const a = this.platform.acquireContext(n, r.aspectRatio), l = a && a.canvas, c = l && l.height, h = l && l.width;
    if (this.id = _o(), this.ctx = a, this.canvas = l, this.width = h, this.height = c, this._options = r, this._aspectRatio = this.aspectRatio, this._layers = [], this._metasets = [], this._stacks = void 0, this.boxes = [], this.currentDevicePixelRatio = void 0, this.chartArea = void 0, this._active = [], this._lastEvent = void 0, this._listeners = {}, this._responsiveListeners = void 0, this._sortedMetasets = [], this.scales = {}, this._plugins = new hl(), this.$proxies = {}, this._hiddenIndices = {}, this.attached = !1, this._animationsDisabled = void 0, this.$context = void 0, this._doResize = Fo((d) => this.update(d), r.resizeDelay || 0), this._dataChanges = [], $e[this.id] = this, !a || !l) {
      console.error("Failed to create chart: can't acquire context from the given item");
      return;
    }
    at.listen(this, "complete", zs), at.listen(this, "progress", Sl), this._initialize(), this.attached && this.update();
  }
  get aspectRatio() {
    const { options: { aspectRatio: t, maintainAspectRatio: e }, width: s, height: n, _aspectRatio: o } = this;
    return T(t) ? e && o ? o : n ? s / n : null : t;
  }
  get data() {
    return this.config.data;
  }
  set data(t) {
    this.config.data = t;
  }
  get options() {
    return this._options;
  }
  set options(t) {
    this.config.options = t;
  }
  _initialize() {
    return this.notifyPlugins("beforeInit"), this.options.responsive ? this.resize() : ls(this, this.options.devicePixelRatio), this.bindEvents(), this.notifyPlugins("afterInit"), this;
  }
  clear() {
    return os(this.canvas, this.ctx), this;
  }
  stop() {
    return at.stop(this), this;
  }
  resize(t, e) {
    at.running(this) ? this._resizeBeforeDraw = { width: t, height: e } : this._resize(t, e);
  }
  _resize(t, e) {
    const s = this.options, n = this.canvas, o = s.maintainAspectRatio && this.aspectRatio, r = this.platform.getMaximumSize(n, t, e, o), a = s.devicePixelRatio || this.platform.getDevicePixelRatio(), l = this.width ? "resize" : "attach";
    this.width = r.width, this.height = r.height, this._aspectRatio = this.aspectRatio, ls(this, a, !0) && (this.notifyPlugins("resize", { size: r }), I(s.onResize, [this, r], this), this.attached && this._doResize(l) && this.render());
  }
  ensureScalesHaveIDs() {
    const e = this.options.scales || {};
    E(e, (s, n) => {
      s.id = n;
    });
  }
  buildOrUpdateScales() {
    const t = this.options, e = t.scales, s = this.scales, n = Object.keys(s).reduce((r, a) => (r[a] = !1, r), {});
    let o = [];
    e && (o = o.concat(
      Object.keys(e).map((r) => {
        const a = e[r], l = ki(r, a), c = l === "r", h = l === "x";
        return {
          options: a,
          dposition: c ? "chartArea" : h ? "bottom" : "left",
          dtype: c ? "radialLinear" : h ? "category" : "linear"
        };
      })
    )), E(o, (r) => {
      const a = r.options, l = a.id, c = ki(l, a), h = C(a.type, r.dtype);
      (a.position === void 0 || Fs(a.position, c) !== Fs(r.dposition)) && (a.position = r.dposition), n[l] = !0;
      let d = null;
      if (l in s && s[l].type === h)
        d = s[l];
      else {
        const u = ot.getScale(h);
        d = new u({
          id: l,
          type: h,
          ctx: this.ctx,
          chart: this
        }), s[d.id] = d;
      }
      d.init(a, t);
    }), E(n, (r, a) => {
      r || delete s[a];
    }), E(s, (r) => {
      X.configure(this, r, r.options), X.addBox(this, r);
    });
  }
  _updateMetasets() {
    const t = this._metasets, e = this.data.datasets.length, s = t.length;
    if (t.sort((n, o) => n.index - o.index), s > e) {
      for (let n = e; n < s; ++n)
        this._destroyDatasetMeta(n);
      t.splice(e, s - e);
    }
    this._sortedMetasets = t.slice(0).sort(Is("order", "index"));
  }
  _removeUnreferencedMetasets() {
    const { _metasets: t, data: { datasets: e } } = this;
    t.length > e.length && delete this._stacks, t.forEach((s, n) => {
      e.filter((o) => o === s._dataset).length === 0 && this._destroyDatasetMeta(n);
    });
  }
  buildOrUpdateControllers() {
    const t = [], e = this.data.datasets;
    let s, n;
    for (this._removeUnreferencedMetasets(), s = 0, n = e.length; s < n; s++) {
      const o = e[s];
      let r = this.getDatasetMeta(s);
      const a = o.type || this.config.type;
      if (r.type && r.type !== a && (this._destroyDatasetMeta(s), r = this.getDatasetMeta(s)), r.type = a, r.indexAxis = o.indexAxis || Mi(a, this.options), r.order = o.order || 0, r.index = s, r.label = "" + o.label, r.visible = this.isDatasetVisible(s), r.controller)
        r.controller.updateIndex(s), r.controller.linkScales();
      else {
        const l = ot.getController(a), { datasetElementType: c, dataElementType: h } = O.datasets[a];
        Object.assign(l.prototype, {
          dataElementType: ot.getElement(h),
          datasetElementType: c && ot.getElement(c)
        }), r.controller = new l(this, s), t.push(r.controller);
      }
    }
    return this._updateMetasets(), t;
  }
  _resetElements() {
    E(this.data.datasets, (t, e) => {
      this.getDatasetMeta(e).controller.reset();
    }, this);
  }
  reset() {
    this._resetElements(), this.notifyPlugins("reset");
  }
  update(t) {
    const e = this.config;
    e.update();
    const s = this._options = e.createResolver(e.chartOptionScopes(), this.getContext()), n = this._animationsDisabled = !s.animation;
    if (this._updateScales(), this._checkEventBindings(), this._updateHiddenIndices(), this._plugins.invalidate(), this.notifyPlugins("beforeUpdate", { mode: t, cancelable: !0 }) === !1)
      return;
    const o = this.buildOrUpdateControllers();
    this.notifyPlugins("beforeElementsUpdate");
    let r = 0;
    for (let c = 0, h = this.data.datasets.length; c < h; c++) {
      const { controller: d } = this.getDatasetMeta(c), u = !n && o.indexOf(d) === -1;
      d.buildOrUpdateElements(u), r = Math.max(+d.getMaxOverflow(), r);
    }
    r = this._minPadding = s.layout.autoPadding ? r : 0, this._updateLayout(r), n || E(o, (c) => {
      c.reset();
    }), this._updateDatasets(t), this.notifyPlugins("afterUpdate", { mode: t }), this._layers.sort(Is("z", "_idx"));
    const { _active: a, _lastEvent: l } = this;
    l ? this._eventHandler(l, !0) : a.length && this._updateHoverStyles(a, a, !0), this.render();
  }
  _updateScales() {
    E(this.scales, (t) => {
      X.removeBox(this, t);
    }), this.ensureScalesHaveIDs(), this.buildOrUpdateScales();
  }
  _checkEventBindings() {
    const t = this.options, e = new Set(Object.keys(this._listeners)), s = new Set(t.events);
    (!Ui(e, s) || !!this._responsiveListeners !== t.responsive) && (this.unbindEvents(), this.bindEvents());
  }
  _updateHiddenIndices() {
    const { _hiddenIndices: t } = this, e = this._getUniformDataChanges() || [];
    for (const { method: s, start: n, count: o } of e) {
      const r = s === "_removeElements" ? -o : o;
      Pl(t, n, r);
    }
  }
  _getUniformDataChanges() {
    const t = this._dataChanges;
    if (!t || !t.length)
      return;
    this._dataChanges = [];
    const e = this.data.datasets.length, s = (o) => new Set(
      t.filter((r) => r[0] === o).map((r, a) => a + "," + r.splice(1).join(","))
    ), n = s(0);
    for (let o = 1; o < e; o++)
      if (!Ui(n, s(o)))
        return;
    return Array.from(n).map((o) => o.split(",")).map((o) => ({ method: o[1], start: +o[2], count: +o[3] }));
  }
  _updateLayout(t) {
    if (this.notifyPlugins("beforeLayout", { cancelable: !0 }) === !1)
      return;
    X.update(this, this.width, this.height, t);
    const e = this.chartArea, s = e.width <= 0 || e.height <= 0;
    this._layers = [], E(this.boxes, (n) => {
      s && n.position === "chartArea" || (n.configure && n.configure(), this._layers.push(...n._layers()));
    }, this), this._layers.forEach((n, o) => {
      n._idx = o;
    }), this.notifyPlugins("afterLayout");
  }
  _updateDatasets(t) {
    if (this.notifyPlugins("beforeDatasetsUpdate", { mode: t, cancelable: !0 }) !== !1) {
      for (let e = 0, s = this.data.datasets.length; e < s; ++e)
        this.getDatasetMeta(e).controller.configure();
      for (let e = 0, s = this.data.datasets.length; e < s; ++e)
        this._updateDataset(e, yt(t) ? t({ datasetIndex: e }) : t);
      this.notifyPlugins("afterDatasetsUpdate", { mode: t });
    }
  }
  _updateDataset(t, e) {
    const s = this.getDatasetMeta(t), n = { meta: s, index: t, mode: e, cancelable: !0 };
    this.notifyPlugins("beforeDatasetUpdate", n) !== !1 && (s.controller._update(e), n.cancelable = !1, this.notifyPlugins("afterDatasetUpdate", n));
  }
  render() {
    this.notifyPlugins("beforeRender", { cancelable: !0 }) !== !1 && (at.has(this) ? this.attached && !at.running(this) && at.start(this) : (this.draw(), zs({ chart: this })));
  }
  draw() {
    let t;
    if (this._resizeBeforeDraw) {
      const { width: s, height: n } = this._resizeBeforeDraw;
      this._resize(s, n), this._resizeBeforeDraw = null;
    }
    if (this.clear(), this.width <= 0 || this.height <= 0 || this.notifyPlugins("beforeDraw", { cancelable: !0 }) === !1)
      return;
    const e = this._layers;
    for (t = 0; t < e.length && e[t].z <= 0; ++t)
      e[t].draw(this.chartArea);
    for (this._drawDatasets(); t < e.length; ++t)
      e[t].draw(this.chartArea);
    this.notifyPlugins("afterDraw");
  }
  _getSortedDatasetMetas(t) {
    const e = this._sortedMetasets, s = [];
    let n, o;
    for (n = 0, o = e.length; n < o; ++n) {
      const r = e[n];
      (!t || r.visible) && s.push(r);
    }
    return s;
  }
  getSortedVisibleDatasetMetas() {
    return this._getSortedDatasetMetas(!0);
  }
  _drawDatasets() {
    if (this.notifyPlugins("beforeDatasetsDraw", { cancelable: !0 }) === !1)
      return;
    const t = this.getSortedVisibleDatasetMetas();
    for (let e = t.length - 1; e >= 0; --e)
      this._drawDataset(t[e]);
    this.notifyPlugins("afterDatasetsDraw");
  }
  _drawDataset(t) {
    const e = this.ctx, s = t._clip, n = !s.disabled, o = this.chartArea, r = {
      meta: t,
      index: t.index,
      cancelable: !0
    };
    this.notifyPlugins("beforeDatasetDraw", r) !== !1 && (n && Xe(e, {
      left: s.left === !1 ? 0 : o.left - s.left,
      right: s.right === !1 ? this.width : o.right + s.right,
      top: s.top === !1 ? 0 : o.top - s.top,
      bottom: s.bottom === !1 ? this.height : o.bottom + s.bottom
    }), t.controller.draw(), n && Ue(e), r.cancelable = !1, this.notifyPlugins("afterDatasetDraw", r));
  }
  isPointInArea(t) {
    return re(t, this.chartArea, this._minPadding);
  }
  getElementsAtEventForMode(t, e, s, n) {
    const o = Hn.modes[e];
    return typeof o == "function" ? o(this, t, s, n) : [];
  }
  getDatasetMeta(t) {
    const e = this.data.datasets[t], s = this._metasets;
    let n = s.filter((o) => o && o._dataset === e).pop();
    return n || (n = {
      type: null,
      data: [],
      dataset: null,
      controller: null,
      hidden: null,
      xAxisID: null,
      yAxisID: null,
      order: e && e.order || 0,
      index: t,
      _dataset: e,
      _parsed: [],
      _sorted: !1
    }, s.push(n)), n;
  }
  getContext() {
    return this.$context || (this.$context = vt(null, { chart: this, type: "chart" }));
  }
  getVisibleDatasetCount() {
    return this.getSortedVisibleDatasetMetas().length;
  }
  isDatasetVisible(t) {
    const e = this.data.datasets[t];
    if (!e)
      return !1;
    const s = this.getDatasetMeta(t);
    return typeof s.hidden == "boolean" ? !s.hidden : !e.hidden;
  }
  setDatasetVisibility(t, e) {
    const s = this.getDatasetMeta(t);
    s.hidden = !e;
  }
  toggleDataVisibility(t) {
    this._hiddenIndices[t] = !this._hiddenIndices[t];
  }
  getDataVisibility(t) {
    return !this._hiddenIndices[t];
  }
  _updateVisibility(t, e, s) {
    const n = s ? "show" : "hide", o = this.getDatasetMeta(t), r = o.controller._resolveAnimations(void 0, n);
    et(e) ? (o.data[e].hidden = !s, this.update()) : (this.setDatasetVisibility(t, s), r.update(o, { visible: s }), this.update((a) => a.datasetIndex === t ? n : void 0));
  }
  hide(t, e) {
    this._updateVisibility(t, e, !1);
  }
  show(t, e) {
    this._updateVisibility(t, e, !0);
  }
  _destroyDatasetMeta(t) {
    const e = this._metasets[t];
    e && e.controller && e.controller._destroy(), delete this._metasets[t];
  }
  _stop() {
    let t, e;
    for (this.stop(), at.remove(this), t = 0, e = this.data.datasets.length; t < e; ++t)
      this._destroyDatasetMeta(t);
  }
  destroy() {
    this.notifyPlugins("beforeDestroy");
    const { canvas: t, ctx: e } = this;
    this._stop(), this.config.clearCache(), t && (this.unbindEvents(), os(t, e), this.platform.releaseContext(e), this.canvas = null, this.ctx = null), this.notifyPlugins("destroy"), delete $e[this.id], this.notifyPlugins("afterDestroy");
  }
  toBase64Image(...t) {
    return this.canvas.toDataURL(...t);
  }
  bindEvents() {
    this.bindUserEvents(), this.options.responsive ? this.bindResponsiveEvents() : this.attached = !0;
  }
  bindUserEvents() {
    const t = this._listeners, e = this.platform, s = (o, r) => {
      e.addEventListener(this, o, r), t[o] = r;
    }, n = (o, r, a) => {
      o.offsetX = r, o.offsetY = a, this._eventHandler(o);
    };
    E(this.options.events, (o) => s(o, n));
  }
  bindResponsiveEvents() {
    this._responsiveListeners || (this._responsiveListeners = {});
    const t = this._responsiveListeners, e = this.platform, s = (l, c) => {
      e.addEventListener(this, l, c), t[l] = c;
    }, n = (l, c) => {
      t[l] && (e.removeEventListener(this, l, c), delete t[l]);
    }, o = (l, c) => {
      this.canvas && this.resize(l, c);
    };
    let r;
    const a = () => {
      n("attach", a), this.attached = !0, this.resize(), s("resize", o), s("detach", r);
    };
    r = () => {
      this.attached = !1, n("resize", o), this._stop(), this._resize(0, 0), s("attach", a);
    }, e.isAttached(this.canvas) ? a() : r();
  }
  unbindEvents() {
    E(this._listeners, (t, e) => {
      this.platform.removeEventListener(this, e, t);
    }), this._listeners = {}, E(this._responsiveListeners, (t, e) => {
      this.platform.removeEventListener(this, e, t);
    }), this._responsiveListeners = void 0;
  }
  updateHoverStyle(t, e, s) {
    const n = s ? "set" : "remove";
    let o, r, a, l;
    for (e === "dataset" && (o = this.getDatasetMeta(t[0].datasetIndex), o.controller["_" + n + "DatasetHoverStyle"]()), a = 0, l = t.length; a < l; ++a) {
      r = t[a];
      const c = r && this.getDatasetMeta(r.datasetIndex).controller;
      c && c[n + "HoverStyle"](r.element, r.datasetIndex, r.index);
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(t) {
    const e = this._active || [], s = t.map(({ datasetIndex: o, index: r }) => {
      const a = this.getDatasetMeta(o);
      if (!a)
        throw new Error("No dataset found at index " + o);
      return {
        datasetIndex: o,
        element: a.data[r],
        index: r
      };
    });
    !ze(s, e) && (this._active = s, this._lastEvent = null, this._updateHoverStyles(s, e));
  }
  notifyPlugins(t, e, s) {
    return this._plugins.notify(this, t, e, s);
  }
  _updateHoverStyles(t, e, s) {
    const n = this.options.hover, o = (l, c) => l.filter((h) => !c.some((d) => h.datasetIndex === d.datasetIndex && h.index === d.index)), r = o(e, t), a = s ? t : o(t, e);
    r.length && this.updateHoverStyle(r, n.mode, !1), a.length && n.mode && this.updateHoverStyle(a, n.mode, !0);
  }
  _eventHandler(t, e) {
    const s = {
      event: t,
      replay: e,
      cancelable: !0,
      inChartArea: this.isPointInArea(t)
    }, n = (r) => (r.options.events || this.options.events).includes(t.native.type);
    if (this.notifyPlugins("beforeEvent", s, n) === !1)
      return;
    const o = this._handleEvent(t, e, s.inChartArea);
    return s.cancelable = !1, this.notifyPlugins("afterEvent", s, n), (o || s.changed) && this.render(), this;
  }
  _handleEvent(t, e, s) {
    const { _active: n = [], options: o } = this, r = e, a = this._getActiveElements(t, n, s, r), l = So(t), c = Cl(t, this._lastEvent, s, l);
    s && (this._lastEvent = null, I(o.onHover, [t, a, this], this), l && I(o.onClick, [t, a, this], this));
    const h = !ze(a, n);
    return (h || e) && (this._active = a, this._updateHoverStyles(a, n, e)), this._lastEvent = c, h;
  }
  _getActiveElements(t, e, s, n) {
    if (t.type === "mouseout")
      return [];
    if (!s)
      return e;
    const o = this.options.hover;
    return this.getElementsAtEventForMode(t, o.mode, o, n);
  }
}
const Bs = () => E(ji.instances, (i) => i._plugins.invalidate()), pt = !0;
Object.defineProperties(ji, {
  defaults: {
    enumerable: pt,
    value: O
  },
  instances: {
    enumerable: pt,
    value: $e
  },
  overrides: {
    enumerable: pt,
    value: At
  },
  registry: {
    enumerable: pt,
    value: ot
  },
  version: {
    enumerable: pt,
    value: kl
  },
  getChart: {
    enumerable: pt,
    value: to
  },
  register: {
    enumerable: pt,
    value: (...i) => {
      ot.add(...i), Bs();
    }
  },
  unregister: {
    enumerable: pt,
    value: (...i) => {
      ot.remove(...i), Bs();
    }
  }
});
function eo(i, t, e) {
  const { startAngle: s, pixelMargin: n, x: o, y: r, outerRadius: a, innerRadius: l } = t;
  let c = n / a;
  i.beginPath(), i.arc(o, r, a, s - c, e + c), l > n ? (c = n / l, i.arc(o, r, l, e + c, s - c, !0)) : i.arc(o, r, n, e + V, s - V), i.closePath(), i.clip();
}
function Dl(i) {
  return Ii(i, ["outerStart", "outerEnd", "innerStart", "innerEnd"]);
}
function Ol(i, t, e, s) {
  const n = Dl(i.options.borderRadius), o = (e - t) / 2, r = Math.min(o, s * t / 2), a = (l) => {
    const c = (e - Math.min(o, l)) * s / 2;
    return Y(l, 0, Math.min(o, c));
  };
  return {
    outerStart: a(n.outerStart),
    outerEnd: a(n.outerEnd),
    innerStart: Y(n.innerStart, 0, r),
    innerEnd: Y(n.innerEnd, 0, r)
  };
}
function It(i, t, e, s) {
  return {
    x: e + i * Math.cos(t),
    y: s + i * Math.sin(t)
  };
}
function wi(i, t, e, s, n, o) {
  const { x: r, y: a, startAngle: l, pixelMargin: c, innerRadius: h } = t, d = Math.max(t.outerRadius + s + e - c, 0), u = h > 0 ? h + s + e + c : 0;
  let f = 0;
  const g = n - l;
  if (s) {
    const P = h > 0 ? h - s : 0, j = d > 0 ? d - s : 0, W = (P + j) / 2, kt = W !== 0 ? g * W / (W + s) : g;
    f = (g - kt) / 2;
  }
  const p = Math.max(1e-3, g * d - e / B) / d, m = (g - p) / 2, b = l + m + f, x = n - m - f, { outerStart: v, outerEnd: y, innerStart: _, innerEnd: M } = Ol(t, u, d, x - b), k = d - v, S = d - y, w = b + v / k, L = x - y / S, R = u + _, A = u + M, H = b + _ / R, q = x - M / A;
  if (i.beginPath(), o) {
    if (i.arc(r, a, d, w, L), y > 0) {
      const W = It(S, L, r, a);
      i.arc(W.x, W.y, y, L, x + V);
    }
    const P = It(A, x, r, a);
    if (i.lineTo(P.x, P.y), M > 0) {
      const W = It(A, q, r, a);
      i.arc(W.x, W.y, M, x + V, q + Math.PI);
    }
    if (i.arc(r, a, u, x - M / u, b + _ / u, !0), _ > 0) {
      const W = It(R, H, r, a);
      i.arc(W.x, W.y, _, H + Math.PI, b - V);
    }
    const j = It(k, b, r, a);
    if (i.lineTo(j.x, j.y), v > 0) {
      const W = It(k, w, r, a);
      i.arc(W.x, W.y, v, b - V, w);
    }
  } else {
    i.moveTo(r, a);
    const P = Math.cos(w) * d + r, j = Math.sin(w) * d + a;
    i.lineTo(P, j);
    const W = Math.cos(L) * d + r, kt = Math.sin(L) * d + a;
    i.lineTo(W, kt);
  }
  i.closePath();
}
function Al(i, t, e, s, n) {
  const { fullCircles: o, startAngle: r, circumference: a } = t;
  let l = t.endAngle;
  if (o) {
    wi(i, t, e, s, r + F, n);
    for (let c = 0; c < o; ++c)
      i.fill();
    isNaN(a) || (l = r + a % F, a % F === 0 && (l += F));
  }
  return wi(i, t, e, s, l, n), i.fill(), l;
}
function Tl(i, t, e) {
  const { x: s, y: n, startAngle: o, pixelMargin: r, fullCircles: a } = t, l = Math.max(t.outerRadius - r, 0), c = t.innerRadius + r;
  let h;
  for (e && eo(i, t, o + F), i.beginPath(), i.arc(s, n, c, o + F, o, !0), h = 0; h < a; ++h)
    i.stroke();
  for (i.beginPath(), i.arc(s, n, l, o, o + F), h = 0; h < a; ++h)
    i.stroke();
}
function Ll(i, t, e, s, n, o) {
  const { options: r } = t, { borderWidth: a, borderJoinStyle: l } = r, c = r.borderAlign === "inner";
  a && (c ? (i.lineWidth = a * 2, i.lineJoin = l || "round") : (i.lineWidth = a, i.lineJoin = l || "bevel"), t.fullCircles && Tl(i, t, c), c && eo(i, t, n), wi(i, t, e, s, n, o), i.stroke());
}
class ye extends st {
  constructor(t) {
    super(), this.options = void 0, this.circumference = void 0, this.startAngle = void 0, this.endAngle = void 0, this.innerRadius = void 0, this.outerRadius = void 0, this.pixelMargin = 0, this.fullCircles = 0, t && Object.assign(this, t);
  }
  inRange(t, e, s) {
    const n = this.getProps(["x", "y"], s), { angle: o, distance: r } = hn(n, { x: t, y: e }), { startAngle: a, endAngle: l, innerRadius: c, outerRadius: h, circumference: d } = this.getProps([
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius",
      "circumference"
    ], s), u = this.options.spacing / 2, g = C(d, l - a) >= F || oe(o, a, l), p = ut(r, c + u, h + u);
    return g && p;
  }
  getCenterPoint(t) {
    const { x: e, y: s, startAngle: n, endAngle: o, innerRadius: r, outerRadius: a } = this.getProps([
      "x",
      "y",
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius",
      "circumference"
    ], t), { offset: l, spacing: c } = this.options, h = (n + o) / 2, d = (r + a + c + l) / 2;
    return {
      x: e + Math.cos(h) * d,
      y: s + Math.sin(h) * d
    };
  }
  tooltipPosition(t) {
    return this.getCenterPoint(t);
  }
  draw(t) {
    const { options: e, circumference: s } = this, n = (e.offset || 0) / 2, o = (e.spacing || 0) / 2, r = e.circular;
    if (this.pixelMargin = e.borderAlign === "inner" ? 0.33 : 0, this.fullCircles = s > F ? Math.floor(s / F) : 0, s === 0 || this.innerRadius < 0 || this.outerRadius < 0)
      return;
    t.save();
    let a = 0;
    if (n) {
      a = n / 2;
      const c = (this.startAngle + this.endAngle) / 2;
      t.translate(Math.cos(c) * a, Math.sin(c) * a), this.circumference >= B && (a = n);
    }
    t.fillStyle = e.backgroundColor, t.strokeStyle = e.borderColor;
    const l = Al(t, this, a, o, r);
    Ll(t, this, a, o, l, r), t.restore();
  }
}
ye.id = "arc";
ye.defaults = {
  borderAlign: "center",
  borderColor: "#fff",
  borderJoinStyle: void 0,
  borderRadius: 0,
  borderWidth: 2,
  offset: 0,
  spacing: 0,
  angle: void 0,
  circular: !0
};
ye.defaultRoutes = {
  backgroundColor: "backgroundColor"
};
function io(i, t, e = t) {
  i.lineCap = C(e.borderCapStyle, t.borderCapStyle), i.setLineDash(C(e.borderDash, t.borderDash)), i.lineDashOffset = C(e.borderDashOffset, t.borderDashOffset), i.lineJoin = C(e.borderJoinStyle, t.borderJoinStyle), i.lineWidth = C(e.borderWidth, t.borderWidth), i.strokeStyle = C(e.borderColor, t.borderColor);
}
function Rl(i, t, e) {
  i.lineTo(e.x, e.y);
}
function El(i) {
  return i.stepped ? lr : i.tension || i.cubicInterpolationMode === "monotone" ? cr : Rl;
}
function so(i, t, e = {}) {
  const s = i.length, { start: n = 0, end: o = s - 1 } = e, { start: r, end: a } = t, l = Math.max(n, r), c = Math.min(o, a), h = n < r && o < r || n > a && o > a;
  return {
    count: s,
    start: l,
    loop: t.loop,
    ilen: c < l && !h ? s + c - l : c - l
  };
}
function Fl(i, t, e, s) {
  const { points: n, options: o } = t, { count: r, start: a, loop: l, ilen: c } = so(n, e, s), h = El(o);
  let { move: d = !0, reverse: u } = s || {}, f, g, p;
  for (f = 0; f <= c; ++f)
    g = n[(a + (u ? c - f : f)) % r], !g.skip && (d ? (i.moveTo(g.x, g.y), d = !1) : h(i, p, g, u, o.stepped), p = g);
  return l && (g = n[(a + (u ? c : 0)) % r], h(i, p, g, u, o.stepped)), !!l;
}
function Il(i, t, e, s) {
  const n = t.points, { count: o, start: r, ilen: a } = so(n, e, s), { move: l = !0, reverse: c } = s || {};
  let h = 0, d = 0, u, f, g, p, m, b;
  const x = (y) => (r + (c ? a - y : y)) % o, v = () => {
    p !== m && (i.lineTo(h, m), i.lineTo(h, p), i.lineTo(h, b));
  };
  for (l && (f = n[x(0)], i.moveTo(f.x, f.y)), u = 0; u <= a; ++u) {
    if (f = n[x(u)], f.skip)
      continue;
    const y = f.x, _ = f.y, M = y | 0;
    M === g ? (_ < p ? p = _ : _ > m && (m = _), h = (d * h + y) / ++d) : (v(), i.lineTo(y, _), g = M, d = 0, p = m = _), b = _;
  }
  v();
}
function Si(i) {
  const t = i.options, e = t.borderDash && t.borderDash.length;
  return !i._decimated && !i._loop && !t.tension && t.cubicInterpolationMode !== "monotone" && !t.stepped && !e ? Il : Fl;
}
function zl(i) {
  return i.stepped ? Wr : i.tension || i.cubicInterpolationMode === "monotone" ? Nr : Ct;
}
function Bl(i, t, e, s) {
  let n = t._path;
  n || (n = t._path = new Path2D(), t.path(n, e, s) && n.closePath()), io(i, t.options), i.stroke(n);
}
function Vl(i, t, e, s) {
  const { segments: n, options: o } = t, r = Si(t);
  for (const a of n)
    io(i, o, a.style), i.beginPath(), r(i, t, a, { start: e, end: e + s - 1 }) && i.closePath(), i.stroke();
}
const Wl = typeof Path2D == "function";
function Nl(i, t, e, s) {
  Wl && !t.options.segment ? Bl(i, t, e, s) : Vl(i, t, e, s);
}
class gt extends st {
  constructor(t) {
    super(), this.animated = !0, this.options = void 0, this._chart = void 0, this._loop = void 0, this._fullLoop = void 0, this._path = void 0, this._points = void 0, this._segments = void 0, this._decimated = !1, this._pointsUpdated = !1, this._datasetIndex = void 0, t && Object.assign(this, t);
  }
  updateControlPoints(t, e) {
    const s = this.options;
    if ((s.tension || s.cubicInterpolationMode === "monotone") && !s.stepped && !this._pointsUpdated) {
      const n = s.spanGaps ? this._loop : this._fullLoop;
      Lr(this._points, s, t, n, e), this._pointsUpdated = !0;
    }
  }
  set points(t) {
    this._points = t, delete this._segments, delete this._path, this._pointsUpdated = !1;
  }
  get points() {
    return this._points;
  }
  get segments() {
    return this._segments || (this._segments = Kr(this, this.options.segment));
  }
  first() {
    const t = this.segments, e = this.points;
    return t.length && e[t[0].start];
  }
  last() {
    const t = this.segments, e = this.points, s = t.length;
    return s && e[t[s - 1].end];
  }
  interpolate(t, e) {
    const s = this.options, n = t[e], o = this.points, r = Fn(this, { property: e, start: n, end: n });
    if (!r.length)
      return;
    const a = [], l = zl(s);
    let c, h;
    for (c = 0, h = r.length; c < h; ++c) {
      const { start: d, end: u } = r[c], f = o[d], g = o[u];
      if (f === g) {
        a.push(f);
        continue;
      }
      const p = Math.abs((n - f[e]) / (g[e] - f[e])), m = l(f, g, p, s.stepped);
      m[e] = t[e], a.push(m);
    }
    return a.length === 1 ? a[0] : a;
  }
  pathSegment(t, e, s) {
    return Si(this)(t, this, e, s);
  }
  path(t, e, s) {
    const n = this.segments, o = Si(this);
    let r = this._loop;
    e = e || 0, s = s || this.points.length - e;
    for (const a of n)
      r &= o(t, this, a, { start: e, end: e + s - 1 });
    return !!r;
  }
  draw(t, e, s, n) {
    const o = this.options || {};
    (this.points || []).length && o.borderWidth && (t.save(), Nl(t, this, s, n), t.restore()), this.animated && (this._pointsUpdated = !1, this._path = void 0);
  }
}
gt.id = "line";
gt.defaults = {
  borderCapStyle: "butt",
  borderDash: [],
  borderDashOffset: 0,
  borderJoinStyle: "miter",
  borderWidth: 3,
  capBezierPoints: !0,
  cubicInterpolationMode: "default",
  fill: !1,
  spanGaps: !1,
  stepped: !1,
  tension: 0
};
gt.defaultRoutes = {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
};
gt.descriptors = {
  _scriptable: !0,
  _indexable: (i) => i !== "borderDash" && i !== "fill"
};
function Vs(i, t, e, s) {
  const n = i.options, { [e]: o } = i.getProps([e], s);
  return Math.abs(t - o) < n.radius + n.hitRadius;
}
class ve extends st {
  constructor(t) {
    super(), this.options = void 0, this.parsed = void 0, this.skip = void 0, this.stop = void 0, t && Object.assign(this, t);
  }
  inRange(t, e, s) {
    const n = this.options, { x: o, y: r } = this.getProps(["x", "y"], s);
    return Math.pow(t - o, 2) + Math.pow(e - r, 2) < Math.pow(n.hitRadius + n.radius, 2);
  }
  inXRange(t, e) {
    return Vs(this, t, "x", e);
  }
  inYRange(t, e) {
    return Vs(this, t, "y", e);
  }
  getCenterPoint(t) {
    const { x: e, y: s } = this.getProps(["x", "y"], t);
    return { x: e, y: s };
  }
  size(t) {
    t = t || this.options || {};
    let e = t.radius || 0;
    e = Math.max(e, e && t.hoverRadius || 0);
    const s = e && t.borderWidth || 0;
    return (e + s) * 2;
  }
  draw(t, e) {
    const s = this.options;
    this.skip || s.radius < 0.1 || !re(this, e, this.size(s) / 2) || (t.strokeStyle = s.borderColor, t.lineWidth = s.borderWidth, t.fillStyle = s.backgroundColor, yi(t, s, this.x, this.y));
  }
  getRange() {
    const t = this.options || {};
    return t.radius + t.hitRadius;
  }
}
ve.id = "point";
ve.defaults = {
  borderWidth: 1,
  hitRadius: 1,
  hoverBorderWidth: 1,
  hoverRadius: 4,
  pointStyle: "circle",
  radius: 3,
  rotation: 0
};
ve.defaultRoutes = {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
};
function no(i, t) {
  const { x: e, y: s, base: n, width: o, height: r } = i.getProps(["x", "y", "base", "width", "height"], t);
  let a, l, c, h, d;
  return i.horizontal ? (d = r / 2, a = Math.min(e, n), l = Math.max(e, n), c = s - d, h = s + d) : (d = o / 2, a = e - d, l = e + d, c = Math.min(s, n), h = Math.max(s, n)), { left: a, top: c, right: l, bottom: h };
}
function bt(i, t, e, s) {
  return i ? 0 : Y(t, e, s);
}
function Hl(i, t, e) {
  const s = i.options.borderWidth, n = i.borderSkipped, o = kn(s);
  return {
    t: bt(n.top, o.top, 0, e),
    r: bt(n.right, o.right, 0, t),
    b: bt(n.bottom, o.bottom, 0, e),
    l: bt(n.left, o.left, 0, t)
  };
}
function jl(i, t, e) {
  const { enableBorderRadius: s } = i.getProps(["enableBorderRadius"]), n = i.options.borderRadius, o = Dt(n), r = Math.min(t, e), a = i.borderSkipped, l = s || D(n);
  return {
    topLeft: bt(!l || a.top || a.left, o.topLeft, 0, r),
    topRight: bt(!l || a.top || a.right, o.topRight, 0, r),
    bottomLeft: bt(!l || a.bottom || a.left, o.bottomLeft, 0, r),
    bottomRight: bt(!l || a.bottom || a.right, o.bottomRight, 0, r)
  };
}
function $l(i) {
  const t = no(i), e = t.right - t.left, s = t.bottom - t.top, n = Hl(i, e / 2, s / 2), o = jl(i, e / 2, s / 2);
  return {
    outer: {
      x: t.left,
      y: t.top,
      w: e,
      h: s,
      radius: o
    },
    inner: {
      x: t.left + n.l,
      y: t.top + n.t,
      w: e - n.l - n.r,
      h: s - n.t - n.b,
      radius: {
        topLeft: Math.max(0, o.topLeft - Math.max(n.t, n.l)),
        topRight: Math.max(0, o.topRight - Math.max(n.t, n.r)),
        bottomLeft: Math.max(0, o.bottomLeft - Math.max(n.b, n.l)),
        bottomRight: Math.max(0, o.bottomRight - Math.max(n.b, n.r))
      }
    }
  };
}
function gi(i, t, e, s) {
  const n = t === null, o = e === null, a = i && !(n && o) && no(i, s);
  return a && (n || ut(t, a.left, a.right)) && (o || ut(e, a.top, a.bottom));
}
function Yl(i) {
  return i.topLeft || i.topRight || i.bottomLeft || i.bottomRight;
}
function Xl(i, t) {
  i.rect(t.x, t.y, t.w, t.h);
}
function pi(i, t, e = {}) {
  const s = i.x !== e.x ? -t : 0, n = i.y !== e.y ? -t : 0, o = (i.x + i.w !== e.x + e.w ? t : 0) - s, r = (i.y + i.h !== e.y + e.h ? t : 0) - n;
  return {
    x: i.x + s,
    y: i.y + n,
    w: i.w + o,
    h: i.h + r,
    radius: i.radius
  };
}
class Me extends st {
  constructor(t) {
    super(), this.options = void 0, this.horizontal = void 0, this.base = void 0, this.width = void 0, this.height = void 0, this.inflateAmount = void 0, t && Object.assign(this, t);
  }
  draw(t) {
    const { inflateAmount: e, options: { borderColor: s, backgroundColor: n } } = this, { inner: o, outer: r } = $l(this), a = Yl(r.radius) ? ae : Xl;
    t.save(), (r.w !== o.w || r.h !== o.h) && (t.beginPath(), a(t, pi(r, e, o)), t.clip(), a(t, pi(o, -e, r)), t.fillStyle = s, t.fill("evenodd")), t.beginPath(), a(t, pi(o, e)), t.fillStyle = n, t.fill(), t.restore();
  }
  inRange(t, e, s) {
    return gi(this, t, e, s);
  }
  inXRange(t, e) {
    return gi(this, t, null, e);
  }
  inYRange(t, e) {
    return gi(this, null, t, e);
  }
  getCenterPoint(t) {
    const { x: e, y: s, base: n, horizontal: o } = this.getProps(["x", "y", "base", "horizontal"], t);
    return {
      x: o ? (e + n) / 2 : e,
      y: o ? s : (s + n) / 2
    };
  }
  getRange(t) {
    return t === "x" ? this.width / 2 : this.height / 2;
  }
}
Me.id = "bar";
Me.defaults = {
  borderSkipped: "start",
  borderWidth: 0,
  borderRadius: 0,
  inflateAmount: "auto",
  pointStyle: void 0
};
Me.defaultRoutes = {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
};
var oo = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcElement: ye,
  LineElement: gt,
  PointElement: ve,
  BarElement: Me
});
function Ul(i, t, e, s, n) {
  const o = n.samples || s;
  if (o >= e)
    return i.slice(t, t + e);
  const r = [], a = (e - 2) / (o - 2);
  let l = 0;
  const c = t + e - 1;
  let h = t, d, u, f, g, p;
  for (r[l++] = i[h], d = 0; d < o - 2; d++) {
    let m = 0, b = 0, x;
    const v = Math.floor((d + 1) * a) + 1 + t, y = Math.min(Math.floor((d + 2) * a) + 1, e) + t, _ = y - v;
    for (x = v; x < y; x++)
      m += i[x].x, b += i[x].y;
    m /= _, b /= _;
    const M = Math.floor(d * a) + 1 + t, k = Math.min(Math.floor((d + 1) * a) + 1, e) + t, { x: S, y: w } = i[h];
    for (f = g = -1, x = M; x < k; x++)
      g = 0.5 * Math.abs(
        (S - m) * (i[x].y - w) - (S - i[x].x) * (b - w)
      ), g > f && (f = g, u = i[x], p = x);
    r[l++] = u, h = p;
  }
  return r[l++] = i[c], r;
}
function Kl(i, t, e, s) {
  let n = 0, o = 0, r, a, l, c, h, d, u, f, g, p;
  const m = [], b = t + e - 1, x = i[t].x, y = i[b].x - x;
  for (r = t; r < t + e; ++r) {
    a = i[r], l = (a.x - x) / y * s, c = a.y;
    const _ = l | 0;
    if (_ === h)
      c < g ? (g = c, d = r) : c > p && (p = c, u = r), n = (o * n + a.x) / ++o;
    else {
      const M = r - 1;
      if (!T(d) && !T(u)) {
        const k = Math.min(d, u), S = Math.max(d, u);
        k !== f && k !== M && m.push({
          ...i[k],
          x: n
        }), S !== f && S !== M && m.push({
          ...i[S],
          x: n
        });
      }
      r > 0 && M !== f && m.push(i[M]), m.push(a), h = _, o = 0, g = p = c, d = u = f = r;
    }
  }
  return m;
}
function ro(i) {
  if (i._decimated) {
    const t = i._data;
    delete i._decimated, delete i._data, Object.defineProperty(i, "data", { value: t });
  }
}
function Ws(i) {
  i.data.datasets.forEach((t) => {
    ro(t);
  });
}
function ql(i, t) {
  const e = t.length;
  let s = 0, n;
  const { iScale: o } = i, { min: r, max: a, minDefined: l, maxDefined: c } = o.getUserBounds();
  return l && (s = Y(ft(t, o.axis, r).lo, 0, e - 1)), c ? n = Y(ft(t, o.axis, a).hi + 1, s, e) - s : n = e - s, { start: s, count: n };
}
var ao = {
  id: "decimation",
  defaults: {
    algorithm: "min-max",
    enabled: !1
  },
  beforeElementsUpdate: (i, t, e) => {
    if (!e.enabled) {
      Ws(i);
      return;
    }
    const s = i.width;
    i.data.datasets.forEach((n, o) => {
      const { _data: r, indexAxis: a } = n, l = i.getDatasetMeta(o), c = r || n.data;
      if (Zt([a, i.options.indexAxis]) === "y" || !l.controller.supportsDecimation)
        return;
      const h = i.scales[l.xAxisID];
      if (h.type !== "linear" && h.type !== "time" || i.options.parsing)
        return;
      let { start: d, count: u } = ql(l, c);
      const f = e.threshold || 4 * s;
      if (u <= f) {
        ro(n);
        return;
      }
      T(r) && (n._data = c, delete n.data, Object.defineProperty(n, "data", {
        configurable: !0,
        enumerable: !0,
        get: function() {
          return this._decimated;
        },
        set: function(p) {
          this._data = p;
        }
      }));
      let g;
      switch (e.algorithm) {
        case "lttb":
          g = Ul(c, d, u, s, e);
          break;
        case "min-max":
          g = Kl(c, d, u, s);
          break;
        default:
          throw new Error(`Unsupported decimation algorithm '${e.algorithm}'`);
      }
      n._decimated = g;
    });
  },
  destroy(i) {
    Ws(i);
  }
};
function Gl(i, t, e) {
  const s = i.segments, n = i.points, o = t.points, r = [];
  for (const a of s) {
    let { start: l, end: c } = a;
    c = $i(l, c, n);
    const h = Pi(e, n[l], n[c], a.loop);
    if (!t.segments) {
      r.push({
        source: a,
        target: h,
        start: n[l],
        end: n[c]
      });
      continue;
    }
    const d = Fn(t, h);
    for (const u of d) {
      const f = Pi(e, o[u.start], o[u.end], u.loop), g = En(a, n, f);
      for (const p of g)
        r.push({
          source: p,
          target: u,
          start: {
            [e]: Ns(h, f, "start", Math.max)
          },
          end: {
            [e]: Ns(h, f, "end", Math.min)
          }
        });
    }
  }
  return r;
}
function Pi(i, t, e, s) {
  if (s)
    return;
  let n = t[i], o = e[i];
  return i === "angle" && (n = Z(n), o = Z(o)), { property: i, start: n, end: o };
}
function Zl(i, t) {
  const { x: e = null, y: s = null } = i || {}, n = t.points, o = [];
  return t.segments.forEach(({ start: r, end: a }) => {
    a = $i(r, a, n);
    const l = n[r], c = n[a];
    s !== null ? (o.push({ x: l.x, y: s }), o.push({ x: c.x, y: s })) : e !== null && (o.push({ x: e, y: l.y }), o.push({ x: e, y: c.y }));
  }), o;
}
function $i(i, t, e) {
  for (; t > i; t--) {
    const s = e[t];
    if (!isNaN(s.x) && !isNaN(s.y))
      break;
  }
  return t;
}
function Ns(i, t, e, s) {
  return i && t ? s(i[e], t[e]) : i ? i[e] : t ? t[e] : 0;
}
function lo(i, t) {
  let e = [], s = !1;
  return z(i) ? (s = !0, e = i) : e = Zl(i, t), e.length ? new gt({
    points: e,
    options: { tension: 0 },
    _loop: s,
    _fullLoop: s
  }) : null;
}
function Hs(i) {
  return i && i.fill !== !1;
}
function Jl(i, t, e) {
  let n = i[t].fill;
  const o = [t];
  let r;
  if (!e)
    return n;
  for (; n !== !1 && o.indexOf(n) === -1; ) {
    if (!N(n))
      return n;
    if (r = i[n], !r)
      return !1;
    if (r.visible)
      return n;
    o.push(n), n = r.fill;
  }
  return !1;
}
function Ql(i, t, e) {
  const s = sc(i);
  if (D(s))
    return isNaN(s.value) ? !1 : s;
  let n = parseFloat(s);
  return N(n) && Math.floor(n) === n ? tc(s[0], t, n, e) : ["origin", "start", "end", "stack", "shape"].indexOf(s) >= 0 && s;
}
function tc(i, t, e, s) {
  return (i === "-" || i === "+") && (e = t + e), e === t || e < 0 || e >= s ? !1 : e;
}
function ec(i, t) {
  let e = null;
  return i === "start" ? e = t.bottom : i === "end" ? e = t.top : D(i) ? e = t.getPixelForValue(i.value) : t.getBasePixel && (e = t.getBasePixel()), e;
}
function ic(i, t, e) {
  let s;
  return i === "start" ? s = e : i === "end" ? s = t.options.reverse ? t.min : t.max : D(i) ? s = i.value : s = t.getBaseValue(), s;
}
function sc(i) {
  const t = i.options, e = t.fill;
  let s = C(e && e.target, e);
  return s === void 0 && (s = !!t.backgroundColor), s === !1 || s === null ? !1 : s === !0 ? "origin" : s;
}
function nc(i) {
  const { scale: t, index: e, line: s } = i, n = [], o = s.segments, r = s.points, a = oc(t, e);
  a.push(lo({ x: null, y: t.bottom }, s));
  for (let l = 0; l < o.length; l++) {
    const c = o[l];
    for (let h = c.start; h <= c.end; h++)
      rc(n, r[h], a);
  }
  return new gt({ points: n, options: {} });
}
function oc(i, t) {
  const e = [], s = i.getMatchingVisibleMetas("line");
  for (let n = 0; n < s.length; n++) {
    const o = s[n];
    if (o.index === t)
      break;
    o.hidden || e.unshift(o.dataset);
  }
  return e;
}
function rc(i, t, e) {
  const s = [];
  for (let n = 0; n < e.length; n++) {
    const o = e[n], { first: r, last: a, point: l } = ac(o, t, "x");
    if (!(!l || r && a)) {
      if (r)
        s.unshift(l);
      else if (i.push(l), !a)
        break;
    }
  }
  i.push(...s);
}
function ac(i, t, e) {
  const s = i.interpolate(t, e);
  if (!s)
    return {};
  const n = s[e], o = i.segments, r = i.points;
  let a = !1, l = !1;
  for (let c = 0; c < o.length; c++) {
    const h = o[c], d = r[h.start][e], u = r[h.end][e];
    if (ut(n, d, u)) {
      a = n === d, l = n === u;
      break;
    }
  }
  return { first: a, last: l, point: s };
}
class co {
  constructor(t) {
    this.x = t.x, this.y = t.y, this.radius = t.radius;
  }
  pathSegment(t, e, s) {
    const { x: n, y: o, radius: r } = this;
    return e = e || { start: 0, end: F }, t.arc(n, o, r, e.end, e.start, !0), !s.bounds;
  }
  interpolate(t) {
    const { x: e, y: s, radius: n } = this, o = t.angle;
    return {
      x: e + Math.cos(o) * n,
      y: s + Math.sin(o) * n,
      angle: o
    };
  }
}
function lc(i) {
  const { chart: t, fill: e, line: s } = i;
  if (N(e))
    return cc(t, e);
  if (e === "stack")
    return nc(i);
  if (e === "shape")
    return !0;
  const n = hc(i);
  return n instanceof co ? n : lo(n, s);
}
function cc(i, t) {
  const e = i.getDatasetMeta(t);
  return e && i.isDatasetVisible(t) ? e.dataset : null;
}
function hc(i) {
  return (i.scale || {}).getPointPositionForValue ? uc(i) : dc(i);
}
function dc(i) {
  const { scale: t = {}, fill: e } = i, s = ec(e, t);
  if (N(s)) {
    const n = t.isHorizontal();
    return {
      x: n ? s : null,
      y: n ? null : s
    };
  }
  return null;
}
function uc(i) {
  const { scale: t, fill: e } = i, s = t.options, n = t.getLabels().length, o = s.reverse ? t.max : t.min, r = ic(e, t, o), a = [];
  if (s.grid.circular) {
    const l = t.getPointPositionForValue(0, o);
    return new co({
      x: l.x,
      y: l.y,
      radius: t.getDistanceFromCenterForValue(r)
    });
  }
  for (let l = 0; l < n; ++l)
    a.push(t.getPointPositionForValue(l, r));
  return a;
}
function mi(i, t, e) {
  const s = lc(t), { line: n, scale: o, axis: r } = t, a = n.options, l = a.fill, c = a.backgroundColor, { above: h = c, below: d = c } = l || {};
  s && n.points.length && (Xe(i, e), fc(i, { line: n, target: s, above: h, below: d, area: e, scale: o, axis: r }), Ue(i));
}
function fc(i, t) {
  const { line: e, target: s, above: n, below: o, area: r, scale: a } = t, l = e._loop ? "angle" : t.axis;
  i.save(), l === "x" && o !== n && (js(i, s, r.top), $s(i, { line: e, target: s, color: n, scale: a, property: l }), i.restore(), i.save(), js(i, s, r.bottom)), $s(i, { line: e, target: s, color: o, scale: a, property: l }), i.restore();
}
function js(i, t, e) {
  const { segments: s, points: n } = t;
  let o = !0, r = !1;
  i.beginPath();
  for (const a of s) {
    const { start: l, end: c } = a, h = n[l], d = n[$i(l, c, n)];
    o ? (i.moveTo(h.x, h.y), o = !1) : (i.lineTo(h.x, e), i.lineTo(h.x, h.y)), r = !!t.pathSegment(i, a, { move: r }), r ? i.closePath() : i.lineTo(d.x, e);
  }
  i.lineTo(t.first().x, e), i.closePath(), i.clip();
}
function $s(i, t) {
  const { line: e, target: s, property: n, color: o, scale: r } = t, a = Gl(e, s, n);
  for (const { source: l, target: c, start: h, end: d } of a) {
    const { style: { backgroundColor: u = o } = {} } = l, f = s !== !0;
    i.save(), i.fillStyle = u, gc(i, r, f && Pi(n, h, d)), i.beginPath();
    const g = !!e.pathSegment(i, l);
    let p;
    if (f) {
      g ? i.closePath() : Ys(i, s, d, n);
      const m = !!s.pathSegment(i, c, { move: g, reverse: !0 });
      p = g && m, p || Ys(i, s, h, n);
    }
    i.closePath(), i.fill(p ? "evenodd" : "nonzero"), i.restore();
  }
}
function gc(i, t, e) {
  const { top: s, bottom: n } = t.chart.chartArea, { property: o, start: r, end: a } = e || {};
  o === "x" && (i.beginPath(), i.rect(r, s, a - r, n - s), i.clip());
}
function Ys(i, t, e, s) {
  const n = t.interpolate(e, s);
  n && i.lineTo(n.x, n.y);
}
var ho = {
  id: "filler",
  afterDatasetsUpdate(i, t, e) {
    const s = (i.data.datasets || []).length, n = [];
    let o, r, a, l;
    for (r = 0; r < s; ++r)
      o = i.getDatasetMeta(r), a = o.dataset, l = null, a && a.options && a instanceof gt && (l = {
        visible: i.isDatasetVisible(r),
        index: r,
        fill: Ql(a, r, s),
        chart: i,
        axis: o.controller.options.indexAxis,
        scale: o.vScale,
        line: a
      }), o.$filler = l, n.push(l);
    for (r = 0; r < s; ++r)
      l = n[r], !(!l || l.fill === !1) && (l.fill = Jl(n, r, e.propagate));
  },
  beforeDraw(i, t, e) {
    const s = e.drawTime === "beforeDraw", n = i.getSortedVisibleDatasetMetas(), o = i.chartArea;
    for (let r = n.length - 1; r >= 0; --r) {
      const a = n[r].$filler;
      a && (a.line.updateControlPoints(o, a.axis), s && a.fill && mi(i.ctx, a, o));
    }
  },
  beforeDatasetsDraw(i, t, e) {
    if (e.drawTime !== "beforeDatasetsDraw")
      return;
    const s = i.getSortedVisibleDatasetMetas();
    for (let n = s.length - 1; n >= 0; --n) {
      const o = s[n].$filler;
      Hs(o) && mi(i.ctx, o, i.chartArea);
    }
  },
  beforeDatasetDraw(i, t, e) {
    const s = t.meta.$filler;
    !Hs(s) || e.drawTime !== "beforeDatasetDraw" || mi(i.ctx, s, i.chartArea);
  },
  defaults: {
    propagate: !0,
    drawTime: "beforeDatasetDraw"
  }
};
const Xs = (i, t) => {
  let { boxHeight: e = t, boxWidth: s = t } = i;
  return i.usePointStyle && (e = Math.min(e, t), s = i.pointStyleWidth || Math.min(s, t)), {
    boxWidth: s,
    boxHeight: e,
    itemHeight: Math.max(t, e)
  };
}, pc = (i, t) => i !== null && t !== null && i.datasetIndex === t.datasetIndex && i.index === t.index;
class Us extends st {
  constructor(t) {
    super(), this._added = !1, this.legendHitBoxes = [], this._hoveredItem = null, this.doughnutMode = !1, this.chart = t.chart, this.options = t.options, this.ctx = t.ctx, this.legendItems = void 0, this.columnSizes = void 0, this.lineWidths = void 0, this.maxHeight = void 0, this.maxWidth = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.height = void 0, this.width = void 0, this._margins = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0;
  }
  update(t, e, s) {
    this.maxWidth = t, this.maxHeight = e, this._margins = s, this.setDimensions(), this.buildLabels(), this.fit();
  }
  setDimensions() {
    this.isHorizontal() ? (this.width = this.maxWidth, this.left = this._margins.left, this.right = this.width) : (this.height = this.maxHeight, this.top = this._margins.top, this.bottom = this.height);
  }
  buildLabels() {
    const t = this.options.labels || {};
    let e = I(t.generateLabels, [this.chart], this) || [];
    t.filter && (e = e.filter((s) => t.filter(s, this.chart.data))), t.sort && (e = e.sort((s, n) => t.sort(s, n, this.chart.data))), this.options.reverse && e.reverse(), this.legendItems = e;
  }
  fit() {
    const { options: t, ctx: e } = this;
    if (!t.display) {
      this.width = this.height = 0;
      return;
    }
    const s = t.labels, n = $(s.font), o = n.size, r = this._computeTitleHeight(), { boxWidth: a, itemHeight: l } = Xs(s, o);
    let c, h;
    e.font = n.string, this.isHorizontal() ? (c = this.maxWidth, h = this._fitRows(r, o, a, l) + 10) : (h = this.maxHeight, c = this._fitCols(r, o, a, l) + 10), this.width = Math.min(c, t.maxWidth || this.maxWidth), this.height = Math.min(h, t.maxHeight || this.maxHeight);
  }
  _fitRows(t, e, s, n) {
    const { ctx: o, maxWidth: r, options: { labels: { padding: a } } } = this, l = this.legendHitBoxes = [], c = this.lineWidths = [0], h = n + a;
    let d = t;
    o.textAlign = "left", o.textBaseline = "middle";
    let u = -1, f = -h;
    return this.legendItems.forEach((g, p) => {
      const m = s + e / 2 + o.measureText(g.text).width;
      (p === 0 || c[c.length - 1] + m + 2 * a > r) && (d += h, c[c.length - (p > 0 ? 0 : 1)] = 0, f += h, u++), l[p] = { left: 0, top: f, row: u, width: m, height: n }, c[c.length - 1] += m + a;
    }), d;
  }
  _fitCols(t, e, s, n) {
    const { ctx: o, maxHeight: r, options: { labels: { padding: a } } } = this, l = this.legendHitBoxes = [], c = this.columnSizes = [], h = r - t;
    let d = a, u = 0, f = 0, g = 0, p = 0;
    return this.legendItems.forEach((m, b) => {
      const x = s + e / 2 + o.measureText(m.text).width;
      b > 0 && f + n + 2 * a > h && (d += u + a, c.push({ width: u, height: f }), g += u + a, p++, u = f = 0), l[b] = { left: g, top: f, col: p, width: x, height: n }, u = Math.max(u, x), f += n + a;
    }), d += u, c.push({ width: u, height: f }), d;
  }
  adjustHitBoxes() {
    if (!this.options.display)
      return;
    const t = this._computeTitleHeight(), { legendHitBoxes: e, options: { align: s, labels: { padding: n }, rtl: o } } = this, r = zt(o, this.left, this.width);
    if (this.isHorizontal()) {
      let a = 0, l = U(s, this.left + n, this.right - this.lineWidths[a]);
      for (const c of e)
        a !== c.row && (a = c.row, l = U(s, this.left + n, this.right - this.lineWidths[a])), c.top += this.top + t + n, c.left = r.leftForLtr(r.x(l), c.width), l += c.width + n;
    } else {
      let a = 0, l = U(s, this.top + t + n, this.bottom - this.columnSizes[a].height);
      for (const c of e)
        c.col !== a && (a = c.col, l = U(s, this.top + t + n, this.bottom - this.columnSizes[a].height)), c.top = l, c.left += this.left + n, c.left = r.leftForLtr(r.x(c.left), c.width), l += c.height + n;
    }
  }
  isHorizontal() {
    return this.options.position === "top" || this.options.position === "bottom";
  }
  draw() {
    if (this.options.display) {
      const t = this.ctx;
      Xe(t, this), this._draw(), Ue(t);
    }
  }
  _draw() {
    const { options: t, columnSizes: e, lineWidths: s, ctx: n } = this, { align: o, labels: r } = t, a = O.color, l = zt(t.rtl, this.left, this.width), c = $(r.font), { color: h, padding: d } = r, u = c.size, f = u / 2;
    let g;
    this.drawTitle(), n.textAlign = l.textAlign("left"), n.textBaseline = "middle", n.lineWidth = 0.5, n.font = c.string;
    const { boxWidth: p, boxHeight: m, itemHeight: b } = Xs(r, u), x = function(k, S, w) {
      if (isNaN(p) || p <= 0 || isNaN(m) || m < 0)
        return;
      n.save();
      const L = C(w.lineWidth, 1);
      if (n.fillStyle = C(w.fillStyle, a), n.lineCap = C(w.lineCap, "butt"), n.lineDashOffset = C(w.lineDashOffset, 0), n.lineJoin = C(w.lineJoin, "miter"), n.lineWidth = L, n.strokeStyle = C(w.strokeStyle, a), n.setLineDash(C(w.lineDash, [])), r.usePointStyle) {
        const R = {
          radius: m * Math.SQRT2 / 2,
          pointStyle: w.pointStyle,
          rotation: w.rotation,
          borderWidth: L
        }, A = l.xPlus(k, p / 2), H = S + f;
        Mn(n, R, A, H, r.pointStyleWidth && p);
      } else {
        const R = S + Math.max((u - m) / 2, 0), A = l.leftForLtr(k, p), H = Dt(w.borderRadius);
        n.beginPath(), Object.values(H).some((q) => q !== 0) ? ae(n, {
          x: A,
          y: R,
          w: p,
          h: m,
          radius: H
        }) : n.rect(A, R, p, m), n.fill(), L !== 0 && n.stroke();
      }
      n.restore();
    }, v = function(k, S, w) {
      Tt(n, w.text, k, S + b / 2, c, {
        strikethrough: w.hidden,
        textAlign: l.textAlign(w.textAlign)
      });
    }, y = this.isHorizontal(), _ = this._computeTitleHeight();
    y ? g = {
      x: U(o, this.left + d, this.right - s[0]),
      y: this.top + d + _,
      line: 0
    } : g = {
      x: this.left + d,
      y: U(o, this.top + _ + d, this.bottom - e[0].height),
      line: 0
    }, Tn(this.ctx, t.textDirection);
    const M = b + d;
    this.legendItems.forEach((k, S) => {
      n.strokeStyle = k.fontColor || h, n.fillStyle = k.fontColor || h;
      const w = n.measureText(k.text).width, L = l.textAlign(k.textAlign || (k.textAlign = r.textAlign)), R = p + f + w;
      let A = g.x, H = g.y;
      l.setWidth(this.width), y ? S > 0 && A + R + d > this.right && (H = g.y += M, g.line++, A = g.x = U(o, this.left + d, this.right - s[g.line])) : S > 0 && H + M > this.bottom && (A = g.x = A + e[g.line].width + d, g.line++, H = g.y = U(o, this.top + _ + d, this.bottom - e[g.line].height));
      const q = l.x(A);
      x(q, H, k), A = Io(L, A + p + f, y ? A + R : this.right, t.rtl), v(l.x(A), H, k), y ? g.x += R + d : g.y += M;
    }), Ln(this.ctx, t.textDirection);
  }
  drawTitle() {
    const t = this.options, e = t.title, s = $(e.font), n = K(e.padding);
    if (!e.display)
      return;
    const o = zt(t.rtl, this.left, this.width), r = this.ctx, a = e.position, l = s.size / 2, c = n.top + l;
    let h, d = this.left, u = this.width;
    if (this.isHorizontal())
      u = Math.max(...this.lineWidths), h = this.top + c, d = U(t.align, d, this.right - u);
    else {
      const g = this.columnSizes.reduce((p, m) => Math.max(p, m.height), 0);
      h = c + U(t.align, this.top, this.bottom - g - t.labels.padding - this._computeTitleHeight());
    }
    const f = U(a, d, d + u);
    r.textAlign = o.textAlign(Li(a)), r.textBaseline = "middle", r.strokeStyle = e.color, r.fillStyle = e.color, r.font = s.string, Tt(r, e.text, f, h, s);
  }
  _computeTitleHeight() {
    const t = this.options.title, e = $(t.font), s = K(t.padding);
    return t.display ? e.lineHeight + s.height : 0;
  }
  _getLegendItemAt(t, e) {
    let s, n, o;
    if (ut(t, this.left, this.right) && ut(e, this.top, this.bottom)) {
      for (o = this.legendHitBoxes, s = 0; s < o.length; ++s)
        if (n = o[s], ut(t, n.left, n.left + n.width) && ut(e, n.top, n.top + n.height))
          return this.legendItems[s];
    }
    return null;
  }
  handleEvent(t) {
    const e = this.options;
    if (!mc(t.type, e))
      return;
    const s = this._getLegendItemAt(t.x, t.y);
    if (t.type === "mousemove" || t.type === "mouseout") {
      const n = this._hoveredItem, o = pc(n, s);
      n && !o && I(e.onLeave, [t, n, this], this), this._hoveredItem = s, s && !o && I(e.onHover, [t, s, this], this);
    } else
      s && I(e.onClick, [t, s, this], this);
  }
}
function mc(i, t) {
  return !!((i === "mousemove" || i === "mouseout") && (t.onHover || t.onLeave) || t.onClick && (i === "click" || i === "mouseup"));
}
var uo = {
  id: "legend",
  _element: Us,
  start(i, t, e) {
    const s = i.legend = new Us({ ctx: i.ctx, options: e, chart: i });
    X.configure(i, s, e), X.addBox(i, s);
  },
  stop(i) {
    X.removeBox(i, i.legend), delete i.legend;
  },
  beforeUpdate(i, t, e) {
    const s = i.legend;
    X.configure(i, s, e), s.options = e;
  },
  afterUpdate(i) {
    const t = i.legend;
    t.buildLabels(), t.adjustHitBoxes();
  },
  afterEvent(i, t) {
    t.replay || i.legend.handleEvent(t.event);
  },
  defaults: {
    display: !0,
    position: "top",
    align: "center",
    fullSize: !0,
    reverse: !1,
    weight: 1e3,
    onClick(i, t, e) {
      const s = t.datasetIndex, n = e.chart;
      n.isDatasetVisible(s) ? (n.hide(s), t.hidden = !0) : (n.show(s), t.hidden = !1);
    },
    onHover: null,
    onLeave: null,
    labels: {
      color: (i) => i.chart.options.color,
      boxWidth: 40,
      padding: 10,
      generateLabels(i) {
        const t = i.data.datasets, { labels: { usePointStyle: e, pointStyle: s, textAlign: n, color: o } } = i.legend.options;
        return i._getSortedDatasetMetas().map((r) => {
          const a = r.controller.getStyle(e ? 0 : void 0), l = K(a.borderWidth);
          return {
            text: t[r.index].label,
            fillStyle: a.backgroundColor,
            fontColor: o,
            hidden: !r.visible,
            lineCap: a.borderCapStyle,
            lineDash: a.borderDash,
            lineDashOffset: a.borderDashOffset,
            lineJoin: a.borderJoinStyle,
            lineWidth: (l.width + l.height) / 4,
            strokeStyle: a.borderColor,
            pointStyle: s || a.pointStyle,
            rotation: a.rotation,
            textAlign: n || a.textAlign,
            borderRadius: 0,
            datasetIndex: r.index
          };
        }, this);
      }
    },
    title: {
      color: (i) => i.chart.options.color,
      display: !1,
      position: "center",
      text: ""
    }
  },
  descriptors: {
    _scriptable: (i) => !i.startsWith("on"),
    labels: {
      _scriptable: (i) => !["generateLabels", "filter", "sort"].includes(i)
    }
  }
};
class Yi extends st {
  constructor(t) {
    super(), this.chart = t.chart, this.options = t.options, this.ctx = t.ctx, this._padding = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0;
  }
  update(t, e) {
    const s = this.options;
    if (this.left = 0, this.top = 0, !s.display) {
      this.width = this.height = this.right = this.bottom = 0;
      return;
    }
    this.width = this.right = t, this.height = this.bottom = e;
    const n = z(s.text) ? s.text.length : 1;
    this._padding = K(s.padding);
    const o = n * $(s.font).lineHeight + this._padding.height;
    this.isHorizontal() ? this.height = o : this.width = o;
  }
  isHorizontal() {
    const t = this.options.position;
    return t === "top" || t === "bottom";
  }
  _drawArgs(t) {
    const { top: e, left: s, bottom: n, right: o, options: r } = this, a = r.align;
    let l = 0, c, h, d;
    return this.isHorizontal() ? (h = U(a, s, o), d = e + t, c = o - s) : (r.position === "left" ? (h = s + t, d = U(a, n, e), l = B * -0.5) : (h = o - t, d = U(a, e, n), l = B * 0.5), c = n - e), { titleX: h, titleY: d, maxWidth: c, rotation: l };
  }
  draw() {
    const t = this.ctx, e = this.options;
    if (!e.display)
      return;
    const s = $(e.font), o = s.lineHeight / 2 + this._padding.top, { titleX: r, titleY: a, maxWidth: l, rotation: c } = this._drawArgs(o);
    Tt(t, e.text, 0, 0, s, {
      color: e.color,
      maxWidth: l,
      rotation: c,
      textAlign: Li(e.align),
      textBaseline: "middle",
      translation: [r, a]
    });
  }
}
function bc(i, t) {
  const e = new Yi({
    ctx: i.ctx,
    options: t,
    chart: i
  });
  X.configure(i, e, t), X.addBox(i, e), i.titleBlock = e;
}
var fo = {
  id: "title",
  _element: Yi,
  start(i, t, e) {
    bc(i, e);
  },
  stop(i) {
    const t = i.titleBlock;
    X.removeBox(i, t), delete i.titleBlock;
  },
  beforeUpdate(i, t, e) {
    const s = i.titleBlock;
    X.configure(i, s, e), s.options = e;
  },
  defaults: {
    align: "center",
    display: !1,
    font: {
      weight: "bold"
    },
    fullSize: !0,
    padding: 10,
    position: "top",
    text: "",
    weight: 2e3
  },
  defaultRoutes: {
    color: "color"
  },
  descriptors: {
    _scriptable: !0,
    _indexable: !1
  }
};
const Re = /* @__PURE__ */ new WeakMap();
var go = {
  id: "subtitle",
  start(i, t, e) {
    const s = new Yi({
      ctx: i.ctx,
      options: e,
      chart: i
    });
    X.configure(i, s, e), X.addBox(i, s), Re.set(i, s);
  },
  stop(i) {
    X.removeBox(i, Re.get(i)), Re.delete(i);
  },
  beforeUpdate(i, t, e) {
    const s = Re.get(i);
    X.configure(i, s, e), s.options = e;
  },
  defaults: {
    align: "center",
    display: !1,
    font: {
      weight: "normal"
    },
    fullSize: !0,
    padding: 0,
    position: "top",
    text: "",
    weight: 1500
  },
  defaultRoutes: {
    color: "color"
  },
  descriptors: {
    _scriptable: !0,
    _indexable: !1
  }
};
const se = {
  average(i) {
    if (!i.length)
      return !1;
    let t, e, s = 0, n = 0, o = 0;
    for (t = 0, e = i.length; t < e; ++t) {
      const r = i[t].element;
      if (r && r.hasValue()) {
        const a = r.tooltipPosition();
        s += a.x, n += a.y, ++o;
      }
    }
    return {
      x: s / o,
      y: n / o
    };
  },
  nearest(i, t) {
    if (!i.length)
      return !1;
    let e = t.x, s = t.y, n = Number.POSITIVE_INFINITY, o, r, a;
    for (o = 0, r = i.length; o < r; ++o) {
      const l = i[o].element;
      if (l && l.hasValue()) {
        const c = l.getCenterPoint(), h = bi(t, c);
        h < n && (n = h, a = l);
      }
    }
    if (a) {
      const l = a.tooltipPosition();
      e = l.x, s = l.y;
    }
    return {
      x: e,
      y: s
    };
  }
};
function rt(i, t) {
  return t && (z(t) ? Array.prototype.push.apply(i, t) : i.push(t)), i;
}
function ht(i) {
  return (typeof i == "string" || i instanceof String) && i.indexOf(`
`) > -1 ? i.split(`
`) : i;
}
function xc(i, t) {
  const { element: e, datasetIndex: s, index: n } = t, o = i.getDatasetMeta(s).controller, { label: r, value: a } = o.getLabelAndValue(n);
  return {
    chart: i,
    label: r,
    parsed: o.getParsed(n),
    raw: i.data.datasets[s].data[n],
    formattedValue: a,
    dataset: o.getDataset(),
    dataIndex: n,
    datasetIndex: s,
    element: e
  };
}
function Ks(i, t) {
  const e = i.chart.ctx, { body: s, footer: n, title: o } = i, { boxWidth: r, boxHeight: a } = t, l = $(t.bodyFont), c = $(t.titleFont), h = $(t.footerFont), d = o.length, u = n.length, f = s.length, g = K(t.padding);
  let p = g.height, m = 0, b = s.reduce((y, _) => y + _.before.length + _.lines.length + _.after.length, 0);
  if (b += i.beforeBody.length + i.afterBody.length, d && (p += d * c.lineHeight + (d - 1) * t.titleSpacing + t.titleMarginBottom), b) {
    const y = t.displayColors ? Math.max(a, l.lineHeight) : l.lineHeight;
    p += f * y + (b - f) * l.lineHeight + (b - 1) * t.bodySpacing;
  }
  u && (p += t.footerMarginTop + u * h.lineHeight + (u - 1) * t.footerSpacing);
  let x = 0;
  const v = function(y) {
    m = Math.max(m, e.measureText(y).width + x);
  };
  return e.save(), e.font = c.string, E(i.title, v), e.font = l.string, E(i.beforeBody.concat(i.afterBody), v), x = t.displayColors ? r + 2 + t.boxPadding : 0, E(s, (y) => {
    E(y.before, v), E(y.lines, v), E(y.after, v);
  }), x = 0, e.font = h.string, E(i.footer, v), e.restore(), m += g.width, { width: m, height: p };
}
function _c(i, t) {
  const { y: e, height: s } = t;
  return e < s / 2 ? "top" : e > i.height - s / 2 ? "bottom" : "center";
}
function yc(i, t, e, s) {
  const { x: n, width: o } = s, r = e.caretSize + e.caretPadding;
  if (i === "left" && n + o + r > t.width || i === "right" && n - o - r < 0)
    return !0;
}
function vc(i, t, e, s) {
  const { x: n, width: o } = e, { width: r, chartArea: { left: a, right: l } } = i;
  let c = "center";
  return s === "center" ? c = n <= (a + l) / 2 ? "left" : "right" : n <= o / 2 ? c = "left" : n >= r - o / 2 && (c = "right"), yc(c, i, t, e) && (c = "center"), c;
}
function qs(i, t, e) {
  const s = e.yAlign || t.yAlign || _c(i, e);
  return {
    xAlign: e.xAlign || t.xAlign || vc(i, t, e, s),
    yAlign: s
  };
}
function Mc(i, t) {
  let { x: e, width: s } = i;
  return t === "right" ? e -= s : t === "center" && (e -= s / 2), e;
}
function kc(i, t, e) {
  let { y: s, height: n } = i;
  return t === "top" ? s += e : t === "bottom" ? s -= n + e : s -= n / 2, s;
}
function Gs(i, t, e, s) {
  const { caretSize: n, caretPadding: o, cornerRadius: r } = i, { xAlign: a, yAlign: l } = e, c = n + o, { topLeft: h, topRight: d, bottomLeft: u, bottomRight: f } = Dt(r);
  let g = Mc(t, a);
  const p = kc(t, l, c);
  return l === "center" ? a === "left" ? g += c : a === "right" && (g -= c) : a === "left" ? g -= Math.max(h, u) + n : a === "right" && (g += Math.max(d, f) + n), {
    x: Y(g, 0, s.width - t.width),
    y: Y(p, 0, s.height - t.height)
  };
}
function Ee(i, t, e) {
  const s = K(e.padding);
  return t === "center" ? i.x + i.width / 2 : t === "right" ? i.x + i.width - s.right : i.x + s.left;
}
function Zs(i) {
  return rt([], ht(i));
}
function wc(i, t, e) {
  return vt(i, {
    tooltip: t,
    tooltipItems: e,
    type: "tooltip"
  });
}
function Js(i, t) {
  const e = t && t.dataset && t.dataset.tooltip && t.dataset.tooltip.callbacks;
  return e ? i.override(e) : i;
}
class Ci extends st {
  constructor(t) {
    super(), this.opacity = 0, this._active = [], this._eventPosition = void 0, this._size = void 0, this._cachedAnimations = void 0, this._tooltipItems = [], this.$animations = void 0, this.$context = void 0, this.chart = t.chart || t._chart, this._chart = this.chart, this.options = t.options, this.dataPoints = void 0, this.title = void 0, this.beforeBody = void 0, this.body = void 0, this.afterBody = void 0, this.footer = void 0, this.xAlign = void 0, this.yAlign = void 0, this.x = void 0, this.y = void 0, this.height = void 0, this.width = void 0, this.caretX = void 0, this.caretY = void 0, this.labelColors = void 0, this.labelPointStyles = void 0, this.labelTextColors = void 0;
  }
  initialize(t) {
    this.options = t, this._cachedAnimations = void 0, this.$context = void 0;
  }
  _resolveAnimations() {
    const t = this._cachedAnimations;
    if (t)
      return t;
    const e = this.chart, s = this.options.setContext(this.getContext()), n = s.enabled && e.options.animation && s.animations, o = new Ni(this.chart, n);
    return n._cacheable && (this._cachedAnimations = Object.freeze(o)), o;
  }
  getContext() {
    return this.$context || (this.$context = wc(this.chart.getContext(), this, this._tooltipItems));
  }
  getTitle(t, e) {
    const { callbacks: s } = e, n = s.beforeTitle.apply(this, [t]), o = s.title.apply(this, [t]), r = s.afterTitle.apply(this, [t]);
    let a = [];
    return a = rt(a, ht(n)), a = rt(a, ht(o)), a = rt(a, ht(r)), a;
  }
  getBeforeBody(t, e) {
    return Zs(e.callbacks.beforeBody.apply(this, [t]));
  }
  getBody(t, e) {
    const { callbacks: s } = e, n = [];
    return E(t, (o) => {
      const r = {
        before: [],
        lines: [],
        after: []
      }, a = Js(s, o);
      rt(r.before, ht(a.beforeLabel.call(this, o))), rt(r.lines, a.label.call(this, o)), rt(r.after, ht(a.afterLabel.call(this, o))), n.push(r);
    }), n;
  }
  getAfterBody(t, e) {
    return Zs(e.callbacks.afterBody.apply(this, [t]));
  }
  getFooter(t, e) {
    const { callbacks: s } = e, n = s.beforeFooter.apply(this, [t]), o = s.footer.apply(this, [t]), r = s.afterFooter.apply(this, [t]);
    let a = [];
    return a = rt(a, ht(n)), a = rt(a, ht(o)), a = rt(a, ht(r)), a;
  }
  _createItems(t) {
    const e = this._active, s = this.chart.data, n = [], o = [], r = [];
    let a = [], l, c;
    for (l = 0, c = e.length; l < c; ++l)
      a.push(xc(this.chart, e[l]));
    return t.filter && (a = a.filter((h, d, u) => t.filter(h, d, u, s))), t.itemSort && (a = a.sort((h, d) => t.itemSort(h, d, s))), E(a, (h) => {
      const d = Js(t.callbacks, h);
      n.push(d.labelColor.call(this, h)), o.push(d.labelPointStyle.call(this, h)), r.push(d.labelTextColor.call(this, h));
    }), this.labelColors = n, this.labelPointStyles = o, this.labelTextColors = r, this.dataPoints = a, a;
  }
  update(t, e) {
    const s = this.options.setContext(this.getContext()), n = this._active;
    let o, r = [];
    if (!n.length)
      this.opacity !== 0 && (o = {
        opacity: 0
      });
    else {
      const a = se[s.position].call(this, n, this._eventPosition);
      r = this._createItems(s), this.title = this.getTitle(r, s), this.beforeBody = this.getBeforeBody(r, s), this.body = this.getBody(r, s), this.afterBody = this.getAfterBody(r, s), this.footer = this.getFooter(r, s);
      const l = this._size = Ks(this, s), c = Object.assign({}, a, l), h = qs(this.chart, s, c), d = Gs(s, c, h, this.chart);
      this.xAlign = h.xAlign, this.yAlign = h.yAlign, o = {
        opacity: 1,
        x: d.x,
        y: d.y,
        width: l.width,
        height: l.height,
        caretX: a.x,
        caretY: a.y
      };
    }
    this._tooltipItems = r, this.$context = void 0, o && this._resolveAnimations().update(this, o), t && s.external && s.external.call(this, { chart: this.chart, tooltip: this, replay: e });
  }
  drawCaret(t, e, s, n) {
    const o = this.getCaretPosition(t, s, n);
    e.lineTo(o.x1, o.y1), e.lineTo(o.x2, o.y2), e.lineTo(o.x3, o.y3);
  }
  getCaretPosition(t, e, s) {
    const { xAlign: n, yAlign: o } = this, { caretSize: r, cornerRadius: a } = s, { topLeft: l, topRight: c, bottomLeft: h, bottomRight: d } = Dt(a), { x: u, y: f } = t, { width: g, height: p } = e;
    let m, b, x, v, y, _;
    return o === "center" ? (y = f + p / 2, n === "left" ? (m = u, b = m - r, v = y + r, _ = y - r) : (m = u + g, b = m + r, v = y - r, _ = y + r), x = m) : (n === "left" ? b = u + Math.max(l, h) + r : n === "right" ? b = u + g - Math.max(c, d) - r : b = this.caretX, o === "top" ? (v = f, y = v - r, m = b - r, x = b + r) : (v = f + p, y = v + r, m = b + r, x = b - r), _ = v), { x1: m, x2: b, x3: x, y1: v, y2: y, y3: _ };
  }
  drawTitle(t, e, s) {
    const n = this.title, o = n.length;
    let r, a, l;
    if (o) {
      const c = zt(s.rtl, this.x, this.width);
      for (t.x = Ee(this, s.titleAlign, s), e.textAlign = c.textAlign(s.titleAlign), e.textBaseline = "middle", r = $(s.titleFont), a = s.titleSpacing, e.fillStyle = s.titleColor, e.font = r.string, l = 0; l < o; ++l)
        e.fillText(n[l], c.x(t.x), t.y + r.lineHeight / 2), t.y += r.lineHeight + a, l + 1 === o && (t.y += s.titleMarginBottom - a);
    }
  }
  _drawColorBox(t, e, s, n, o) {
    const r = this.labelColors[s], a = this.labelPointStyles[s], { boxHeight: l, boxWidth: c, boxPadding: h } = o, d = $(o.bodyFont), u = Ee(this, "left", o), f = n.x(u), g = l < d.lineHeight ? (d.lineHeight - l) / 2 : 0, p = e.y + g;
    if (o.usePointStyle) {
      const m = {
        radius: Math.min(c, l) / 2,
        pointStyle: a.pointStyle,
        rotation: a.rotation,
        borderWidth: 1
      }, b = n.leftForLtr(f, c) + c / 2, x = p + l / 2;
      t.strokeStyle = o.multiKeyBackground, t.fillStyle = o.multiKeyBackground, yi(t, m, b, x), t.strokeStyle = r.borderColor, t.fillStyle = r.backgroundColor, yi(t, m, b, x);
    } else {
      t.lineWidth = D(r.borderWidth) ? Math.max(...Object.values(r.borderWidth)) : r.borderWidth || 1, t.strokeStyle = r.borderColor, t.setLineDash(r.borderDash || []), t.lineDashOffset = r.borderDashOffset || 0;
      const m = n.leftForLtr(f, c - h), b = n.leftForLtr(n.xPlus(f, 1), c - h - 2), x = Dt(r.borderRadius);
      Object.values(x).some((v) => v !== 0) ? (t.beginPath(), t.fillStyle = o.multiKeyBackground, ae(t, {
        x: m,
        y: p,
        w: c,
        h: l,
        radius: x
      }), t.fill(), t.stroke(), t.fillStyle = r.backgroundColor, t.beginPath(), ae(t, {
        x: b,
        y: p + 1,
        w: c - 2,
        h: l - 2,
        radius: x
      }), t.fill()) : (t.fillStyle = o.multiKeyBackground, t.fillRect(m, p, c, l), t.strokeRect(m, p, c, l), t.fillStyle = r.backgroundColor, t.fillRect(b, p + 1, c - 2, l - 2));
    }
    t.fillStyle = this.labelTextColors[s];
  }
  drawBody(t, e, s) {
    const { body: n } = this, { bodySpacing: o, bodyAlign: r, displayColors: a, boxHeight: l, boxWidth: c, boxPadding: h } = s, d = $(s.bodyFont);
    let u = d.lineHeight, f = 0;
    const g = zt(s.rtl, this.x, this.width), p = function(S) {
      e.fillText(S, g.x(t.x + f), t.y + u / 2), t.y += u + o;
    }, m = g.textAlign(r);
    let b, x, v, y, _, M, k;
    for (e.textAlign = r, e.textBaseline = "middle", e.font = d.string, t.x = Ee(this, m, s), e.fillStyle = s.bodyColor, E(this.beforeBody, p), f = a && m !== "right" ? r === "center" ? c / 2 + h : c + 2 + h : 0, y = 0, M = n.length; y < M; ++y) {
      for (b = n[y], x = this.labelTextColors[y], e.fillStyle = x, E(b.before, p), v = b.lines, a && v.length && (this._drawColorBox(e, t, y, g, s), u = Math.max(d.lineHeight, l)), _ = 0, k = v.length; _ < k; ++_)
        p(v[_]), u = d.lineHeight;
      E(b.after, p);
    }
    f = 0, u = d.lineHeight, E(this.afterBody, p), t.y -= o;
  }
  drawFooter(t, e, s) {
    const n = this.footer, o = n.length;
    let r, a;
    if (o) {
      const l = zt(s.rtl, this.x, this.width);
      for (t.x = Ee(this, s.footerAlign, s), t.y += s.footerMarginTop, e.textAlign = l.textAlign(s.footerAlign), e.textBaseline = "middle", r = $(s.footerFont), e.fillStyle = s.footerColor, e.font = r.string, a = 0; a < o; ++a)
        e.fillText(n[a], l.x(t.x), t.y + r.lineHeight / 2), t.y += r.lineHeight + s.footerSpacing;
    }
  }
  drawBackground(t, e, s, n) {
    const { xAlign: o, yAlign: r } = this, { x: a, y: l } = t, { width: c, height: h } = s, { topLeft: d, topRight: u, bottomLeft: f, bottomRight: g } = Dt(n.cornerRadius);
    e.fillStyle = n.backgroundColor, e.strokeStyle = n.borderColor, e.lineWidth = n.borderWidth, e.beginPath(), e.moveTo(a + d, l), r === "top" && this.drawCaret(t, e, s, n), e.lineTo(a + c - u, l), e.quadraticCurveTo(a + c, l, a + c, l + u), r === "center" && o === "right" && this.drawCaret(t, e, s, n), e.lineTo(a + c, l + h - g), e.quadraticCurveTo(a + c, l + h, a + c - g, l + h), r === "bottom" && this.drawCaret(t, e, s, n), e.lineTo(a + f, l + h), e.quadraticCurveTo(a, l + h, a, l + h - f), r === "center" && o === "left" && this.drawCaret(t, e, s, n), e.lineTo(a, l + d), e.quadraticCurveTo(a, l, a + d, l), e.closePath(), e.fill(), n.borderWidth > 0 && e.stroke();
  }
  _updateAnimationTarget(t) {
    const e = this.chart, s = this.$animations, n = s && s.x, o = s && s.y;
    if (n || o) {
      const r = se[t.position].call(this, this._active, this._eventPosition);
      if (!r)
        return;
      const a = this._size = Ks(this, t), l = Object.assign({}, r, this._size), c = qs(e, t, l), h = Gs(t, l, c, e);
      (n._to !== h.x || o._to !== h.y) && (this.xAlign = c.xAlign, this.yAlign = c.yAlign, this.width = a.width, this.height = a.height, this.caretX = r.x, this.caretY = r.y, this._resolveAnimations().update(this, h));
    }
  }
  _willRender() {
    return !!this.opacity;
  }
  draw(t) {
    const e = this.options.setContext(this.getContext());
    let s = this.opacity;
    if (!s)
      return;
    this._updateAnimationTarget(e);
    const n = {
      width: this.width,
      height: this.height
    }, o = {
      x: this.x,
      y: this.y
    };
    s = Math.abs(s) < 1e-3 ? 0 : s;
    const r = K(e.padding), a = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
    e.enabled && a && (t.save(), t.globalAlpha = s, this.drawBackground(o, t, n, e), Tn(t, e.textDirection), o.y += r.top, this.drawTitle(o, t, e), this.drawBody(o, t, e), this.drawFooter(o, t, e), Ln(t, e.textDirection), t.restore());
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(t, e) {
    const s = this._active, n = t.map(({ datasetIndex: a, index: l }) => {
      const c = this.chart.getDatasetMeta(a);
      if (!c)
        throw new Error("Cannot find a dataset at index " + a);
      return {
        datasetIndex: a,
        element: c.data[l],
        index: l
      };
    }), o = !ze(s, n), r = this._positionChanged(n, e);
    (o || r) && (this._active = n, this._eventPosition = e, this._ignoreReplayEvents = !0, this.update(!0));
  }
  handleEvent(t, e, s = !0) {
    if (e && this._ignoreReplayEvents)
      return !1;
    this._ignoreReplayEvents = !1;
    const n = this.options, o = this._active || [], r = this._getActiveElements(t, o, e, s), a = this._positionChanged(r, t), l = e || !ze(r, o) || a;
    return l && (this._active = r, (n.enabled || n.external) && (this._eventPosition = {
      x: t.x,
      y: t.y
    }, this.update(!0, e))), l;
  }
  _getActiveElements(t, e, s, n) {
    const o = this.options;
    if (t.type === "mouseout")
      return [];
    if (!n)
      return e;
    const r = this.chart.getElementsAtEventForMode(t, o.mode, o, s);
    return o.reverse && r.reverse(), r;
  }
  _positionChanged(t, e) {
    const { caretX: s, caretY: n, options: o } = this, r = se[o.position].call(this, t, e);
    return r !== !1 && (s !== r.x || n !== r.y);
  }
}
Ci.positioners = se;
var po = {
  id: "tooltip",
  _element: Ci,
  positioners: se,
  afterInit(i, t, e) {
    e && (i.tooltip = new Ci({ chart: i, options: e }));
  },
  beforeUpdate(i, t, e) {
    i.tooltip && i.tooltip.initialize(e);
  },
  reset(i, t, e) {
    i.tooltip && i.tooltip.initialize(e);
  },
  afterDraw(i) {
    const t = i.tooltip;
    if (t && t._willRender()) {
      const e = {
        tooltip: t
      };
      if (i.notifyPlugins("beforeTooltipDraw", e) === !1)
        return;
      t.draw(i.ctx), i.notifyPlugins("afterTooltipDraw", e);
    }
  },
  afterEvent(i, t) {
    if (i.tooltip) {
      const e = t.replay;
      i.tooltip.handleEvent(t.event, e, t.inChartArea) && (t.changed = !0);
    }
  },
  defaults: {
    enabled: !0,
    external: null,
    position: "average",
    backgroundColor: "rgba(0,0,0,0.8)",
    titleColor: "#fff",
    titleFont: {
      weight: "bold"
    },
    titleSpacing: 2,
    titleMarginBottom: 6,
    titleAlign: "left",
    bodyColor: "#fff",
    bodySpacing: 2,
    bodyFont: {},
    bodyAlign: "left",
    footerColor: "#fff",
    footerSpacing: 2,
    footerMarginTop: 6,
    footerFont: {
      weight: "bold"
    },
    footerAlign: "left",
    padding: 6,
    caretPadding: 2,
    caretSize: 5,
    cornerRadius: 6,
    boxHeight: (i, t) => t.bodyFont.size,
    boxWidth: (i, t) => t.bodyFont.size,
    multiKeyBackground: "#fff",
    displayColors: !0,
    boxPadding: 0,
    borderColor: "rgba(0,0,0,0)",
    borderWidth: 0,
    animation: {
      duration: 400,
      easing: "easeOutQuart"
    },
    animations: {
      numbers: {
        type: "number",
        properties: ["x", "y", "width", "height", "caretX", "caretY"]
      },
      opacity: {
        easing: "linear",
        duration: 200
      }
    },
    callbacks: {
      beforeTitle: ct,
      title(i) {
        if (i.length > 0) {
          const t = i[0], e = t.chart.data.labels, s = e ? e.length : 0;
          if (this && this.options && this.options.mode === "dataset")
            return t.dataset.label || "";
          if (t.label)
            return t.label;
          if (s > 0 && t.dataIndex < s)
            return e[t.dataIndex];
        }
        return "";
      },
      afterTitle: ct,
      beforeBody: ct,
      beforeLabel: ct,
      label(i) {
        if (this && this.options && this.options.mode === "dataset")
          return i.label + ": " + i.formattedValue || i.formattedValue;
        let t = i.dataset.label || "";
        t && (t += ": ");
        const e = i.formattedValue;
        return T(e) || (t += e), t;
      },
      labelColor(i) {
        const e = i.chart.getDatasetMeta(i.datasetIndex).controller.getStyle(i.dataIndex);
        return {
          borderColor: e.borderColor,
          backgroundColor: e.backgroundColor,
          borderWidth: e.borderWidth,
          borderDash: e.borderDash,
          borderDashOffset: e.borderDashOffset,
          borderRadius: 0
        };
      },
      labelTextColor() {
        return this.options.bodyColor;
      },
      labelPointStyle(i) {
        const e = i.chart.getDatasetMeta(i.datasetIndex).controller.getStyle(i.dataIndex);
        return {
          pointStyle: e.pointStyle,
          rotation: e.rotation
        };
      },
      afterLabel: ct,
      afterBody: ct,
      beforeFooter: ct,
      footer: ct,
      afterFooter: ct
    }
  },
  defaultRoutes: {
    bodyFont: "font",
    footerFont: "font",
    titleFont: "font"
  },
  descriptors: {
    _scriptable: (i) => i !== "filter" && i !== "itemSort" && i !== "external",
    _indexable: !1,
    callbacks: {
      _scriptable: !1,
      _indexable: !1
    },
    animation: {
      _fallback: !1
    },
    animations: {
      _fallback: "animation"
    }
  },
  additionalOptionScopes: ["interaction"]
}, mo = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  Decimation: ao,
  Filler: ho,
  Legend: uo,
  SubTitle: go,
  Title: fo,
  Tooltip: po
});
const Sc = (i, t, e, s) => (typeof t == "string" ? (e = i.push(t) - 1, s.unshift({ index: e, label: t })) : isNaN(t) && (e = null), e);
function Pc(i, t, e, s) {
  const n = i.indexOf(t);
  if (n === -1)
    return Sc(i, t, e, s);
  const o = i.lastIndexOf(t);
  return n !== o ? e : n;
}
const Cc = (i, t) => i === null ? null : Y(Math.round(i), 0, t);
class ce extends Mt {
  constructor(t) {
    super(t), this._startValue = void 0, this._valueRange = 0, this._addedLabels = [];
  }
  init(t) {
    const e = this._addedLabels;
    if (e.length) {
      const s = this.getLabels();
      for (const { index: n, label: o } of e)
        s[n] === o && s.splice(n, 1);
      this._addedLabels = [];
    }
    super.init(t);
  }
  parse(t, e) {
    if (T(t))
      return null;
    const s = this.getLabels();
    return e = isFinite(e) && s[e] === t ? e : Pc(s, t, C(e, t), this._addedLabels), Cc(e, s.length - 1);
  }
  determineDataLimits() {
    const { minDefined: t, maxDefined: e } = this.getUserBounds();
    let { min: s, max: n } = this.getMinMax(!0);
    this.options.bounds === "ticks" && (t || (s = 0), e || (n = this.getLabels().length - 1)), this.min = s, this.max = n;
  }
  buildTicks() {
    const t = this.min, e = this.max, s = this.options.offset, n = [];
    let o = this.getLabels();
    o = t === 0 && e === o.length - 1 ? o : o.slice(t, e + 1), this._valueRange = Math.max(o.length - (s ? 0 : 1), 1), this._startValue = this.min - (s ? 0.5 : 0);
    for (let r = t; r <= e; r++)
      n.push({ value: r });
    return n;
  }
  getLabelForValue(t) {
    const e = this.getLabels();
    return t >= 0 && t < e.length ? e[t] : t;
  }
  configure() {
    super.configure(), this.isHorizontal() || (this._reversePixels = !this._reversePixels);
  }
  getPixelForValue(t) {
    return typeof t != "number" && (t = this.parse(t)), t === null ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange);
  }
  getPixelForTick(t) {
    const e = this.ticks;
    return t < 0 || t > e.length - 1 ? null : this.getPixelForValue(e[t].value);
  }
  getValueForPixel(t) {
    return Math.round(this._startValue + this.getDecimalForPixel(t) * this._valueRange);
  }
  getBasePixel() {
    return this.bottom;
  }
}
ce.id = "category";
ce.defaults = {
  ticks: {
    callback: ce.prototype.getLabelForValue
  }
};
function Dc(i, t) {
  const e = [], { bounds: n, step: o, min: r, max: a, precision: l, count: c, maxTicks: h, maxDigits: d, includeBounds: u } = i, f = o || 1, g = h - 1, { min: p, max: m } = t, b = !T(r), x = !T(a), v = !T(c), y = (m - p) / (d + 1);
  let _ = qi((m - p) / g / f) * f, M, k, S, w;
  if (_ < 1e-14 && !b && !x)
    return [{ value: p }, { value: m }];
  w = Math.ceil(m / _) - Math.floor(p / _), w > g && (_ = qi(w * _ / g / f) * f), T(l) || (M = Math.pow(10, l), _ = Math.ceil(_ * M) / M), n === "ticks" ? (k = Math.floor(p / _) * _, S = Math.ceil(m / _) * _) : (k = p, S = m), b && x && o && Oo((a - r) / o, _ / 1e3) ? (w = Math.round(Math.min((a - r) / _, h)), _ = (a - r) / w, k = r, S = a) : v ? (k = b ? r : k, S = x ? a : S, w = c - 1, _ = (S - k) / w) : (w = (S - k) / _, te(w, Math.round(w), _ / 1e3) ? w = Math.round(w) : w = Math.ceil(w));
  const L = Math.max(
    Gi(_),
    Gi(k)
  );
  M = Math.pow(10, T(l) ? L : l), k = Math.round(k * M) / M, S = Math.round(S * M) / M;
  let R = 0;
  for (b && (u && k !== r ? (e.push({ value: r }), k < r && R++, te(Math.round((k + R * _) * M) / M, r, Qs(r, y, i)) && R++) : k < r && R++); R < w; ++R)
    e.push({ value: Math.round((k + R * _) * M) / M });
  return x && u && S !== a ? e.length && te(e[e.length - 1].value, a, Qs(a, y, i)) ? e[e.length - 1].value = a : e.push({ value: a }) : (!x || S === a) && e.push({ value: S }), e;
}
function Qs(i, t, { horizontal: e, minRotation: s }) {
  const n = nt(s), o = (e ? Math.sin(n) : Math.cos(n)) || 1e-3, r = 0.75 * t * ("" + i).length;
  return Math.min(t / o, r);
}
class Ye extends Mt {
  constructor(t) {
    super(t), this.start = void 0, this.end = void 0, this._startValue = void 0, this._endValue = void 0, this._valueRange = 0;
  }
  parse(t, e) {
    return T(t) || (typeof t == "number" || t instanceof Number) && !isFinite(+t) ? null : +t;
  }
  handleTickRangeOptions() {
    const { beginAtZero: t } = this.options, { minDefined: e, maxDefined: s } = this.getUserBounds();
    let { min: n, max: o } = this;
    const r = (l) => n = e ? n : l, a = (l) => o = s ? o : l;
    if (t) {
      const l = lt(n), c = lt(o);
      l < 0 && c < 0 ? a(0) : l > 0 && c > 0 && r(0);
    }
    if (n === o) {
      let l = 1;
      (o >= Number.MAX_SAFE_INTEGER || n <= Number.MIN_SAFE_INTEGER) && (l = Math.abs(o * 0.05)), a(o + l), t || r(n - l);
    }
    this.min = n, this.max = o;
  }
  getTickLimit() {
    const t = this.options.ticks;
    let { maxTicksLimit: e, stepSize: s } = t, n;
    return s ? (n = Math.ceil(this.max / s) - Math.floor(this.min / s) + 1, n > 1e3 && (console.warn(`scales.${this.id}.ticks.stepSize: ${s} would result generating up to ${n} ticks. Limiting to 1000.`), n = 1e3)) : (n = this.computeTickLimit(), e = e || 11), e && (n = Math.min(e, n)), n;
  }
  computeTickLimit() {
    return Number.POSITIVE_INFINITY;
  }
  buildTicks() {
    const t = this.options, e = t.ticks;
    let s = this.getTickLimit();
    s = Math.max(2, s);
    const n = {
      maxTicks: s,
      bounds: t.bounds,
      min: t.min,
      max: t.max,
      precision: e.precision,
      step: e.stepSize,
      count: e.count,
      maxDigits: this._maxDigits(),
      horizontal: this.isHorizontal(),
      minRotation: e.minRotation || 0,
      includeBounds: e.includeBounds !== !1
    }, o = this._range || this, r = Dc(n, o);
    return t.bounds === "ticks" && cn(r, this, "value"), t.reverse ? (r.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), r;
  }
  configure() {
    const t = this.ticks;
    let e = this.min, s = this.max;
    if (super.configure(), this.options.offset && t.length) {
      const n = (s - e) / Math.max(t.length - 1, 1) / 2;
      e -= n, s += n;
    }
    this._startValue = e, this._endValue = s, this._valueRange = s - e;
  }
  getLabelForValue(t) {
    return de(t, this.chart.options.locale, this.options.ticks.format);
  }
}
class Ge extends Ye {
  determineDataLimits() {
    const { min: t, max: e } = this.getMinMax(!0);
    this.min = N(t) ? t : 0, this.max = N(e) ? e : 1, this.handleTickRangeOptions();
  }
  computeTickLimit() {
    const t = this.isHorizontal(), e = t ? this.width : this.height, s = nt(this.options.ticks.minRotation), n = (t ? Math.sin(s) : Math.cos(s)) || 1e-3, o = this._resolveTickFontOptions(0);
    return Math.ceil(e / Math.min(40, o.lineHeight / n));
  }
  getPixelForValue(t) {
    return t === null ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange);
  }
  getValueForPixel(t) {
    return this._startValue + this.getDecimalForPixel(t) * this._valueRange;
  }
}
Ge.id = "linear";
Ge.defaults = {
  ticks: {
    callback: be.formatters.numeric
  }
};
function tn(i) {
  return i / Math.pow(10, Math.floor(tt(i))) === 1;
}
function Oc(i, t) {
  const e = Math.floor(tt(t.max)), s = Math.ceil(t.max / Math.pow(10, e)), n = [];
  let o = Q(i.min, Math.pow(10, Math.floor(tt(t.min)))), r = Math.floor(tt(o)), a = Math.floor(o / Math.pow(10, r)), l = r < 0 ? Math.pow(10, Math.abs(r)) : 1;
  do
    n.push({ value: o, major: tn(o) }), ++a, a === 10 && (a = 1, ++r, l = r >= 0 ? 1 : l), o = Math.round(a * Math.pow(10, r) * l) / l;
  while (r < e || r === e && a < s);
  const c = Q(i.max, o);
  return n.push({ value: c, major: tn(o) }), n;
}
class Ze extends Mt {
  constructor(t) {
    super(t), this.start = void 0, this.end = void 0, this._startValue = void 0, this._valueRange = 0;
  }
  parse(t, e) {
    const s = Ye.prototype.parse.apply(this, [t, e]);
    if (s === 0) {
      this._zero = !0;
      return;
    }
    return N(s) && s > 0 ? s : null;
  }
  determineDataLimits() {
    const { min: t, max: e } = this.getMinMax(!0);
    this.min = N(t) ? Math.max(0, t) : null, this.max = N(e) ? Math.max(0, e) : null, this.options.beginAtZero && (this._zero = !0), this.handleTickRangeOptions();
  }
  handleTickRangeOptions() {
    const { minDefined: t, maxDefined: e } = this.getUserBounds();
    let s = this.min, n = this.max;
    const o = (l) => s = t ? s : l, r = (l) => n = e ? n : l, a = (l, c) => Math.pow(10, Math.floor(tt(l)) + c);
    s === n && (s <= 0 ? (o(1), r(10)) : (o(a(s, -1)), r(a(n, 1)))), s <= 0 && o(a(n, -1)), n <= 0 && r(a(s, 1)), this._zero && this.min !== this._suggestedMin && s === a(this.min, 0) && o(a(s, -1)), this.min = s, this.max = n;
  }
  buildTicks() {
    const t = this.options, e = {
      min: this._userMin,
      max: this._userMax
    }, s = Oc(e, this);
    return t.bounds === "ticks" && cn(s, this, "value"), t.reverse ? (s.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), s;
  }
  getLabelForValue(t) {
    return t === void 0 ? "0" : de(t, this.chart.options.locale, this.options.ticks.format);
  }
  configure() {
    const t = this.min;
    super.configure(), this._startValue = tt(t), this._valueRange = tt(this.max) - tt(t);
  }
  getPixelForValue(t) {
    return (t === void 0 || t === 0) && (t = this.min), t === null || isNaN(t) ? NaN : this.getPixelForDecimal(t === this.min ? 0 : (tt(t) - this._startValue) / this._valueRange);
  }
  getValueForPixel(t) {
    const e = this.getDecimalForPixel(t);
    return Math.pow(10, this._startValue + e * this._valueRange);
  }
}
Ze.id = "logarithmic";
Ze.defaults = {
  ticks: {
    callback: be.formatters.logarithmic,
    major: {
      enabled: !0
    }
  }
};
function Di(i) {
  const t = i.ticks;
  if (t.display && i.display) {
    const e = K(t.backdropPadding);
    return C(t.font && t.font.size, O.font.size) + e.height;
  }
  return 0;
}
function Ac(i, t, e) {
  return e = z(e) ? e : [e], {
    w: ar(i, t.string, e),
    h: e.length * t.lineHeight
  };
}
function en(i, t, e, s, n) {
  return i === s || i === n ? {
    start: t - e / 2,
    end: t + e / 2
  } : i < s || i > n ? {
    start: t - e,
    end: t
  } : {
    start: t,
    end: t + e
  };
}
function Tc(i) {
  const t = {
    l: i.left + i._padding.left,
    r: i.right - i._padding.right,
    t: i.top + i._padding.top,
    b: i.bottom - i._padding.bottom
  }, e = Object.assign({}, t), s = [], n = [], o = i._pointLabels.length, r = i.options.pointLabels, a = r.centerPointLabels ? B / o : 0;
  for (let l = 0; l < o; l++) {
    const c = r.setContext(i.getPointLabelContext(l));
    n[l] = c.padding;
    const h = i.getPointPosition(l, i.drawingArea + n[l], a), d = $(c.font), u = Ac(i.ctx, d, i._pointLabels[l]);
    s[l] = u;
    const f = Z(i.getIndexAngle(l) + a), g = Math.round(Ai(f)), p = en(g, h.x, u.w, 0, 180), m = en(g, h.y, u.h, 90, 270);
    Lc(e, t, f, p, m);
  }
  i.setCenterPoint(
    t.l - e.l,
    e.r - t.r,
    t.t - e.t,
    e.b - t.b
  ), i._pointLabelItems = Rc(i, s, n);
}
function Lc(i, t, e, s, n) {
  const o = Math.abs(Math.sin(e)), r = Math.abs(Math.cos(e));
  let a = 0, l = 0;
  s.start < t.l ? (a = (t.l - s.start) / o, i.l = Math.min(i.l, t.l - a)) : s.end > t.r && (a = (s.end - t.r) / o, i.r = Math.max(i.r, t.r + a)), n.start < t.t ? (l = (t.t - n.start) / r, i.t = Math.min(i.t, t.t - l)) : n.end > t.b && (l = (n.end - t.b) / r, i.b = Math.max(i.b, t.b + l));
}
function Rc(i, t, e) {
  const s = [], n = i._pointLabels.length, o = i.options, r = Di(o) / 2, a = i.drawingArea, l = o.pointLabels.centerPointLabels ? B / n : 0;
  for (let c = 0; c < n; c++) {
    const h = i.getPointPosition(c, a + r + e[c], l), d = Math.round(Ai(Z(h.angle + V))), u = t[c], f = Ic(h.y, u.h, d), g = Ec(d), p = Fc(h.x, u.w, g);
    s.push({
      x: h.x,
      y: f,
      textAlign: g,
      left: p,
      top: f,
      right: p + u.w,
      bottom: f + u.h
    });
  }
  return s;
}
function Ec(i) {
  return i === 0 || i === 180 ? "center" : i < 180 ? "left" : "right";
}
function Fc(i, t, e) {
  return e === "right" ? i -= t : e === "center" && (i -= t / 2), i;
}
function Ic(i, t, e) {
  return e === 90 || e === 270 ? i -= t / 2 : (e > 270 || e < 90) && (i -= t), i;
}
function zc(i, t) {
  const { ctx: e, options: { pointLabels: s } } = i;
  for (let n = t - 1; n >= 0; n--) {
    const o = s.setContext(i.getPointLabelContext(n)), r = $(o.font), { x: a, y: l, textAlign: c, left: h, top: d, right: u, bottom: f } = i._pointLabelItems[n], { backdropColor: g } = o;
    if (!T(g)) {
      const p = Dt(o.borderRadius), m = K(o.backdropPadding);
      e.fillStyle = g;
      const b = h - m.left, x = d - m.top, v = u - h + m.width, y = f - d + m.height;
      Object.values(p).some((_) => _ !== 0) ? (e.beginPath(), ae(e, {
        x: b,
        y: x,
        w: v,
        h: y,
        radius: p
      }), e.fill()) : e.fillRect(b, x, v, y);
    }
    Tt(
      e,
      i._pointLabels[n],
      a,
      l + r.lineHeight / 2,
      r,
      {
        color: o.color,
        textAlign: c,
        textBaseline: "middle"
      }
    );
  }
}
function bo(i, t, e, s) {
  const { ctx: n } = i;
  if (e)
    n.arc(i.xCenter, i.yCenter, t, 0, F);
  else {
    let o = i.getPointPosition(0, t);
    n.moveTo(o.x, o.y);
    for (let r = 1; r < s; r++)
      o = i.getPointPosition(r, t), n.lineTo(o.x, o.y);
  }
}
function Bc(i, t, e, s) {
  const n = i.ctx, o = t.circular, { color: r, lineWidth: a } = t;
  !o && !s || !r || !a || e < 0 || (n.save(), n.strokeStyle = r, n.lineWidth = a, n.setLineDash(t.borderDash), n.lineDashOffset = t.borderDashOffset, n.beginPath(), bo(i, e, o, s), n.closePath(), n.stroke(), n.restore());
}
function Vc(i, t, e) {
  return vt(i, {
    label: e,
    index: t,
    type: "pointLabel"
  });
}
class Nt extends Ye {
  constructor(t) {
    super(t), this.xCenter = void 0, this.yCenter = void 0, this.drawingArea = void 0, this._pointLabels = [], this._pointLabelItems = [];
  }
  setDimensions() {
    const t = this._padding = K(Di(this.options) / 2), e = this.width = this.maxWidth - t.width, s = this.height = this.maxHeight - t.height;
    this.xCenter = Math.floor(this.left + e / 2 + t.left), this.yCenter = Math.floor(this.top + s / 2 + t.top), this.drawingArea = Math.floor(Math.min(e, s) / 2);
  }
  determineDataLimits() {
    const { min: t, max: e } = this.getMinMax(!1);
    this.min = N(t) && !isNaN(t) ? t : 0, this.max = N(e) && !isNaN(e) ? e : 0, this.handleTickRangeOptions();
  }
  computeTickLimit() {
    return Math.ceil(this.drawingArea / Di(this.options));
  }
  generateTickLabels(t) {
    Ye.prototype.generateTickLabels.call(this, t), this._pointLabels = this.getLabels().map((e, s) => {
      const n = I(this.options.pointLabels.callback, [e, s], this);
      return n || n === 0 ? n : "";
    }).filter((e, s) => this.chart.getDataVisibility(s));
  }
  fit() {
    const t = this.options;
    t.display && t.pointLabels.display ? Tc(this) : this.setCenterPoint(0, 0, 0, 0);
  }
  setCenterPoint(t, e, s, n) {
    this.xCenter += Math.floor((t - e) / 2), this.yCenter += Math.floor((s - n) / 2), this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(t, e, s, n));
  }
  getIndexAngle(t) {
    const e = F / (this._pointLabels.length || 1), s = this.options.startAngle || 0;
    return Z(t * e + nt(s));
  }
  getDistanceFromCenterForValue(t) {
    if (T(t))
      return NaN;
    const e = this.drawingArea / (this.max - this.min);
    return this.options.reverse ? (this.max - t) * e : (t - this.min) * e;
  }
  getValueForDistanceFromCenter(t) {
    if (T(t))
      return NaN;
    const e = t / (this.drawingArea / (this.max - this.min));
    return this.options.reverse ? this.max - e : this.min + e;
  }
  getPointLabelContext(t) {
    const e = this._pointLabels || [];
    if (t >= 0 && t < e.length) {
      const s = e[t];
      return Vc(this.getContext(), t, s);
    }
  }
  getPointPosition(t, e, s = 0) {
    const n = this.getIndexAngle(t) - V + s;
    return {
      x: Math.cos(n) * e + this.xCenter,
      y: Math.sin(n) * e + this.yCenter,
      angle: n
    };
  }
  getPointPositionForValue(t, e) {
    return this.getPointPosition(t, this.getDistanceFromCenterForValue(e));
  }
  getBasePosition(t) {
    return this.getPointPositionForValue(t || 0, this.getBaseValue());
  }
  getPointLabelPosition(t) {
    const { left: e, top: s, right: n, bottom: o } = this._pointLabelItems[t];
    return {
      left: e,
      top: s,
      right: n,
      bottom: o
    };
  }
  drawBackground() {
    const { backgroundColor: t, grid: { circular: e } } = this.options;
    if (t) {
      const s = this.ctx;
      s.save(), s.beginPath(), bo(this, this.getDistanceFromCenterForValue(this._endValue), e, this._pointLabels.length), s.closePath(), s.fillStyle = t, s.fill(), s.restore();
    }
  }
  drawGrid() {
    const t = this.ctx, e = this.options, { angleLines: s, grid: n } = e, o = this._pointLabels.length;
    let r, a, l;
    if (e.pointLabels.display && zc(this, o), n.display && this.ticks.forEach((c, h) => {
      if (h !== 0) {
        a = this.getDistanceFromCenterForValue(c.value);
        const d = n.setContext(this.getContext(h - 1));
        Bc(this, d, a, o);
      }
    }), s.display) {
      for (t.save(), r = o - 1; r >= 0; r--) {
        const c = s.setContext(this.getPointLabelContext(r)), { color: h, lineWidth: d } = c;
        !d || !h || (t.lineWidth = d, t.strokeStyle = h, t.setLineDash(c.borderDash), t.lineDashOffset = c.borderDashOffset, a = this.getDistanceFromCenterForValue(e.ticks.reverse ? this.min : this.max), l = this.getPointPosition(r, a), t.beginPath(), t.moveTo(this.xCenter, this.yCenter), t.lineTo(l.x, l.y), t.stroke());
      }
      t.restore();
    }
  }
  drawBorder() {
  }
  drawLabels() {
    const t = this.ctx, e = this.options, s = e.ticks;
    if (!s.display)
      return;
    const n = this.getIndexAngle(0);
    let o, r;
    t.save(), t.translate(this.xCenter, this.yCenter), t.rotate(n), t.textAlign = "center", t.textBaseline = "middle", this.ticks.forEach((a, l) => {
      if (l === 0 && !e.reverse)
        return;
      const c = s.setContext(this.getContext(l)), h = $(c.font);
      if (o = this.getDistanceFromCenterForValue(this.ticks[l].value), c.showLabelBackdrop) {
        t.font = h.string, r = t.measureText(a.label).width, t.fillStyle = c.backdropColor;
        const d = K(c.backdropPadding);
        t.fillRect(
          -r / 2 - d.left,
          -o - h.size / 2 - d.top,
          r + d.width,
          h.size + d.height
        );
      }
      Tt(t, a.label, 0, -o, h, {
        color: c.color
      });
    }), t.restore();
  }
  drawTitle() {
  }
}
Nt.id = "radialLinear";
Nt.defaults = {
  display: !0,
  animate: !0,
  position: "chartArea",
  angleLines: {
    display: !0,
    lineWidth: 1,
    borderDash: [],
    borderDashOffset: 0
  },
  grid: {
    circular: !1
  },
  startAngle: 0,
  ticks: {
    showLabelBackdrop: !0,
    callback: be.formatters.numeric
  },
  pointLabels: {
    backdropColor: void 0,
    backdropPadding: 2,
    display: !0,
    font: {
      size: 10
    },
    callback(i) {
      return i;
    },
    padding: 5,
    centerPointLabels: !1
  }
};
Nt.defaultRoutes = {
  "angleLines.color": "borderColor",
  "pointLabels.color": "color",
  "ticks.color": "color"
};
Nt.descriptors = {
  angleLines: {
    _fallback: "grid"
  }
};
const Je = {
  millisecond: { common: !0, size: 1, steps: 1e3 },
  second: { common: !0, size: 1e3, steps: 60 },
  minute: { common: !0, size: 6e4, steps: 60 },
  hour: { common: !0, size: 36e5, steps: 24 },
  day: { common: !0, size: 864e5, steps: 30 },
  week: { common: !1, size: 6048e5, steps: 4 },
  month: { common: !0, size: 2628e6, steps: 12 },
  quarter: { common: !1, size: 7884e6, steps: 4 },
  year: { common: !0, size: 3154e7 }
}, G = Object.keys(Je);
function Wc(i, t) {
  return i - t;
}
function sn(i, t) {
  if (T(t))
    return null;
  const e = i._adapter, { parser: s, round: n, isoWeekday: o } = i._parseOpts;
  let r = t;
  return typeof s == "function" && (r = s(r)), N(r) || (r = typeof s == "string" ? e.parse(r, s) : e.parse(r)), r === null ? null : (n && (r = n === "week" && (Bt(o) || o === !0) ? e.startOf(r, "isoWeek", o) : e.startOf(r, n)), +r);
}
function nn(i, t, e, s) {
  const n = G.length;
  for (let o = G.indexOf(i); o < n - 1; ++o) {
    const r = Je[G[o]], a = r.steps ? r.steps : Number.MAX_SAFE_INTEGER;
    if (r.common && Math.ceil((e - t) / (a * r.size)) <= s)
      return G[o];
  }
  return G[n - 1];
}
function Nc(i, t, e, s, n) {
  for (let o = G.length - 1; o >= G.indexOf(e); o--) {
    const r = G[o];
    if (Je[r].common && i._adapter.diff(n, s, r) >= t - 1)
      return r;
  }
  return G[e ? G.indexOf(e) : 0];
}
function Hc(i) {
  for (let t = G.indexOf(i) + 1, e = G.length; t < e; ++t)
    if (Je[G[t]].common)
      return G[t];
}
function on(i, t, e) {
  if (!e)
    i[t] = !0;
  else if (e.length) {
    const { lo: s, hi: n } = Ti(e, t), o = e[s] >= t ? e[s] : e[n];
    i[o] = !0;
  }
}
function jc(i, t, e, s) {
  const n = i._adapter, o = +n.startOf(t[0].value, s), r = t[t.length - 1].value;
  let a, l;
  for (a = o; a <= r; a = +n.add(a, 1, s))
    l = e[a], l >= 0 && (t[l].major = !0);
  return t;
}
function rn(i, t, e) {
  const s = [], n = {}, o = t.length;
  let r, a;
  for (r = 0; r < o; ++r)
    a = t[r], n[a] = r, s.push({
      value: a,
      major: !1
    });
  return o === 0 || !e ? s : jc(i, s, n, e);
}
class Ht extends Mt {
  constructor(t) {
    super(t), this._cache = {
      data: [],
      labels: [],
      all: []
    }, this._unit = "day", this._majorUnit = void 0, this._offsets = {}, this._normalized = !1, this._parseOpts = void 0;
  }
  init(t, e) {
    const s = t.time || (t.time = {}), n = this._adapter = new Nn._date(t.adapters.date);
    n.init(e), Qt(s.displayFormats, n.formats()), this._parseOpts = {
      parser: s.parser,
      round: s.round,
      isoWeekday: s.isoWeekday
    }, super.init(t), this._normalized = e.normalized;
  }
  parse(t, e) {
    return t === void 0 ? null : sn(this, t);
  }
  beforeLayout() {
    super.beforeLayout(), this._cache = {
      data: [],
      labels: [],
      all: []
    };
  }
  determineDataLimits() {
    const t = this.options, e = this._adapter, s = t.time.unit || "day";
    let { min: n, max: o, minDefined: r, maxDefined: a } = this.getUserBounds();
    function l(c) {
      !r && !isNaN(c.min) && (n = Math.min(n, c.min)), !a && !isNaN(c.max) && (o = Math.max(o, c.max));
    }
    (!r || !a) && (l(this._getLabelBounds()), (t.bounds !== "ticks" || t.ticks.source !== "labels") && l(this.getMinMax(!1))), n = N(n) && !isNaN(n) ? n : +e.startOf(Date.now(), s), o = N(o) && !isNaN(o) ? o : +e.endOf(Date.now(), s) + 1, this.min = Math.min(n, o - 1), this.max = Math.max(n + 1, o);
  }
  _getLabelBounds() {
    const t = this.getLabelTimestamps();
    let e = Number.POSITIVE_INFINITY, s = Number.NEGATIVE_INFINITY;
    return t.length && (e = t[0], s = t[t.length - 1]), { min: e, max: s };
  }
  buildTicks() {
    const t = this.options, e = t.time, s = t.ticks, n = s.source === "labels" ? this.getLabelTimestamps() : this._generate();
    t.bounds === "ticks" && n.length && (this.min = this._userMin || n[0], this.max = this._userMax || n[n.length - 1]);
    const o = this.min, r = this.max, a = Ro(n, o, r);
    return this._unit = e.unit || (s.autoSkip ? nn(e.minUnit, this.min, this.max, this._getLabelCapacity(o)) : Nc(this, a.length, e.minUnit, this.min, this.max)), this._majorUnit = !s.major.enabled || this._unit === "year" ? void 0 : Hc(this._unit), this.initOffsets(n), t.reverse && a.reverse(), rn(this, a, this._majorUnit);
  }
  afterAutoSkip() {
    this.options.offsetAfterAutoskip && this.initOffsets(this.ticks.map((t) => +t.value));
  }
  initOffsets(t) {
    let e = 0, s = 0, n, o;
    this.options.offset && t.length && (n = this.getDecimalForValue(t[0]), t.length === 1 ? e = 1 - n : e = (this.getDecimalForValue(t[1]) - n) / 2, o = this.getDecimalForValue(t[t.length - 1]), t.length === 1 ? s = o : s = (o - this.getDecimalForValue(t[t.length - 2])) / 2);
    const r = t.length < 3 ? 0.5 : 0.25;
    e = Y(e, 0, r), s = Y(s, 0, r), this._offsets = { start: e, end: s, factor: 1 / (e + 1 + s) };
  }
  _generate() {
    const t = this._adapter, e = this.min, s = this.max, n = this.options, o = n.time, r = o.unit || nn(o.minUnit, e, s, this._getLabelCapacity(e)), a = C(o.stepSize, 1), l = r === "week" ? o.isoWeekday : !1, c = Bt(l) || l === !0, h = {};
    let d = e, u, f;
    if (c && (d = +t.startOf(d, "isoWeek", l)), d = +t.startOf(d, c ? "day" : r), t.diff(s, e, r) > 1e5 * a)
      throw new Error(e + " and " + s + " are too far apart with stepSize of " + a + " " + r);
    const g = n.ticks.source === "data" && this.getDataTimestamps();
    for (u = d, f = 0; u < s; u = +t.add(u, a, r), f++)
      on(h, u, g);
    return (u === s || n.bounds === "ticks" || f === 1) && on(h, u, g), Object.keys(h).sort((p, m) => p - m).map((p) => +p);
  }
  getLabelForValue(t) {
    const e = this._adapter, s = this.options.time;
    return s.tooltipFormat ? e.format(t, s.tooltipFormat) : e.format(t, s.displayFormats.datetime);
  }
  _tickFormatFunction(t, e, s, n) {
    const o = this.options, r = o.time.displayFormats, a = this._unit, l = this._majorUnit, c = a && r[a], h = l && r[l], d = s[e], u = l && h && d && d.major, f = this._adapter.format(t, n || (u ? h : c)), g = o.ticks.callback;
    return g ? I(g, [f, e, s], this) : f;
  }
  generateTickLabels(t) {
    let e, s, n;
    for (e = 0, s = t.length; e < s; ++e)
      n = t[e], n.label = this._tickFormatFunction(n.value, e, t);
  }
  getDecimalForValue(t) {
    return t === null ? NaN : (t - this.min) / (this.max - this.min);
  }
  getPixelForValue(t) {
    const e = this._offsets, s = this.getDecimalForValue(t);
    return this.getPixelForDecimal((e.start + s) * e.factor);
  }
  getValueForPixel(t) {
    const e = this._offsets, s = this.getDecimalForPixel(t) / e.factor - e.end;
    return this.min + s * (this.max - this.min);
  }
  _getLabelSize(t) {
    const e = this.options.ticks, s = this.ctx.measureText(t).width, n = nt(this.isHorizontal() ? e.maxRotation : e.minRotation), o = Math.cos(n), r = Math.sin(n), a = this._resolveTickFontOptions(0).size;
    return {
      w: s * o + a * r,
      h: s * r + a * o
    };
  }
  _getLabelCapacity(t) {
    const e = this.options.time, s = e.displayFormats, n = s[e.unit] || s.millisecond, o = this._tickFormatFunction(t, 0, rn(this, [t], this._majorUnit), n), r = this._getLabelSize(o), a = Math.floor(this.isHorizontal() ? this.width / r.w : this.height / r.h) - 1;
    return a > 0 ? a : 1;
  }
  getDataTimestamps() {
    let t = this._cache.data || [], e, s;
    if (t.length)
      return t;
    const n = this.getMatchingVisibleMetas();
    if (this._normalized && n.length)
      return this._cache.data = n[0].controller.getAllParsedValues(this);
    for (e = 0, s = n.length; e < s; ++e)
      t = t.concat(n[e].controller.getAllParsedValues(this));
    return this._cache.data = this.normalize(t);
  }
  getLabelTimestamps() {
    const t = this._cache.labels || [];
    let e, s;
    if (t.length)
      return t;
    const n = this.getLabels();
    for (e = 0, s = n.length; e < s; ++e)
      t.push(sn(this, n[e]));
    return this._cache.labels = this._normalized ? t : this.normalize(t);
  }
  normalize(t) {
    return un(t.sort(Wc));
  }
}
Ht.id = "time";
Ht.defaults = {
  bounds: "data",
  adapters: {},
  time: {
    parser: !1,
    unit: !1,
    round: !1,
    isoWeekday: !1,
    minUnit: "millisecond",
    displayFormats: {}
  },
  ticks: {
    source: "auto",
    major: {
      enabled: !1
    }
  }
};
function Fe(i, t, e) {
  let s = 0, n = i.length - 1, o, r, a, l;
  e ? (t >= i[s].pos && t <= i[n].pos && ({ lo: s, hi: n } = ft(i, "pos", t)), { pos: o, time: a } = i[s], { pos: r, time: l } = i[n]) : (t >= i[s].time && t <= i[n].time && ({ lo: s, hi: n } = ft(i, "time", t)), { time: o, pos: a } = i[s], { time: r, pos: l } = i[n]);
  const c = r - o;
  return c ? a + (l - a) * (t - o) / c : a;
}
class Qe extends Ht {
  constructor(t) {
    super(t), this._table = [], this._minPos = void 0, this._tableRange = void 0;
  }
  initOffsets() {
    const t = this._getTimestampsForTable(), e = this._table = this.buildLookupTable(t);
    this._minPos = Fe(e, this.min), this._tableRange = Fe(e, this.max) - this._minPos, super.initOffsets(t);
  }
  buildLookupTable(t) {
    const { min: e, max: s } = this, n = [], o = [];
    let r, a, l, c, h;
    for (r = 0, a = t.length; r < a; ++r)
      c = t[r], c >= e && c <= s && n.push(c);
    if (n.length < 2)
      return [
        { time: e, pos: 0 },
        { time: s, pos: 1 }
      ];
    for (r = 0, a = n.length; r < a; ++r)
      h = n[r + 1], l = n[r - 1], c = n[r], Math.round((h + l) / 2) !== c && o.push({ time: c, pos: r / (a - 1) });
    return o;
  }
  _getTimestampsForTable() {
    let t = this._cache.all || [];
    if (t.length)
      return t;
    const e = this.getDataTimestamps(), s = this.getLabelTimestamps();
    return e.length && s.length ? t = this.normalize(e.concat(s)) : t = e.length ? e : s, t = this._cache.all = t, t;
  }
  getDecimalForValue(t) {
    return (Fe(this._table, t) - this._minPos) / this._tableRange;
  }
  getValueForPixel(t) {
    const e = this._offsets, s = this.getDecimalForPixel(t) / e.factor - e.end;
    return Fe(this._table, s * this._tableRange + this._minPos, !0);
  }
}
Qe.id = "timeseries";
Qe.defaults = Ht.defaults;
var xo = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  CategoryScale: ce,
  LinearScale: Ge,
  LogarithmicScale: Ze,
  RadialLinearScale: Nt,
  TimeScale: Ht,
  TimeSeriesScale: Qe
});
const $c = [
  Wn,
  oo,
  mo,
  xo
], Yc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Animation: In,
  Animations: Ni,
  ArcElement: ye,
  BarController: ue,
  BarElement: Me,
  BasePlatform: Hi,
  BasicPlatform: Yn,
  BubbleController: fe,
  CategoryScale: ce,
  Chart: ji,
  DatasetController: it,
  Decimation: ao,
  DomPlatform: Kn,
  DoughnutController: Lt,
  Element: st,
  Filler: ho,
  Interaction: Hn,
  Legend: uo,
  LineController: ge,
  LineElement: gt,
  LinearScale: Ge,
  LogarithmicScale: Ze,
  PieController: qe,
  PointElement: ve,
  PolarAreaController: pe,
  RadarController: me,
  RadialLinearScale: Nt,
  Scale: Mt,
  ScatterController: xe,
  SubTitle: go,
  Ticks: be,
  TimeScale: Ht,
  TimeSeriesScale: Qe,
  Title: fo,
  Tooltip: po,
  _adapters: Nn,
  _detectPlatform: qn,
  animator: at,
  controllers: Wn,
  defaults: O,
  elements: oo,
  layouts: X,
  plugins: mo,
  registerables: $c,
  registry: ot,
  scales: xo
}, Symbol.toStringTag, { value: "Module" }));

//# sourceMappingURL=chart.es.js.map


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfdHctZWxlbWVudHNfZGlzdF9qc19jaGFydF9lc19qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFFBQVE7QUFDOUI7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQSxrREFBa0QsT0FBTztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLE9BQU87QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDZCQUE2QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLFdBQVc7QUFDcEI7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLG1CQUFtQjtBQUM1QjtBQUNBLFNBQVMsdUJBQXVCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHdCQUF3QixtQkFBbUIsK0NBQStDO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxVQUFVLHdDQUF3QztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdKQUFnSjtBQUM1SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsT0FBTztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFLEtBQUssUUFBUSxZQUFZLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRTtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsVUFBVSw0REFBNEQ7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtREFBbUQ7QUFDL0Q7QUFDQSx1TUFBdU07QUFDdk07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxpREFBaUQ7QUFDdEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxlQUFlLHNCQUFzQixrQkFBa0IsVUFBVSxrQkFBa0Isa0RBQWtELGVBQWUsdUJBQXVCLGtCQUFrQixVQUFVLGtCQUFrQjtBQUNyUTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlCQUFpQjtBQUM3QjtBQUNBLDhCQUE4QixPQUFPO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLFVBQVUsaUJBQWlCO0FBQzNCLFVBQVU7QUFDVjtBQUNBLDhCQUE4QixPQUFPO0FBQ3JDLHNGQUFzRiwyQkFBMkI7QUFDakg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdCQUF3QixpQkFBaUI7QUFnQnhDO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHctZWxlbWVudHMvZGlzdC9qcy9jaGFydC5lcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIENoYXJ0LmpzIHYzLjkuMVxuICogaHR0cHM6Ly93d3cuY2hhcnRqcy5vcmdcbiAqIChjKSAyMDIyIENoYXJ0LmpzIENvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKi9cbmZ1bmN0aW9uIGN0KCkge1xufVxuY29uc3QgX28gPSBmdW5jdGlvbigpIHtcbiAgbGV0IGkgPSAwO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGkrKztcbiAgfTtcbn0oKTtcbmZ1bmN0aW9uIFQoaSkge1xuICByZXR1cm4gaSA9PT0gbnVsbCB8fCB0eXBlb2YgaSA+IFwidVwiO1xufVxuZnVuY3Rpb24geihpKSB7XG4gIGlmIChBcnJheS5pc0FycmF5ICYmIEFycmF5LmlzQXJyYXkoaSkpXG4gICAgcmV0dXJuICEwO1xuICBjb25zdCB0ID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGkpO1xuICByZXR1cm4gdC5zbGljZSgwLCA3KSA9PT0gXCJbb2JqZWN0XCIgJiYgdC5zbGljZSgtNikgPT09IFwiQXJyYXldXCI7XG59XG5mdW5jdGlvbiBEKGkpIHtcbiAgcmV0dXJuIGkgIT09IG51bGwgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGkpID09PSBcIltvYmplY3QgT2JqZWN0XVwiO1xufVxuY29uc3QgTiA9IChpKSA9PiAodHlwZW9mIGkgPT0gXCJudW1iZXJcIiB8fCBpIGluc3RhbmNlb2YgTnVtYmVyKSAmJiBpc0Zpbml0ZSgraSk7XG5mdW5jdGlvbiBRKGksIHQpIHtcbiAgcmV0dXJuIE4oaSkgPyBpIDogdDtcbn1cbmZ1bmN0aW9uIEMoaSwgdCkge1xuICByZXR1cm4gdHlwZW9mIGkgPiBcInVcIiA/IHQgOiBpO1xufVxuY29uc3QgeW8gPSAoaSwgdCkgPT4gdHlwZW9mIGkgPT0gXCJzdHJpbmdcIiAmJiBpLmVuZHNXaXRoKFwiJVwiKSA/IHBhcnNlRmxvYXQoaSkgLyAxMDAgOiBpIC8gdCwgYW4gPSAoaSwgdCkgPT4gdHlwZW9mIGkgPT0gXCJzdHJpbmdcIiAmJiBpLmVuZHNXaXRoKFwiJVwiKSA/IHBhcnNlRmxvYXQoaSkgLyAxMDAgKiB0IDogK2k7XG5mdW5jdGlvbiBJKGksIHQsIGUpIHtcbiAgaWYgKGkgJiYgdHlwZW9mIGkuY2FsbCA9PSBcImZ1bmN0aW9uXCIpXG4gICAgcmV0dXJuIGkuYXBwbHkoZSwgdCk7XG59XG5mdW5jdGlvbiBFKGksIHQsIGUsIHMpIHtcbiAgbGV0IG4sIG8sIHI7XG4gIGlmICh6KGkpKVxuICAgIGlmIChvID0gaS5sZW5ndGgsIHMpXG4gICAgICBmb3IgKG4gPSBvIC0gMTsgbiA+PSAwOyBuLS0pXG4gICAgICAgIHQuY2FsbChlLCBpW25dLCBuKTtcbiAgICBlbHNlXG4gICAgICBmb3IgKG4gPSAwOyBuIDwgbzsgbisrKVxuICAgICAgICB0LmNhbGwoZSwgaVtuXSwgbik7XG4gIGVsc2UgaWYgKEQoaSkpXG4gICAgZm9yIChyID0gT2JqZWN0LmtleXMoaSksIG8gPSByLmxlbmd0aCwgbiA9IDA7IG4gPCBvOyBuKyspXG4gICAgICB0LmNhbGwoZSwgaVtyW25dXSwgcltuXSk7XG59XG5mdW5jdGlvbiB6ZShpLCB0KSB7XG4gIGxldCBlLCBzLCBuLCBvO1xuICBpZiAoIWkgfHwgIXQgfHwgaS5sZW5ndGggIT09IHQubGVuZ3RoKVxuICAgIHJldHVybiAhMTtcbiAgZm9yIChlID0gMCwgcyA9IGkubGVuZ3RoOyBlIDwgczsgKytlKVxuICAgIGlmIChuID0gaVtlXSwgbyA9IHRbZV0sIG4uZGF0YXNldEluZGV4ICE9PSBvLmRhdGFzZXRJbmRleCB8fCBuLmluZGV4ICE9PSBvLmluZGV4KVxuICAgICAgcmV0dXJuICExO1xuICByZXR1cm4gITA7XG59XG5mdW5jdGlvbiBCZShpKSB7XG4gIGlmICh6KGkpKVxuICAgIHJldHVybiBpLm1hcChCZSk7XG4gIGlmIChEKGkpKSB7XG4gICAgY29uc3QgdCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpLCBlID0gT2JqZWN0LmtleXMoaSksIHMgPSBlLmxlbmd0aDtcbiAgICBsZXQgbiA9IDA7XG4gICAgZm9yICg7IG4gPCBzOyArK24pXG4gICAgICB0W2Vbbl1dID0gQmUoaVtlW25dXSk7XG4gICAgcmV0dXJuIHQ7XG4gIH1cbiAgcmV0dXJuIGk7XG59XG5mdW5jdGlvbiBsbihpKSB7XG4gIHJldHVybiBbXCJfX3Byb3RvX19cIiwgXCJwcm90b3R5cGVcIiwgXCJjb25zdHJ1Y3RvclwiXS5pbmRleE9mKGkpID09PSAtMTtcbn1cbmZ1bmN0aW9uIHZvKGksIHQsIGUsIHMpIHtcbiAgaWYgKCFsbihpKSlcbiAgICByZXR1cm47XG4gIGNvbnN0IG4gPSB0W2ldLCBvID0gZVtpXTtcbiAgRChuKSAmJiBEKG8pID8gbmUobiwgbywgcykgOiB0W2ldID0gQmUobyk7XG59XG5mdW5jdGlvbiBuZShpLCB0LCBlKSB7XG4gIGNvbnN0IHMgPSB6KHQpID8gdCA6IFt0XSwgbiA9IHMubGVuZ3RoO1xuICBpZiAoIUQoaSkpXG4gICAgcmV0dXJuIGk7XG4gIGUgPSBlIHx8IHt9O1xuICBjb25zdCBvID0gZS5tZXJnZXIgfHwgdm87XG4gIGZvciAobGV0IHIgPSAwOyByIDwgbjsgKytyKSB7XG4gICAgaWYgKHQgPSBzW3JdLCAhRCh0KSlcbiAgICAgIGNvbnRpbnVlO1xuICAgIGNvbnN0IGEgPSBPYmplY3Qua2V5cyh0KTtcbiAgICBmb3IgKGxldCBsID0gMCwgYyA9IGEubGVuZ3RoOyBsIDwgYzsgKytsKVxuICAgICAgbyhhW2xdLCBpLCB0LCBlKTtcbiAgfVxuICByZXR1cm4gaTtcbn1cbmZ1bmN0aW9uIFF0KGksIHQpIHtcbiAgcmV0dXJuIG5lKGksIHQsIHsgbWVyZ2VyOiBNbyB9KTtcbn1cbmZ1bmN0aW9uIE1vKGksIHQsIGUpIHtcbiAgaWYgKCFsbihpKSlcbiAgICByZXR1cm47XG4gIGNvbnN0IHMgPSB0W2ldLCBuID0gZVtpXTtcbiAgRChzKSAmJiBEKG4pID8gUXQocywgbikgOiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCwgaSkgfHwgKHRbaV0gPSBCZShuKSk7XG59XG5jb25zdCBYaSA9IHtcbiAgXCJcIjogKGkpID0+IGksXG4gIHg6IChpKSA9PiBpLngsXG4gIHk6IChpKSA9PiBpLnlcbn07XG5mdW5jdGlvbiBfdChpLCB0KSB7XG4gIHJldHVybiAoWGlbdF0gfHwgKFhpW3RdID0ga28odCkpKShpKTtcbn1cbmZ1bmN0aW9uIGtvKGkpIHtcbiAgY29uc3QgdCA9IHdvKGkpO1xuICByZXR1cm4gKGUpID0+IHtcbiAgICBmb3IgKGNvbnN0IHMgb2YgdCkge1xuICAgICAgaWYgKHMgPT09IFwiXCIpXG4gICAgICAgIGJyZWFrO1xuICAgICAgZSA9IGUgJiYgZVtzXTtcbiAgICB9XG4gICAgcmV0dXJuIGU7XG4gIH07XG59XG5mdW5jdGlvbiB3byhpKSB7XG4gIGNvbnN0IHQgPSBpLnNwbGl0KFwiLlwiKSwgZSA9IFtdO1xuICBsZXQgcyA9IFwiXCI7XG4gIGZvciAoY29uc3QgbiBvZiB0KVxuICAgIHMgKz0gbiwgcy5lbmRzV2l0aChcIlxcXFxcIikgPyBzID0gcy5zbGljZSgwLCAtMSkgKyBcIi5cIiA6IChlLnB1c2gocyksIHMgPSBcIlwiKTtcbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBPaShpKSB7XG4gIHJldHVybiBpLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgaS5zbGljZSgxKTtcbn1cbmNvbnN0IGV0ID0gKGkpID0+IHR5cGVvZiBpIDwgXCJ1XCIsIHl0ID0gKGkpID0+IHR5cGVvZiBpID09IFwiZnVuY3Rpb25cIiwgVWkgPSAoaSwgdCkgPT4ge1xuICBpZiAoaS5zaXplICE9PSB0LnNpemUpXG4gICAgcmV0dXJuICExO1xuICBmb3IgKGNvbnN0IGUgb2YgaSlcbiAgICBpZiAoIXQuaGFzKGUpKVxuICAgICAgcmV0dXJuICExO1xuICByZXR1cm4gITA7XG59O1xuZnVuY3Rpb24gU28oaSkge1xuICByZXR1cm4gaS50eXBlID09PSBcIm1vdXNldXBcIiB8fCBpLnR5cGUgPT09IFwiY2xpY2tcIiB8fCBpLnR5cGUgPT09IFwiY29udGV4dG1lbnVcIjtcbn1cbmNvbnN0IEIgPSBNYXRoLlBJLCBGID0gMiAqIEIsIFBvID0gRiArIEIsIFZlID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCBDbyA9IEIgLyAxODAsIFYgPSBCIC8gMiwgJHQgPSBCIC8gNCwgS2kgPSBCICogMiAvIDMsIHR0ID0gTWF0aC5sb2cxMCwgbHQgPSBNYXRoLnNpZ247XG5mdW5jdGlvbiBxaShpKSB7XG4gIGNvbnN0IHQgPSBNYXRoLnJvdW5kKGkpO1xuICBpID0gdGUoaSwgdCwgaSAvIDFlMykgPyB0IDogaTtcbiAgY29uc3QgZSA9IE1hdGgucG93KDEwLCBNYXRoLmZsb29yKHR0KGkpKSksIHMgPSBpIC8gZTtcbiAgcmV0dXJuIChzIDw9IDEgPyAxIDogcyA8PSAyID8gMiA6IHMgPD0gNSA/IDUgOiAxMCkgKiBlO1xufVxuZnVuY3Rpb24gRG8oaSkge1xuICBjb25zdCB0ID0gW10sIGUgPSBNYXRoLnNxcnQoaSk7XG4gIGxldCBzO1xuICBmb3IgKHMgPSAxOyBzIDwgZTsgcysrKVxuICAgIGkgJSBzID09PSAwICYmICh0LnB1c2gocyksIHQucHVzaChpIC8gcykpO1xuICByZXR1cm4gZSA9PT0gKGUgfCAwKSAmJiB0LnB1c2goZSksIHQuc29ydCgobiwgbykgPT4gbiAtIG8pLnBvcCgpLCB0O1xufVxuZnVuY3Rpb24gQnQoaSkge1xuICByZXR1cm4gIWlzTmFOKHBhcnNlRmxvYXQoaSkpICYmIGlzRmluaXRlKGkpO1xufVxuZnVuY3Rpb24gdGUoaSwgdCwgZSkge1xuICByZXR1cm4gTWF0aC5hYnMoaSAtIHQpIDwgZTtcbn1cbmZ1bmN0aW9uIE9vKGksIHQpIHtcbiAgY29uc3QgZSA9IE1hdGgucm91bmQoaSk7XG4gIHJldHVybiBlIC0gdCA8PSBpICYmIGUgKyB0ID49IGk7XG59XG5mdW5jdGlvbiBjbihpLCB0LCBlKSB7XG4gIGxldCBzLCBuLCBvO1xuICBmb3IgKHMgPSAwLCBuID0gaS5sZW5ndGg7IHMgPCBuOyBzKyspXG4gICAgbyA9IGlbc11bZV0sIGlzTmFOKG8pIHx8ICh0Lm1pbiA9IE1hdGgubWluKHQubWluLCBvKSwgdC5tYXggPSBNYXRoLm1heCh0Lm1heCwgbykpO1xufVxuZnVuY3Rpb24gbnQoaSkge1xuICByZXR1cm4gaSAqIChCIC8gMTgwKTtcbn1cbmZ1bmN0aW9uIEFpKGkpIHtcbiAgcmV0dXJuIGkgKiAoMTgwIC8gQik7XG59XG5mdW5jdGlvbiBHaShpKSB7XG4gIGlmICghTihpKSlcbiAgICByZXR1cm47XG4gIGxldCB0ID0gMSwgZSA9IDA7XG4gIGZvciAoOyBNYXRoLnJvdW5kKGkgKiB0KSAvIHQgIT09IGk7IClcbiAgICB0ICo9IDEwLCBlKys7XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gaG4oaSwgdCkge1xuICBjb25zdCBlID0gdC54IC0gaS54LCBzID0gdC55IC0gaS55LCBuID0gTWF0aC5zcXJ0KGUgKiBlICsgcyAqIHMpO1xuICBsZXQgbyA9IE1hdGguYXRhbjIocywgZSk7XG4gIHJldHVybiBvIDwgLTAuNSAqIEIgJiYgKG8gKz0gRiksIHtcbiAgICBhbmdsZTogbyxcbiAgICBkaXN0YW5jZTogblxuICB9O1xufVxuZnVuY3Rpb24gYmkoaSwgdCkge1xuICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHQueCAtIGkueCwgMikgKyBNYXRoLnBvdyh0LnkgLSBpLnksIDIpKTtcbn1cbmZ1bmN0aW9uIEFvKGksIHQpIHtcbiAgcmV0dXJuIChpIC0gdCArIFBvKSAlIEYgLSBCO1xufVxuZnVuY3Rpb24gWihpKSB7XG4gIHJldHVybiAoaSAlIEYgKyBGKSAlIEY7XG59XG5mdW5jdGlvbiBvZShpLCB0LCBlLCBzKSB7XG4gIGNvbnN0IG4gPSBaKGkpLCBvID0gWih0KSwgciA9IFooZSksIGEgPSBaKG8gLSBuKSwgbCA9IFoociAtIG4pLCBjID0gWihuIC0gbyksIGggPSBaKG4gLSByKTtcbiAgcmV0dXJuIG4gPT09IG8gfHwgbiA9PT0gciB8fCBzICYmIG8gPT09IHIgfHwgYSA+IGwgJiYgYyA8IGg7XG59XG5mdW5jdGlvbiBZKGksIHQsIGUpIHtcbiAgcmV0dXJuIE1hdGgubWF4KHQsIE1hdGgubWluKGUsIGkpKTtcbn1cbmZ1bmN0aW9uIFRvKGkpIHtcbiAgcmV0dXJuIFkoaSwgLTMyNzY4LCAzMjc2Nyk7XG59XG5mdW5jdGlvbiB1dChpLCB0LCBlLCBzID0gMWUtNikge1xuICByZXR1cm4gaSA+PSBNYXRoLm1pbih0LCBlKSAtIHMgJiYgaSA8PSBNYXRoLm1heCh0LCBlKSArIHM7XG59XG5mdW5jdGlvbiBUaShpLCB0LCBlKSB7XG4gIGUgPSBlIHx8ICgocikgPT4gaVtyXSA8IHQpO1xuICBsZXQgcyA9IGkubGVuZ3RoIC0gMSwgbiA9IDAsIG87XG4gIGZvciAoOyBzIC0gbiA+IDE7IClcbiAgICBvID0gbiArIHMgPj4gMSwgZShvKSA/IG4gPSBvIDogcyA9IG87XG4gIHJldHVybiB7IGxvOiBuLCBoaTogcyB9O1xufVxuY29uc3QgZnQgPSAoaSwgdCwgZSwgcykgPT4gVGkoaSwgZSwgcyA/IChuKSA9PiBpW25dW3RdIDw9IGUgOiAobikgPT4gaVtuXVt0XSA8IGUpLCBMbyA9IChpLCB0LCBlKSA9PiBUaShpLCBlLCAocykgPT4gaVtzXVt0XSA+PSBlKTtcbmZ1bmN0aW9uIFJvKGksIHQsIGUpIHtcbiAgbGV0IHMgPSAwLCBuID0gaS5sZW5ndGg7XG4gIGZvciAoOyBzIDwgbiAmJiBpW3NdIDwgdDsgKVxuICAgIHMrKztcbiAgZm9yICg7IG4gPiBzICYmIGlbbiAtIDFdID4gZTsgKVxuICAgIG4tLTtcbiAgcmV0dXJuIHMgPiAwIHx8IG4gPCBpLmxlbmd0aCA/IGkuc2xpY2UocywgbikgOiBpO1xufVxuY29uc3QgZG4gPSBbXCJwdXNoXCIsIFwicG9wXCIsIFwic2hpZnRcIiwgXCJzcGxpY2VcIiwgXCJ1bnNoaWZ0XCJdO1xuZnVuY3Rpb24gRW8oaSwgdCkge1xuICBpZiAoaS5fY2hhcnRqcykge1xuICAgIGkuX2NoYXJ0anMubGlzdGVuZXJzLnB1c2godCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpLCBcIl9jaGFydGpzXCIsIHtcbiAgICBjb25maWd1cmFibGU6ICEwLFxuICAgIGVudW1lcmFibGU6ICExLFxuICAgIHZhbHVlOiB7XG4gICAgICBsaXN0ZW5lcnM6IFt0XVxuICAgIH1cbiAgfSksIGRuLmZvckVhY2goKGUpID0+IHtcbiAgICBjb25zdCBzID0gXCJfb25EYXRhXCIgKyBPaShlKSwgbiA9IGlbZV07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGksIGUsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgIHZhbHVlKC4uLm8pIHtcbiAgICAgICAgY29uc3QgciA9IG4uYXBwbHkodGhpcywgbyk7XG4gICAgICAgIHJldHVybiBpLl9jaGFydGpzLmxpc3RlbmVycy5mb3JFYWNoKChhKSA9PiB7XG4gICAgICAgICAgdHlwZW9mIGFbc10gPT0gXCJmdW5jdGlvblwiICYmIGFbc10oLi4ubyk7XG4gICAgICAgIH0pLCByO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cbmZ1bmN0aW9uIFppKGksIHQpIHtcbiAgY29uc3QgZSA9IGkuX2NoYXJ0anM7XG4gIGlmICghZSlcbiAgICByZXR1cm47XG4gIGNvbnN0IHMgPSBlLmxpc3RlbmVycywgbiA9IHMuaW5kZXhPZih0KTtcbiAgbiAhPT0gLTEgJiYgcy5zcGxpY2UobiwgMSksICEocy5sZW5ndGggPiAwKSAmJiAoZG4uZm9yRWFjaCgobykgPT4ge1xuICAgIGRlbGV0ZSBpW29dO1xuICB9KSwgZGVsZXRlIGkuX2NoYXJ0anMpO1xufVxuZnVuY3Rpb24gdW4oaSkge1xuICBjb25zdCB0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgbGV0IGUsIHM7XG4gIGZvciAoZSA9IDAsIHMgPSBpLmxlbmd0aDsgZSA8IHM7ICsrZSlcbiAgICB0LmFkZChpW2VdKTtcbiAgcmV0dXJuIHQuc2l6ZSA9PT0gcyA/IGkgOiBBcnJheS5mcm9tKHQpO1xufVxuY29uc3QgZm4gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgPiBcInVcIiA/IGZ1bmN0aW9uKGkpIHtcbiAgICByZXR1cm4gaSgpO1xuICB9IDogd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZTtcbn0oKTtcbmZ1bmN0aW9uIGduKGksIHQsIGUpIHtcbiAgY29uc3QgcyA9IGUgfHwgKChyKSA9PiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChyKSk7XG4gIGxldCBuID0gITEsIG8gPSBbXTtcbiAgcmV0dXJuIGZ1bmN0aW9uKC4uLnIpIHtcbiAgICBvID0gcyhyKSwgbiB8fCAobiA9ICEwLCBmbi5jYWxsKHdpbmRvdywgKCkgPT4ge1xuICAgICAgbiA9ICExLCBpLmFwcGx5KHQsIG8pO1xuICAgIH0pKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIEZvKGksIHQpIHtcbiAgbGV0IGU7XG4gIHJldHVybiBmdW5jdGlvbiguLi5zKSB7XG4gICAgcmV0dXJuIHQgPyAoY2xlYXJUaW1lb3V0KGUpLCBlID0gc2V0VGltZW91dChpLCB0LCBzKSkgOiBpLmFwcGx5KHRoaXMsIHMpLCB0O1xuICB9O1xufVxuY29uc3QgTGkgPSAoaSkgPT4gaSA9PT0gXCJzdGFydFwiID8gXCJsZWZ0XCIgOiBpID09PSBcImVuZFwiID8gXCJyaWdodFwiIDogXCJjZW50ZXJcIiwgVSA9IChpLCB0LCBlKSA9PiBpID09PSBcInN0YXJ0XCIgPyB0IDogaSA9PT0gXCJlbmRcIiA/IGUgOiAodCArIGUpIC8gMiwgSW8gPSAoaSwgdCwgZSwgcykgPT4gaSA9PT0gKHMgPyBcImxlZnRcIiA6IFwicmlnaHRcIikgPyBlIDogaSA9PT0gXCJjZW50ZXJcIiA/ICh0ICsgZSkgLyAyIDogdDtcbmZ1bmN0aW9uIHBuKGksIHQsIGUpIHtcbiAgY29uc3QgcyA9IHQubGVuZ3RoO1xuICBsZXQgbiA9IDAsIG8gPSBzO1xuICBpZiAoaS5fc29ydGVkKSB7XG4gICAgY29uc3QgeyBpU2NhbGU6IHIsIF9wYXJzZWQ6IGEgfSA9IGksIGwgPSByLmF4aXMsIHsgbWluOiBjLCBtYXg6IGgsIG1pbkRlZmluZWQ6IGQsIG1heERlZmluZWQ6IHUgfSA9IHIuZ2V0VXNlckJvdW5kcygpO1xuICAgIGQgJiYgKG4gPSBZKFxuICAgICAgTWF0aC5taW4oXG4gICAgICAgIGZ0KGEsIHIuYXhpcywgYykubG8sXG4gICAgICAgIGUgPyBzIDogZnQodCwgbCwgci5nZXRQaXhlbEZvclZhbHVlKGMpKS5sb1xuICAgICAgKSxcbiAgICAgIDAsXG4gICAgICBzIC0gMVxuICAgICkpLCB1ID8gbyA9IFkoXG4gICAgICBNYXRoLm1heChcbiAgICAgICAgZnQoYSwgci5heGlzLCBoLCAhMCkuaGkgKyAxLFxuICAgICAgICBlID8gMCA6IGZ0KHQsIGwsIHIuZ2V0UGl4ZWxGb3JWYWx1ZShoKSwgITApLmhpICsgMVxuICAgICAgKSxcbiAgICAgIG4sXG4gICAgICBzXG4gICAgKSAtIG4gOiBvID0gcyAtIG47XG4gIH1cbiAgcmV0dXJuIHsgc3RhcnQ6IG4sIGNvdW50OiBvIH07XG59XG5mdW5jdGlvbiBtbihpKSB7XG4gIGNvbnN0IHsgeFNjYWxlOiB0LCB5U2NhbGU6IGUsIF9zY2FsZVJhbmdlczogcyB9ID0gaSwgbiA9IHtcbiAgICB4bWluOiB0Lm1pbixcbiAgICB4bWF4OiB0Lm1heCxcbiAgICB5bWluOiBlLm1pbixcbiAgICB5bWF4OiBlLm1heFxuICB9O1xuICBpZiAoIXMpXG4gICAgcmV0dXJuIGkuX3NjYWxlUmFuZ2VzID0gbiwgITA7XG4gIGNvbnN0IG8gPSBzLnhtaW4gIT09IHQubWluIHx8IHMueG1heCAhPT0gdC5tYXggfHwgcy55bWluICE9PSBlLm1pbiB8fCBzLnltYXggIT09IGUubWF4O1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihzLCBuKSwgbztcbn1cbmNvbnN0IHdlID0gKGkpID0+IGkgPT09IDAgfHwgaSA9PT0gMSwgSmkgPSAoaSwgdCwgZSkgPT4gLShNYXRoLnBvdygyLCAxMCAqIChpIC09IDEpKSAqIE1hdGguc2luKChpIC0gdCkgKiBGIC8gZSkpLCBRaSA9IChpLCB0LCBlKSA9PiBNYXRoLnBvdygyLCAtMTAgKiBpKSAqIE1hdGguc2luKChpIC0gdCkgKiBGIC8gZSkgKyAxLCBlZSA9IHtcbiAgbGluZWFyOiAoaSkgPT4gaSxcbiAgZWFzZUluUXVhZDogKGkpID0+IGkgKiBpLFxuICBlYXNlT3V0UXVhZDogKGkpID0+IC1pICogKGkgLSAyKSxcbiAgZWFzZUluT3V0UXVhZDogKGkpID0+IChpIC89IDAuNSkgPCAxID8gMC41ICogaSAqIGkgOiAtMC41ICogKC0taSAqIChpIC0gMikgLSAxKSxcbiAgZWFzZUluQ3ViaWM6IChpKSA9PiBpICogaSAqIGksXG4gIGVhc2VPdXRDdWJpYzogKGkpID0+IChpIC09IDEpICogaSAqIGkgKyAxLFxuICBlYXNlSW5PdXRDdWJpYzogKGkpID0+IChpIC89IDAuNSkgPCAxID8gMC41ICogaSAqIGkgKiBpIDogMC41ICogKChpIC09IDIpICogaSAqIGkgKyAyKSxcbiAgZWFzZUluUXVhcnQ6IChpKSA9PiBpICogaSAqIGkgKiBpLFxuICBlYXNlT3V0UXVhcnQ6IChpKSA9PiAtKChpIC09IDEpICogaSAqIGkgKiBpIC0gMSksXG4gIGVhc2VJbk91dFF1YXJ0OiAoaSkgPT4gKGkgLz0gMC41KSA8IDEgPyAwLjUgKiBpICogaSAqIGkgKiBpIDogLTAuNSAqICgoaSAtPSAyKSAqIGkgKiBpICogaSAtIDIpLFxuICBlYXNlSW5RdWludDogKGkpID0+IGkgKiBpICogaSAqIGkgKiBpLFxuICBlYXNlT3V0UXVpbnQ6IChpKSA9PiAoaSAtPSAxKSAqIGkgKiBpICogaSAqIGkgKyAxLFxuICBlYXNlSW5PdXRRdWludDogKGkpID0+IChpIC89IDAuNSkgPCAxID8gMC41ICogaSAqIGkgKiBpICogaSAqIGkgOiAwLjUgKiAoKGkgLT0gMikgKiBpICogaSAqIGkgKiBpICsgMiksXG4gIGVhc2VJblNpbmU6IChpKSA9PiAtTWF0aC5jb3MoaSAqIFYpICsgMSxcbiAgZWFzZU91dFNpbmU6IChpKSA9PiBNYXRoLnNpbihpICogViksXG4gIGVhc2VJbk91dFNpbmU6IChpKSA9PiAtMC41ICogKE1hdGguY29zKEIgKiBpKSAtIDEpLFxuICBlYXNlSW5FeHBvOiAoaSkgPT4gaSA9PT0gMCA/IDAgOiBNYXRoLnBvdygyLCAxMCAqIChpIC0gMSkpLFxuICBlYXNlT3V0RXhwbzogKGkpID0+IGkgPT09IDEgPyAxIDogLU1hdGgucG93KDIsIC0xMCAqIGkpICsgMSxcbiAgZWFzZUluT3V0RXhwbzogKGkpID0+IHdlKGkpID8gaSA6IGkgPCAwLjUgPyAwLjUgKiBNYXRoLnBvdygyLCAxMCAqIChpICogMiAtIDEpKSA6IDAuNSAqICgtTWF0aC5wb3coMiwgLTEwICogKGkgKiAyIC0gMSkpICsgMiksXG4gIGVhc2VJbkNpcmM6IChpKSA9PiBpID49IDEgPyBpIDogLShNYXRoLnNxcnQoMSAtIGkgKiBpKSAtIDEpLFxuICBlYXNlT3V0Q2lyYzogKGkpID0+IE1hdGguc3FydCgxIC0gKGkgLT0gMSkgKiBpKSxcbiAgZWFzZUluT3V0Q2lyYzogKGkpID0+IChpIC89IDAuNSkgPCAxID8gLTAuNSAqIChNYXRoLnNxcnQoMSAtIGkgKiBpKSAtIDEpIDogMC41ICogKE1hdGguc3FydCgxIC0gKGkgLT0gMikgKiBpKSArIDEpLFxuICBlYXNlSW5FbGFzdGljOiAoaSkgPT4gd2UoaSkgPyBpIDogSmkoaSwgMC4wNzUsIDAuMyksXG4gIGVhc2VPdXRFbGFzdGljOiAoaSkgPT4gd2UoaSkgPyBpIDogUWkoaSwgMC4wNzUsIDAuMyksXG4gIGVhc2VJbk91dEVsYXN0aWMoaSkge1xuICAgIHJldHVybiB3ZShpKSA/IGkgOiBpIDwgMC41ID8gMC41ICogSmkoaSAqIDIsIDAuMTEyNSwgMC40NSkgOiAwLjUgKyAwLjUgKiBRaShpICogMiAtIDEsIDAuMTEyNSwgMC40NSk7XG4gIH0sXG4gIGVhc2VJbkJhY2soaSkge1xuICAgIHJldHVybiBpICogaSAqICgoMS43MDE1OCArIDEpICogaSAtIDEuNzAxNTgpO1xuICB9LFxuICBlYXNlT3V0QmFjayhpKSB7XG4gICAgcmV0dXJuIChpIC09IDEpICogaSAqICgoMS43MDE1OCArIDEpICogaSArIDEuNzAxNTgpICsgMTtcbiAgfSxcbiAgZWFzZUluT3V0QmFjayhpKSB7XG4gICAgbGV0IHQgPSAxLjcwMTU4O1xuICAgIHJldHVybiAoaSAvPSAwLjUpIDwgMSA/IDAuNSAqIChpICogaSAqICgoKHQgKj0gMS41MjUpICsgMSkgKiBpIC0gdCkpIDogMC41ICogKChpIC09IDIpICogaSAqICgoKHQgKj0gMS41MjUpICsgMSkgKiBpICsgdCkgKyAyKTtcbiAgfSxcbiAgZWFzZUluQm91bmNlOiAoaSkgPT4gMSAtIGVlLmVhc2VPdXRCb3VuY2UoMSAtIGkpLFxuICBlYXNlT3V0Qm91bmNlKGkpIHtcbiAgICByZXR1cm4gaSA8IDEgLyAyLjc1ID8gNy41NjI1ICogaSAqIGkgOiBpIDwgMiAvIDIuNzUgPyA3LjU2MjUgKiAoaSAtPSAxLjUgLyAyLjc1KSAqIGkgKyAwLjc1IDogaSA8IDIuNSAvIDIuNzUgPyA3LjU2MjUgKiAoaSAtPSAyLjI1IC8gMi43NSkgKiBpICsgMC45Mzc1IDogNy41NjI1ICogKGkgLT0gMi42MjUgLyAyLjc1KSAqIGkgKyAwLjk4NDM3NTtcbiAgfSxcbiAgZWFzZUluT3V0Qm91bmNlOiAoaSkgPT4gaSA8IDAuNSA/IGVlLmVhc2VJbkJvdW5jZShpICogMikgKiAwLjUgOiBlZS5lYXNlT3V0Qm91bmNlKGkgKiAyIC0gMSkgKiAwLjUgKyAwLjVcbn07XG4vKiFcbiAqIEBrdXJrbGUvY29sb3IgdjAuMi4xXG4gKiBodHRwczovL2dpdGh1Yi5jb20va3Vya2xlL2NvbG9yI3JlYWRtZVxuICogKGMpIDIwMjIgSnVra2EgS3Vya2VsYVxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKi9cbmZ1bmN0aW9uIGhlKGkpIHtcbiAgcmV0dXJuIGkgKyAwLjUgfCAwO1xufVxuY29uc3QgbXQgPSAoaSwgdCwgZSkgPT4gTWF0aC5tYXgoTWF0aC5taW4oaSwgZSksIHQpO1xuZnVuY3Rpb24gR3QoaSkge1xuICByZXR1cm4gbXQoaGUoaSAqIDIuNTUpLCAwLCAyNTUpO1xufVxuZnVuY3Rpb24geHQoaSkge1xuICByZXR1cm4gbXQoaGUoaSAqIDI1NSksIDAsIDI1NSk7XG59XG5mdW5jdGlvbiBkdChpKSB7XG4gIHJldHVybiBtdChoZShpIC8gMi41NSkgLyAxMDAsIDAsIDEpO1xufVxuZnVuY3Rpb24gdHMoaSkge1xuICByZXR1cm4gbXQoaGUoaSAqIDEwMCksIDAsIDEwMCk7XG59XG5jb25zdCBKID0geyAwOiAwLCAxOiAxLCAyOiAyLCAzOiAzLCA0OiA0LCA1OiA1LCA2OiA2LCA3OiA3LCA4OiA4LCA5OiA5LCBBOiAxMCwgQjogMTEsIEM6IDEyLCBEOiAxMywgRTogMTQsIEY6IDE1LCBhOiAxMCwgYjogMTEsIGM6IDEyLCBkOiAxMywgZTogMTQsIGY6IDE1IH0sIHhpID0gWy4uLlwiMDEyMzQ1Njc4OUFCQ0RFRlwiXSwgem8gPSAoaSkgPT4geGlbaSAmIDE1XSwgQm8gPSAoaSkgPT4geGlbKGkgJiAyNDApID4+IDRdICsgeGlbaSAmIDE1XSwgU2UgPSAoaSkgPT4gKGkgJiAyNDApID4+IDQgPT09IChpICYgMTUpLCBWbyA9IChpKSA9PiBTZShpLnIpICYmIFNlKGkuZykgJiYgU2UoaS5iKSAmJiBTZShpLmEpO1xuZnVuY3Rpb24gV28oaSkge1xuICB2YXIgdCA9IGkubGVuZ3RoLCBlO1xuICByZXR1cm4gaVswXSA9PT0gXCIjXCIgJiYgKHQgPT09IDQgfHwgdCA9PT0gNSA/IGUgPSB7XG4gICAgcjogMjU1ICYgSltpWzFdXSAqIDE3LFxuICAgIGc6IDI1NSAmIEpbaVsyXV0gKiAxNyxcbiAgICBiOiAyNTUgJiBKW2lbM11dICogMTcsXG4gICAgYTogdCA9PT0gNSA/IEpbaVs0XV0gKiAxNyA6IDI1NVxuICB9IDogKHQgPT09IDcgfHwgdCA9PT0gOSkgJiYgKGUgPSB7XG4gICAgcjogSltpWzFdXSA8PCA0IHwgSltpWzJdXSxcbiAgICBnOiBKW2lbM11dIDw8IDQgfCBKW2lbNF1dLFxuICAgIGI6IEpbaVs1XV0gPDwgNCB8IEpbaVs2XV0sXG4gICAgYTogdCA9PT0gOSA/IEpbaVs3XV0gPDwgNCB8IEpbaVs4XV0gOiAyNTVcbiAgfSkpLCBlO1xufVxuY29uc3QgTm8gPSAoaSwgdCkgPT4gaSA8IDI1NSA/IHQoaSkgOiBcIlwiO1xuZnVuY3Rpb24gSG8oaSkge1xuICB2YXIgdCA9IFZvKGkpID8gem8gOiBCbztcbiAgcmV0dXJuIGkgPyBcIiNcIiArIHQoaS5yKSArIHQoaS5nKSArIHQoaS5iKSArIE5vKGkuYSwgdCkgOiB2b2lkIDA7XG59XG5jb25zdCBqbyA9IC9eKGhzbGE/fGh3Ynxoc3YpXFwoXFxzKihbLSsuZVxcZF0rKSg/OmRlZyk/W1xccyxdKyhbLSsuZVxcZF0rKSVbXFxzLF0rKFstKy5lXFxkXSspJSg/OltcXHMsXSsoWy0rLmVcXGRdKykoJSk/KT9cXHMqXFwpJC87XG5mdW5jdGlvbiBibihpLCB0LCBlKSB7XG4gIGNvbnN0IHMgPSB0ICogTWF0aC5taW4oZSwgMSAtIGUpLCBuID0gKG8sIHIgPSAobyArIGkgLyAzMCkgJSAxMikgPT4gZSAtIHMgKiBNYXRoLm1heChNYXRoLm1pbihyIC0gMywgOSAtIHIsIDEpLCAtMSk7XG4gIHJldHVybiBbbigwKSwgbig4KSwgbig0KV07XG59XG5mdW5jdGlvbiAkbyhpLCB0LCBlKSB7XG4gIGNvbnN0IHMgPSAobiwgbyA9IChuICsgaSAvIDYwKSAlIDYpID0+IGUgLSBlICogdCAqIE1hdGgubWF4KE1hdGgubWluKG8sIDQgLSBvLCAxKSwgMCk7XG4gIHJldHVybiBbcyg1KSwgcygzKSwgcygxKV07XG59XG5mdW5jdGlvbiBZbyhpLCB0LCBlKSB7XG4gIGNvbnN0IHMgPSBibihpLCAxLCAwLjUpO1xuICBsZXQgbjtcbiAgZm9yICh0ICsgZSA+IDEgJiYgKG4gPSAxIC8gKHQgKyBlKSwgdCAqPSBuLCBlICo9IG4pLCBuID0gMDsgbiA8IDM7IG4rKylcbiAgICBzW25dICo9IDEgLSB0IC0gZSwgc1tuXSArPSB0O1xuICByZXR1cm4gcztcbn1cbmZ1bmN0aW9uIFhvKGksIHQsIGUsIHMsIG4pIHtcbiAgcmV0dXJuIGkgPT09IG4gPyAodCAtIGUpIC8gcyArICh0IDwgZSA/IDYgOiAwKSA6IHQgPT09IG4gPyAoZSAtIGkpIC8gcyArIDIgOiAoaSAtIHQpIC8gcyArIDQ7XG59XG5mdW5jdGlvbiBSaShpKSB7XG4gIGNvbnN0IGUgPSBpLnIgLyAyNTUsIHMgPSBpLmcgLyAyNTUsIG4gPSBpLmIgLyAyNTUsIG8gPSBNYXRoLm1heChlLCBzLCBuKSwgciA9IE1hdGgubWluKGUsIHMsIG4pLCBhID0gKG8gKyByKSAvIDI7XG4gIGxldCBsLCBjLCBoO1xuICByZXR1cm4gbyAhPT0gciAmJiAoaCA9IG8gLSByLCBjID0gYSA+IDAuNSA/IGggLyAoMiAtIG8gLSByKSA6IGggLyAobyArIHIpLCBsID0gWG8oZSwgcywgbiwgaCwgbyksIGwgPSBsICogNjAgKyAwLjUpLCBbbCB8IDAsIGMgfHwgMCwgYV07XG59XG5mdW5jdGlvbiBFaShpLCB0LCBlLCBzKSB7XG4gIHJldHVybiAoQXJyYXkuaXNBcnJheSh0KSA/IGkodFswXSwgdFsxXSwgdFsyXSkgOiBpKHQsIGUsIHMpKS5tYXAoeHQpO1xufVxuZnVuY3Rpb24gRmkoaSwgdCwgZSkge1xuICByZXR1cm4gRWkoYm4sIGksIHQsIGUpO1xufVxuZnVuY3Rpb24gVW8oaSwgdCwgZSkge1xuICByZXR1cm4gRWkoWW8sIGksIHQsIGUpO1xufVxuZnVuY3Rpb24gS28oaSwgdCwgZSkge1xuICByZXR1cm4gRWkoJG8sIGksIHQsIGUpO1xufVxuZnVuY3Rpb24geG4oaSkge1xuICByZXR1cm4gKGkgJSAzNjAgKyAzNjApICUgMzYwO1xufVxuZnVuY3Rpb24gcW8oaSkge1xuICBjb25zdCB0ID0gam8uZXhlYyhpKTtcbiAgbGV0IGUgPSAyNTUsIHM7XG4gIGlmICghdClcbiAgICByZXR1cm47XG4gIHRbNV0gIT09IHMgJiYgKGUgPSB0WzZdID8gR3QoK3RbNV0pIDogeHQoK3RbNV0pKTtcbiAgY29uc3QgbiA9IHhuKCt0WzJdKSwgbyA9ICt0WzNdIC8gMTAwLCByID0gK3RbNF0gLyAxMDA7XG4gIHJldHVybiB0WzFdID09PSBcImh3YlwiID8gcyA9IFVvKG4sIG8sIHIpIDogdFsxXSA9PT0gXCJoc3ZcIiA/IHMgPSBLbyhuLCBvLCByKSA6IHMgPSBGaShuLCBvLCByKSwge1xuICAgIHI6IHNbMF0sXG4gICAgZzogc1sxXSxcbiAgICBiOiBzWzJdLFxuICAgIGE6IGVcbiAgfTtcbn1cbmZ1bmN0aW9uIEdvKGksIHQpIHtcbiAgdmFyIGUgPSBSaShpKTtcbiAgZVswXSA9IHhuKGVbMF0gKyB0KSwgZSA9IEZpKGUpLCBpLnIgPSBlWzBdLCBpLmcgPSBlWzFdLCBpLmIgPSBlWzJdO1xufVxuZnVuY3Rpb24gWm8oaSkge1xuICBpZiAoIWkpXG4gICAgcmV0dXJuO1xuICBjb25zdCB0ID0gUmkoaSksIGUgPSB0WzBdLCBzID0gdHModFsxXSksIG4gPSB0cyh0WzJdKTtcbiAgcmV0dXJuIGkuYSA8IDI1NSA/IGBoc2xhKCR7ZX0sICR7c30lLCAke259JSwgJHtkdChpLmEpfSlgIDogYGhzbCgke2V9LCAke3N9JSwgJHtufSUpYDtcbn1cbmNvbnN0IGVzID0ge1xuICB4OiBcImRhcmtcIixcbiAgWjogXCJsaWdodFwiLFxuICBZOiBcInJlXCIsXG4gIFg6IFwiYmx1XCIsXG4gIFc6IFwiZ3JcIixcbiAgVjogXCJtZWRpdW1cIixcbiAgVTogXCJzbGF0ZVwiLFxuICBBOiBcImVlXCIsXG4gIFQ6IFwib2xcIixcbiAgUzogXCJvclwiLFxuICBCOiBcInJhXCIsXG4gIEM6IFwibGF0ZWdcIixcbiAgRDogXCJpZ2h0c1wiLFxuICBSOiBcImluXCIsXG4gIFE6IFwidHVycXVvaXNcIixcbiAgRTogXCJoaVwiLFxuICBQOiBcInJvXCIsXG4gIE86IFwiYWxcIixcbiAgTjogXCJsZVwiLFxuICBNOiBcImRlXCIsXG4gIEw6IFwieWVsbG9cIixcbiAgRjogXCJlblwiLFxuICBLOiBcImNoXCIsXG4gIEc6IFwiYXJrc1wiLFxuICBIOiBcImVhXCIsXG4gIEk6IFwiaWdodGdcIixcbiAgSjogXCJ3aFwiXG59LCBpcyA9IHtcbiAgT2ljZVhlOiBcImYwZjhmZlwiLFxuICBhbnRpcXVld0V0ZTogXCJmYWViZDdcIixcbiAgYXF1YTogXCJmZmZmXCIsXG4gIGFxdWFtYXJSZTogXCI3ZmZmZDRcIixcbiAgYXp1WTogXCJmMGZmZmZcIixcbiAgYmVpZ2U6IFwiZjVmNWRjXCIsXG4gIGJpc3F1ZTogXCJmZmU0YzRcIixcbiAgYmxhY2s6IFwiMFwiLFxuICBibGFuS2VkT21vbmQ6IFwiZmZlYmNkXCIsXG4gIFhlOiBcImZmXCIsXG4gIFhldmlUZXQ6IFwiOGEyYmUyXCIsXG4gIGJQd246IFwiYTUyYTJhXCIsXG4gIGJ1cmx5d29vZDogXCJkZWI4ODdcIixcbiAgY2FNdFhlOiBcIjVmOWVhMFwiLFxuICBLYXJ0WXVzZTogXCI3ZmZmMDBcIixcbiAgS29jVGF0ZTogXCJkMjY5MWVcIixcbiAgY1NPOiBcImZmN2Y1MFwiLFxuICBjU25mbG93ZXJYZTogXCI2NDk1ZWRcIixcbiAgY1Nuc2lsazogXCJmZmY4ZGNcIixcbiAgY3JpbXNvbjogXCJkYzE0M2NcIixcbiAgY3lhbjogXCJmZmZmXCIsXG4gIHhYZTogXCI4YlwiLFxuICB4Y3lhbjogXCI4YjhiXCIsXG4gIHhnVE1uUGQ6IFwiYjg4NjBiXCIsXG4gIHhXYXk6IFwiYTlhOWE5XCIsXG4gIHhnWUY6IFwiNjQwMFwiLFxuICB4Z1l5OiBcImE5YTlhOVwiLFxuICB4a2hha2k6IFwiYmRiNzZiXCIsXG4gIHhtYWdGdGE6IFwiOGIwMDhiXCIsXG4gIHhUaXZlZ1lGOiBcIjU1NmIyZlwiLFxuICB4U2FuZ2U6IFwiZmY4YzAwXCIsXG4gIHhTY0VkOiBcIjk5MzJjY1wiLFxuICB4WWQ6IFwiOGIwMDAwXCIsXG4gIHhzT21vbjogXCJlOTk2N2FcIixcbiAgeHNIZ1lGOiBcIjhmYmM4ZlwiLFxuICB4VVhlOiBcIjQ4M2Q4YlwiLFxuICB4VVdheTogXCIyZjRmNGZcIixcbiAgeFVnWXk6IFwiMmY0ZjRmXCIsXG4gIHhRZTogXCJjZWQxXCIsXG4gIHh2aVRldDogXCI5NDAwZDNcIixcbiAgZEFwcFJrOiBcImZmMTQ5M1wiLFxuICBkQXBza3lYZTogXCJiZmZmXCIsXG4gIGRpbVdheTogXCI2OTY5NjlcIixcbiAgZGltZ1l5OiBcIjY5Njk2OVwiLFxuICBkb2RnZXJYZTogXCIxZTkwZmZcIixcbiAgZmlZYnJpY2s6IFwiYjIyMjIyXCIsXG4gIGZsU093RXRlOiBcImZmZmFmMFwiLFxuICBmb1lzdFdBbjogXCIyMjhiMjJcIixcbiAgZnVLc2lhOiBcImZmMDBmZlwiLFxuICBnYVJzYlNvOiBcImRjZGNkY1wiLFxuICBnaG9zdHdFdGU6IFwiZjhmOGZmXCIsXG4gIGdUZDogXCJmZmQ3MDBcIixcbiAgZ1RNblBkOiBcImRhYTUyMFwiLFxuICBXYXk6IFwiODA4MDgwXCIsXG4gIGdZRjogXCI4MDAwXCIsXG4gIGdZRkx3OiBcImFkZmYyZlwiLFxuICBnWXk6IFwiODA4MDgwXCIsXG4gIGhvbmV5TXc6IFwiZjBmZmYwXCIsXG4gIGhvdHBSazogXCJmZjY5YjRcIixcbiAgUmRpYW5ZZDogXCJjZDVjNWNcIixcbiAgUmRpZ286IFwiNGIwMDgyXCIsXG4gIGl2U3k6IFwiZmZmZmYwXCIsXG4gIGtoYWtpOiBcImYwZTY4Y1wiLFxuICBsYXZGTXI6IFwiZTZlNmZhXCIsXG4gIGxhdkZNclhzaDogXCJmZmYwZjVcIixcbiAgbGF3bmdZRjogXCI3Y2ZjMDBcIixcbiAgTm1vbmNFZmZvbjogXCJmZmZhY2RcIixcbiAgWlhlOiBcImFkZDhlNlwiLFxuICBaY1NPOiBcImYwODA4MFwiLFxuICBaY3lhbjogXCJlMGZmZmZcIixcbiAgWmdUTW5QZEx3OiBcImZhZmFkMlwiLFxuICBaV2F5OiBcImQzZDNkM1wiLFxuICBaZ1lGOiBcIjkwZWU5MFwiLFxuICBaZ1l5OiBcImQzZDNkM1wiLFxuICBacFJrOiBcImZmYjZjMVwiLFxuICBac09tb246IFwiZmZhMDdhXCIsXG4gIFpzSGdZRjogXCIyMGIyYWFcIixcbiAgWnNreVhlOiBcIjg3Y2VmYVwiLFxuICBaVVdheTogXCI3Nzg4OTlcIixcbiAgWlVnWXk6IFwiNzc4ODk5XCIsXG4gIFpzdEFsWGU6IFwiYjBjNGRlXCIsXG4gIFpMdzogXCJmZmZmZTBcIixcbiAgbGltZTogXCJmZjAwXCIsXG4gIGxpbWVnWUY6IFwiMzJjZDMyXCIsXG4gIGxSRjogXCJmYWYwZTZcIixcbiAgbWFnRnRhOiBcImZmMDBmZlwiLFxuICBtYVBvbjogXCI4MDAwMDBcIixcbiAgVmFxdWFtYXJSZTogXCI2NmNkYWFcIixcbiAgVlhlOiBcImNkXCIsXG4gIFZTY0VkOiBcImJhNTVkM1wiLFxuICBWcHVycE46IFwiOTM3MGRiXCIsXG4gIFZzSGdZRjogXCIzY2IzNzFcIixcbiAgVlVYZTogXCI3YjY4ZWVcIixcbiAgVnNwclJnZ1lGOiBcImZhOWFcIixcbiAgVlFlOiBcIjQ4ZDFjY1wiLFxuICBWdmlUZXRZZDogXCJjNzE1ODVcIixcbiAgbWlkbmlnaHRYZTogXCIxOTE5NzBcIixcbiAgbVJ0Y1lhbTogXCJmNWZmZmFcIixcbiAgbWlzdHlQc2U6IFwiZmZlNGUxXCIsXG4gIG1vY2Nhc1I6IFwiZmZlNGI1XCIsXG4gIG5hdmFqb3dFdGU6IFwiZmZkZWFkXCIsXG4gIG5hdnk6IFwiODBcIixcbiAgVGRsYWNlOiBcImZkZjVlNlwiLFxuICBUaXZlOiBcIjgwODAwMFwiLFxuICBUaXZlZEJiOiBcIjZiOGUyM1wiLFxuICBTYW5nZTogXCJmZmE1MDBcIixcbiAgU2FuZ2VZZDogXCJmZjQ1MDBcIixcbiAgU2NFZDogXCJkYTcwZDZcIixcbiAgcE9lZ1RNblBkOiBcImVlZThhYVwiLFxuICBwT2VnWUY6IFwiOThmYjk4XCIsXG4gIHBPZVFlOiBcImFmZWVlZVwiLFxuICBwT2V2aVRldFlkOiBcImRiNzA5M1wiLFxuICBwYXBheWF3RXA6IFwiZmZlZmQ1XCIsXG4gIHBIS3B1ZmY6IFwiZmZkYWI5XCIsXG4gIHBlcnU6IFwiY2Q4NTNmXCIsXG4gIHBSazogXCJmZmMwY2JcIixcbiAgcGx1bTogXCJkZGEwZGRcIixcbiAgcG93TXJYZTogXCJiMGUwZTZcIixcbiAgcHVycE46IFwiODAwMDgwXCIsXG4gIFliZWNjYXB1cnBOOiBcIjY2MzM5OVwiLFxuICBZZDogXCJmZjAwMDBcIixcbiAgUHN5YnJvd246IFwiYmM4ZjhmXCIsXG4gIFB5T1hlOiBcIjQxNjllMVwiLFxuICBzYWRkTmJQd246IFwiOGI0NTEzXCIsXG4gIHNPbW9uOiBcImZhODA3MlwiLFxuICBzYW5keWJQd246IFwiZjRhNDYwXCIsXG4gIHNIZ1lGOiBcIjJlOGI1N1wiLFxuICBzSHNoZWxsOiBcImZmZjVlZVwiLFxuICBzaUZuYTogXCJhMDUyMmRcIixcbiAgc2lsdmVyOiBcImMwYzBjMFwiLFxuICBza3lYZTogXCI4N2NlZWJcIixcbiAgVVhlOiBcIjZhNWFjZFwiLFxuICBVV2F5OiBcIjcwODA5MFwiLFxuICBVZ1l5OiBcIjcwODA5MFwiLFxuICBzbm93OiBcImZmZmFmYVwiLFxuICBzcHJSZ2dZRjogXCJmZjdmXCIsXG4gIHN0QWxYZTogXCI0NjgyYjRcIixcbiAgdGFuOiBcImQyYjQ4Y1wiLFxuICB0ZU86IFwiODA4MFwiLFxuICB0RXN0TjogXCJkOGJmZDhcIixcbiAgdG9tYXRvOiBcImZmNjM0N1wiLFxuICBRZTogXCI0MGUwZDBcIixcbiAgdmlUZXQ6IFwiZWU4MmVlXCIsXG4gIEpIdDogXCJmNWRlYjNcIixcbiAgd0V0ZTogXCJmZmZmZmZcIixcbiAgd0V0ZXNtb2tlOiBcImY1ZjVmNVwiLFxuICBMdzogXCJmZmZmMDBcIixcbiAgTHdnWUY6IFwiOWFjZDMyXCJcbn07XG5mdW5jdGlvbiBKbygpIHtcbiAgY29uc3QgaSA9IHt9LCB0ID0gT2JqZWN0LmtleXMoaXMpLCBlID0gT2JqZWN0LmtleXMoZXMpO1xuICBsZXQgcywgbiwgbywgciwgYTtcbiAgZm9yIChzID0gMDsgcyA8IHQubGVuZ3RoOyBzKyspIHtcbiAgICBmb3IgKHIgPSBhID0gdFtzXSwgbiA9IDA7IG4gPCBlLmxlbmd0aDsgbisrKVxuICAgICAgbyA9IGVbbl0sIGEgPSBhLnJlcGxhY2UobywgZXNbb10pO1xuICAgIG8gPSBwYXJzZUludChpc1tyXSwgMTYpLCBpW2FdID0gW28gPj4gMTYgJiAyNTUsIG8gPj4gOCAmIDI1NSwgbyAmIDI1NV07XG4gIH1cbiAgcmV0dXJuIGk7XG59XG5sZXQgUGU7XG5mdW5jdGlvbiBRbyhpKSB7XG4gIFBlIHx8IChQZSA9IEpvKCksIFBlLnRyYW5zcGFyZW50ID0gWzAsIDAsIDAsIDBdKTtcbiAgY29uc3QgdCA9IFBlW2kudG9Mb3dlckNhc2UoKV07XG4gIHJldHVybiB0ICYmIHtcbiAgICByOiB0WzBdLFxuICAgIGc6IHRbMV0sXG4gICAgYjogdFsyXSxcbiAgICBhOiB0Lmxlbmd0aCA9PT0gNCA/IHRbM10gOiAyNTVcbiAgfTtcbn1cbmNvbnN0IHRyID0gL15yZ2JhP1xcKFxccyooWy0rLlxcZF0rKSglKT9bXFxzLF0rKFstKy5lXFxkXSspKCUpP1tcXHMsXSsoWy0rLmVcXGRdKykoJSk/KD86W1xccywvXSsoWy0rLmVcXGRdKykoJSk/KT9cXHMqXFwpJC87XG5mdW5jdGlvbiBlcihpKSB7XG4gIGNvbnN0IHQgPSB0ci5leGVjKGkpO1xuICBsZXQgZSA9IDI1NSwgcywgbiwgbztcbiAgaWYgKHQpIHtcbiAgICBpZiAodFs3XSAhPT0gcykge1xuICAgICAgY29uc3QgciA9ICt0WzddO1xuICAgICAgZSA9IHRbOF0gPyBHdChyKSA6IG10KHIgKiAyNTUsIDAsIDI1NSk7XG4gICAgfVxuICAgIHJldHVybiBzID0gK3RbMV0sIG4gPSArdFszXSwgbyA9ICt0WzVdLCBzID0gMjU1ICYgKHRbMl0gPyBHdChzKSA6IG10KHMsIDAsIDI1NSkpLCBuID0gMjU1ICYgKHRbNF0gPyBHdChuKSA6IG10KG4sIDAsIDI1NSkpLCBvID0gMjU1ICYgKHRbNl0gPyBHdChvKSA6IG10KG8sIDAsIDI1NSkpLCB7XG4gICAgICByOiBzLFxuICAgICAgZzogbixcbiAgICAgIGI6IG8sXG4gICAgICBhOiBlXG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gaXIoaSkge1xuICByZXR1cm4gaSAmJiAoaS5hIDwgMjU1ID8gYHJnYmEoJHtpLnJ9LCAke2kuZ30sICR7aS5ifSwgJHtkdChpLmEpfSlgIDogYHJnYigke2kucn0sICR7aS5nfSwgJHtpLmJ9KWApO1xufVxuY29uc3QgbmkgPSAoaSkgPT4gaSA8PSAzMTMwOGUtNyA/IGkgKiAxMi45MiA6IE1hdGgucG93KGksIDEgLyAyLjQpICogMS4wNTUgLSAwLjA1NSwgRnQgPSAoaSkgPT4gaSA8PSAwLjA0MDQ1ID8gaSAvIDEyLjkyIDogTWF0aC5wb3coKGkgKyAwLjA1NSkgLyAxLjA1NSwgMi40KTtcbmZ1bmN0aW9uIHNyKGksIHQsIGUpIHtcbiAgY29uc3QgcyA9IEZ0KGR0KGkucikpLCBuID0gRnQoZHQoaS5nKSksIG8gPSBGdChkdChpLmIpKTtcbiAgcmV0dXJuIHtcbiAgICByOiB4dChuaShzICsgZSAqIChGdChkdCh0LnIpKSAtIHMpKSksXG4gICAgZzogeHQobmkobiArIGUgKiAoRnQoZHQodC5nKSkgLSBuKSkpLFxuICAgIGI6IHh0KG5pKG8gKyBlICogKEZ0KGR0KHQuYikpIC0gbykpKSxcbiAgICBhOiBpLmEgKyBlICogKHQuYSAtIGkuYSlcbiAgfTtcbn1cbmZ1bmN0aW9uIENlKGksIHQsIGUpIHtcbiAgaWYgKGkpIHtcbiAgICBsZXQgcyA9IFJpKGkpO1xuICAgIHNbdF0gPSBNYXRoLm1heCgwLCBNYXRoLm1pbihzW3RdICsgc1t0XSAqIGUsIHQgPT09IDAgPyAzNjAgOiAxKSksIHMgPSBGaShzKSwgaS5yID0gc1swXSwgaS5nID0gc1sxXSwgaS5iID0gc1syXTtcbiAgfVxufVxuZnVuY3Rpb24gX24oaSwgdCkge1xuICByZXR1cm4gaSAmJiBPYmplY3QuYXNzaWduKHQgfHwge30sIGkpO1xufVxuZnVuY3Rpb24gc3MoaSkge1xuICB2YXIgdCA9IHsgcjogMCwgZzogMCwgYjogMCwgYTogMjU1IH07XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGkpID8gaS5sZW5ndGggPj0gMyAmJiAodCA9IHsgcjogaVswXSwgZzogaVsxXSwgYjogaVsyXSwgYTogMjU1IH0sIGkubGVuZ3RoID4gMyAmJiAodC5hID0geHQoaVszXSkpKSA6ICh0ID0gX24oaSwgeyByOiAwLCBnOiAwLCBiOiAwLCBhOiAxIH0pLCB0LmEgPSB4dCh0LmEpKSwgdDtcbn1cbmZ1bmN0aW9uIG5yKGkpIHtcbiAgcmV0dXJuIGkuY2hhckF0KDApID09PSBcInJcIiA/IGVyKGkpIDogcW8oaSk7XG59XG5jbGFzcyBXZSB7XG4gIGNvbnN0cnVjdG9yKHQpIHtcbiAgICBpZiAodCBpbnN0YW5jZW9mIFdlKVxuICAgICAgcmV0dXJuIHQ7XG4gICAgY29uc3QgZSA9IHR5cGVvZiB0O1xuICAgIGxldCBzO1xuICAgIGUgPT09IFwib2JqZWN0XCIgPyBzID0gc3ModCkgOiBlID09PSBcInN0cmluZ1wiICYmIChzID0gV28odCkgfHwgUW8odCkgfHwgbnIodCkpLCB0aGlzLl9yZ2IgPSBzLCB0aGlzLl92YWxpZCA9ICEhcztcbiAgfVxuICBnZXQgdmFsaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbGlkO1xuICB9XG4gIGdldCByZ2IoKSB7XG4gICAgdmFyIHQgPSBfbih0aGlzLl9yZ2IpO1xuICAgIHJldHVybiB0ICYmICh0LmEgPSBkdCh0LmEpKSwgdDtcbiAgfVxuICBzZXQgcmdiKHQpIHtcbiAgICB0aGlzLl9yZ2IgPSBzcyh0KTtcbiAgfVxuICByZ2JTdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbGlkID8gaXIodGhpcy5fcmdiKSA6IHZvaWQgMDtcbiAgfVxuICBoZXhTdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbGlkID8gSG8odGhpcy5fcmdiKSA6IHZvaWQgMDtcbiAgfVxuICBoc2xTdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbGlkID8gWm8odGhpcy5fcmdiKSA6IHZvaWQgMDtcbiAgfVxuICBtaXgodCwgZSkge1xuICAgIGlmICh0KSB7XG4gICAgICBjb25zdCBzID0gdGhpcy5yZ2IsIG4gPSB0LnJnYjtcbiAgICAgIGxldCBvO1xuICAgICAgY29uc3QgciA9IGUgPT09IG8gPyAwLjUgOiBlLCBhID0gMiAqIHIgLSAxLCBsID0gcy5hIC0gbi5hLCBjID0gKChhICogbCA9PT0gLTEgPyBhIDogKGEgKyBsKSAvICgxICsgYSAqIGwpKSArIDEpIC8gMjtcbiAgICAgIG8gPSAxIC0gYywgcy5yID0gMjU1ICYgYyAqIHMuciArIG8gKiBuLnIgKyAwLjUsIHMuZyA9IDI1NSAmIGMgKiBzLmcgKyBvICogbi5nICsgMC41LCBzLmIgPSAyNTUgJiBjICogcy5iICsgbyAqIG4uYiArIDAuNSwgcy5hID0gciAqIHMuYSArICgxIC0gcikgKiBuLmEsIHRoaXMucmdiID0gcztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgaW50ZXJwb2xhdGUodCwgZSkge1xuICAgIHJldHVybiB0ICYmICh0aGlzLl9yZ2IgPSBzcih0aGlzLl9yZ2IsIHQuX3JnYiwgZSkpLCB0aGlzO1xuICB9XG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgV2UodGhpcy5yZ2IpO1xuICB9XG4gIGFscGhhKHQpIHtcbiAgICByZXR1cm4gdGhpcy5fcmdiLmEgPSB4dCh0KSwgdGhpcztcbiAgfVxuICBjbGVhcmVyKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5fcmdiO1xuICAgIHJldHVybiBlLmEgKj0gMSAtIHQsIHRoaXM7XG4gIH1cbiAgZ3JleXNjYWxlKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9yZ2IsIGUgPSBoZSh0LnIgKiAwLjMgKyB0LmcgKiAwLjU5ICsgdC5iICogMC4xMSk7XG4gICAgcmV0dXJuIHQuciA9IHQuZyA9IHQuYiA9IGUsIHRoaXM7XG4gIH1cbiAgb3BhcXVlcih0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuX3JnYjtcbiAgICByZXR1cm4gZS5hICo9IDEgKyB0LCB0aGlzO1xuICB9XG4gIG5lZ2F0ZSgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fcmdiO1xuICAgIHJldHVybiB0LnIgPSAyNTUgLSB0LnIsIHQuZyA9IDI1NSAtIHQuZywgdC5iID0gMjU1IC0gdC5iLCB0aGlzO1xuICB9XG4gIGxpZ2h0ZW4odCkge1xuICAgIHJldHVybiBDZSh0aGlzLl9yZ2IsIDIsIHQpLCB0aGlzO1xuICB9XG4gIGRhcmtlbih0KSB7XG4gICAgcmV0dXJuIENlKHRoaXMuX3JnYiwgMiwgLXQpLCB0aGlzO1xuICB9XG4gIHNhdHVyYXRlKHQpIHtcbiAgICByZXR1cm4gQ2UodGhpcy5fcmdiLCAxLCB0KSwgdGhpcztcbiAgfVxuICBkZXNhdHVyYXRlKHQpIHtcbiAgICByZXR1cm4gQ2UodGhpcy5fcmdiLCAxLCAtdCksIHRoaXM7XG4gIH1cbiAgcm90YXRlKHQpIHtcbiAgICByZXR1cm4gR28odGhpcy5fcmdiLCB0KSwgdGhpcztcbiAgfVxufVxuZnVuY3Rpb24geW4oaSkge1xuICByZXR1cm4gbmV3IFdlKGkpO1xufVxuZnVuY3Rpb24gdm4oaSkge1xuICBpZiAoaSAmJiB0eXBlb2YgaSA9PSBcIm9iamVjdFwiKSB7XG4gICAgY29uc3QgdCA9IGkudG9TdHJpbmcoKTtcbiAgICByZXR1cm4gdCA9PT0gXCJbb2JqZWN0IENhbnZhc1BhdHRlcm5dXCIgfHwgdCA9PT0gXCJbb2JqZWN0IENhbnZhc0dyYWRpZW50XVwiO1xuICB9XG4gIHJldHVybiAhMTtcbn1cbmZ1bmN0aW9uIG5zKGkpIHtcbiAgcmV0dXJuIHZuKGkpID8gaSA6IHluKGkpO1xufVxuZnVuY3Rpb24gb2koaSkge1xuICByZXR1cm4gdm4oaSkgPyBpIDogeW4oaSkuc2F0dXJhdGUoMC41KS5kYXJrZW4oMC4xKS5oZXhTdHJpbmcoKTtcbn1cbmNvbnN0IEF0ID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCksIF9pID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG5mdW5jdGlvbiBpZShpLCB0KSB7XG4gIGlmICghdClcbiAgICByZXR1cm4gaTtcbiAgY29uc3QgZSA9IHQuc3BsaXQoXCIuXCIpO1xuICBmb3IgKGxldCBzID0gMCwgbiA9IGUubGVuZ3RoOyBzIDwgbjsgKytzKSB7XG4gICAgY29uc3QgbyA9IGVbc107XG4gICAgaSA9IGlbb10gfHwgKGlbb10gPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gIH1cbiAgcmV0dXJuIGk7XG59XG5mdW5jdGlvbiByaShpLCB0LCBlKSB7XG4gIHJldHVybiB0eXBlb2YgdCA9PSBcInN0cmluZ1wiID8gbmUoaWUoaSwgdCksIGUpIDogbmUoaWUoaSwgXCJcIiksIHQpO1xufVxuY2xhc3Mgb3Ige1xuICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgdGhpcy5hbmltYXRpb24gPSB2b2lkIDAsIHRoaXMuYmFja2dyb3VuZENvbG9yID0gXCJyZ2JhKDAsMCwwLDAuMSlcIiwgdGhpcy5ib3JkZXJDb2xvciA9IFwicmdiYSgwLDAsMCwwLjEpXCIsIHRoaXMuY29sb3IgPSBcIiM2NjZcIiwgdGhpcy5kYXRhc2V0cyA9IHt9LCB0aGlzLmRldmljZVBpeGVsUmF0aW8gPSAoZSkgPT4gZS5jaGFydC5wbGF0Zm9ybS5nZXREZXZpY2VQaXhlbFJhdGlvKCksIHRoaXMuZWxlbWVudHMgPSB7fSwgdGhpcy5ldmVudHMgPSBbXG4gICAgICBcIm1vdXNlbW92ZVwiLFxuICAgICAgXCJtb3VzZW91dFwiLFxuICAgICAgXCJjbGlja1wiLFxuICAgICAgXCJ0b3VjaHN0YXJ0XCIsXG4gICAgICBcInRvdWNobW92ZVwiXG4gICAgXSwgdGhpcy5mb250ID0ge1xuICAgICAgZmFtaWx5OiBcIidIZWx2ZXRpY2EgTmV1ZScsICdIZWx2ZXRpY2EnLCAnQXJpYWwnLCBzYW5zLXNlcmlmXCIsXG4gICAgICBzaXplOiAxMixcbiAgICAgIHN0eWxlOiBcIm5vcm1hbFwiLFxuICAgICAgbGluZUhlaWdodDogMS4yLFxuICAgICAgd2VpZ2h0OiBudWxsXG4gICAgfSwgdGhpcy5ob3ZlciA9IHt9LCB0aGlzLmhvdmVyQmFja2dyb3VuZENvbG9yID0gKGUsIHMpID0+IG9pKHMuYmFja2dyb3VuZENvbG9yKSwgdGhpcy5ob3ZlckJvcmRlckNvbG9yID0gKGUsIHMpID0+IG9pKHMuYm9yZGVyQ29sb3IpLCB0aGlzLmhvdmVyQ29sb3IgPSAoZSwgcykgPT4gb2kocy5jb2xvciksIHRoaXMuaW5kZXhBeGlzID0gXCJ4XCIsIHRoaXMuaW50ZXJhY3Rpb24gPSB7XG4gICAgICBtb2RlOiBcIm5lYXJlc3RcIixcbiAgICAgIGludGVyc2VjdDogITAsXG4gICAgICBpbmNsdWRlSW52aXNpYmxlOiAhMVxuICAgIH0sIHRoaXMubWFpbnRhaW5Bc3BlY3RSYXRpbyA9ICEwLCB0aGlzLm9uSG92ZXIgPSBudWxsLCB0aGlzLm9uQ2xpY2sgPSBudWxsLCB0aGlzLnBhcnNpbmcgPSAhMCwgdGhpcy5wbHVnaW5zID0ge30sIHRoaXMucmVzcG9uc2l2ZSA9ICEwLCB0aGlzLnNjYWxlID0gdm9pZCAwLCB0aGlzLnNjYWxlcyA9IHt9LCB0aGlzLnNob3dMaW5lID0gITAsIHRoaXMuZHJhd0FjdGl2ZUVsZW1lbnRzT25Ub3AgPSAhMCwgdGhpcy5kZXNjcmliZSh0KTtcbiAgfVxuICBzZXQodCwgZSkge1xuICAgIHJldHVybiByaSh0aGlzLCB0LCBlKTtcbiAgfVxuICBnZXQodCkge1xuICAgIHJldHVybiBpZSh0aGlzLCB0KTtcbiAgfVxuICBkZXNjcmliZSh0LCBlKSB7XG4gICAgcmV0dXJuIHJpKF9pLCB0LCBlKTtcbiAgfVxuICBvdmVycmlkZSh0LCBlKSB7XG4gICAgcmV0dXJuIHJpKEF0LCB0LCBlKTtcbiAgfVxuICByb3V0ZSh0LCBlLCBzLCBuKSB7XG4gICAgY29uc3QgbyA9IGllKHRoaXMsIHQpLCByID0gaWUodGhpcywgcyksIGEgPSBcIl9cIiArIGU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMobywge1xuICAgICAgW2FdOiB7XG4gICAgICAgIHZhbHVlOiBvW2VdLFxuICAgICAgICB3cml0YWJsZTogITBcbiAgICAgIH0sXG4gICAgICBbZV06IHtcbiAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICBjb25zdCBsID0gdGhpc1thXSwgYyA9IHJbbl07XG4gICAgICAgICAgcmV0dXJuIEQobCkgPyBPYmplY3QuYXNzaWduKHt9LCBjLCBsKSA6IEMobCwgYyk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldChsKSB7XG4gICAgICAgICAgdGhpc1thXSA9IGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxudmFyIE8gPSBuZXcgb3Ioe1xuICBfc2NyaXB0YWJsZTogKGkpID0+ICFpLnN0YXJ0c1dpdGgoXCJvblwiKSxcbiAgX2luZGV4YWJsZTogKGkpID0+IGkgIT09IFwiZXZlbnRzXCIsXG4gIGhvdmVyOiB7XG4gICAgX2ZhbGxiYWNrOiBcImludGVyYWN0aW9uXCJcbiAgfSxcbiAgaW50ZXJhY3Rpb246IHtcbiAgICBfc2NyaXB0YWJsZTogITEsXG4gICAgX2luZGV4YWJsZTogITFcbiAgfVxufSk7XG5mdW5jdGlvbiBycihpKSB7XG4gIHJldHVybiAhaSB8fCBUKGkuc2l6ZSkgfHwgVChpLmZhbWlseSkgPyBudWxsIDogKGkuc3R5bGUgPyBpLnN0eWxlICsgXCIgXCIgOiBcIlwiKSArIChpLndlaWdodCA/IGkud2VpZ2h0ICsgXCIgXCIgOiBcIlwiKSArIGkuc2l6ZSArIFwicHggXCIgKyBpLmZhbWlseTtcbn1cbmZ1bmN0aW9uIE5lKGksIHQsIGUsIHMsIG4pIHtcbiAgbGV0IG8gPSB0W25dO1xuICByZXR1cm4gbyB8fCAobyA9IHRbbl0gPSBpLm1lYXN1cmVUZXh0KG4pLndpZHRoLCBlLnB1c2gobikpLCBvID4gcyAmJiAocyA9IG8pLCBzO1xufVxuZnVuY3Rpb24gYXIoaSwgdCwgZSwgcykge1xuICBzID0gcyB8fCB7fTtcbiAgbGV0IG4gPSBzLmRhdGEgPSBzLmRhdGEgfHwge30sIG8gPSBzLmdhcmJhZ2VDb2xsZWN0ID0gcy5nYXJiYWdlQ29sbGVjdCB8fCBbXTtcbiAgcy5mb250ICE9PSB0ICYmIChuID0gcy5kYXRhID0ge30sIG8gPSBzLmdhcmJhZ2VDb2xsZWN0ID0gW10sIHMuZm9udCA9IHQpLCBpLnNhdmUoKSwgaS5mb250ID0gdDtcbiAgbGV0IHIgPSAwO1xuICBjb25zdCBhID0gZS5sZW5ndGg7XG4gIGxldCBsLCBjLCBoLCBkLCB1O1xuICBmb3IgKGwgPSAwOyBsIDwgYTsgbCsrKVxuICAgIGlmIChkID0gZVtsXSwgZCAhPSBudWxsICYmIHooZCkgIT09ICEwKVxuICAgICAgciA9IE5lKGksIG4sIG8sIHIsIGQpO1xuICAgIGVsc2UgaWYgKHooZCkpXG4gICAgICBmb3IgKGMgPSAwLCBoID0gZC5sZW5ndGg7IGMgPCBoOyBjKyspXG4gICAgICAgIHUgPSBkW2NdLCB1ICE9IG51bGwgJiYgIXoodSkgJiYgKHIgPSBOZShpLCBuLCBvLCByLCB1KSk7XG4gIGkucmVzdG9yZSgpO1xuICBjb25zdCBmID0gby5sZW5ndGggLyAyO1xuICBpZiAoZiA+IGUubGVuZ3RoKSB7XG4gICAgZm9yIChsID0gMDsgbCA8IGY7IGwrKylcbiAgICAgIGRlbGV0ZSBuW29bbF1dO1xuICAgIG8uc3BsaWNlKDAsIGYpO1xuICB9XG4gIHJldHVybiByO1xufVxuZnVuY3Rpb24gd3QoaSwgdCwgZSkge1xuICBjb25zdCBzID0gaS5jdXJyZW50RGV2aWNlUGl4ZWxSYXRpbywgbiA9IGUgIT09IDAgPyBNYXRoLm1heChlIC8gMiwgMC41KSA6IDA7XG4gIHJldHVybiBNYXRoLnJvdW5kKCh0IC0gbikgKiBzKSAvIHMgKyBuO1xufVxuZnVuY3Rpb24gb3MoaSwgdCkge1xuICB0ID0gdCB8fCBpLmdldENvbnRleHQoXCIyZFwiKSwgdC5zYXZlKCksIHQucmVzZXRUcmFuc2Zvcm0oKSwgdC5jbGVhclJlY3QoMCwgMCwgaS53aWR0aCwgaS5oZWlnaHQpLCB0LnJlc3RvcmUoKTtcbn1cbmZ1bmN0aW9uIHlpKGksIHQsIGUsIHMpIHtcbiAgTW4oaSwgdCwgZSwgcywgbnVsbCk7XG59XG5mdW5jdGlvbiBNbihpLCB0LCBlLCBzLCBuKSB7XG4gIGxldCBvLCByLCBhLCBsLCBjLCBoO1xuICBjb25zdCBkID0gdC5wb2ludFN0eWxlLCB1ID0gdC5yb3RhdGlvbiwgZiA9IHQucmFkaXVzO1xuICBsZXQgZyA9ICh1IHx8IDApICogQ287XG4gIGlmIChkICYmIHR5cGVvZiBkID09IFwib2JqZWN0XCIgJiYgKG8gPSBkLnRvU3RyaW5nKCksIG8gPT09IFwiW29iamVjdCBIVE1MSW1hZ2VFbGVtZW50XVwiIHx8IG8gPT09IFwiW29iamVjdCBIVE1MQ2FudmFzRWxlbWVudF1cIikpIHtcbiAgICBpLnNhdmUoKSwgaS50cmFuc2xhdGUoZSwgcyksIGkucm90YXRlKGcpLCBpLmRyYXdJbWFnZShkLCAtZC53aWR0aCAvIDIsIC1kLmhlaWdodCAvIDIsIGQud2lkdGgsIGQuaGVpZ2h0KSwgaS5yZXN0b3JlKCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghKGlzTmFOKGYpIHx8IGYgPD0gMCkpIHtcbiAgICBzd2l0Y2ggKGkuYmVnaW5QYXRoKCksIGQpIHtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIG4gPyBpLmVsbGlwc2UoZSwgcywgbiAvIDIsIGYsIDAsIDAsIEYpIDogaS5hcmMoZSwgcywgZiwgMCwgRiksIGkuY2xvc2VQYXRoKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInRyaWFuZ2xlXCI6XG4gICAgICAgIGkubW92ZVRvKGUgKyBNYXRoLnNpbihnKSAqIGYsIHMgLSBNYXRoLmNvcyhnKSAqIGYpLCBnICs9IEtpLCBpLmxpbmVUbyhlICsgTWF0aC5zaW4oZykgKiBmLCBzIC0gTWF0aC5jb3MoZykgKiBmKSwgZyArPSBLaSwgaS5saW5lVG8oZSArIE1hdGguc2luKGcpICogZiwgcyAtIE1hdGguY29zKGcpICogZiksIGkuY2xvc2VQYXRoKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInJlY3RSb3VuZGVkXCI6XG4gICAgICAgIGMgPSBmICogMC41MTYsIGwgPSBmIC0gYywgciA9IE1hdGguY29zKGcgKyAkdCkgKiBsLCBhID0gTWF0aC5zaW4oZyArICR0KSAqIGwsIGkuYXJjKGUgLSByLCBzIC0gYSwgYywgZyAtIEIsIGcgLSBWKSwgaS5hcmMoZSArIGEsIHMgLSByLCBjLCBnIC0gViwgZyksIGkuYXJjKGUgKyByLCBzICsgYSwgYywgZywgZyArIFYpLCBpLmFyYyhlIC0gYSwgcyArIHIsIGMsIGcgKyBWLCBnICsgQiksIGkuY2xvc2VQYXRoKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInJlY3RcIjpcbiAgICAgICAgaWYgKCF1KSB7XG4gICAgICAgICAgbCA9IE1hdGguU1FSVDFfMiAqIGYsIGggPSBuID8gbiAvIDIgOiBsLCBpLnJlY3QoZSAtIGgsIHMgLSBsLCAyICogaCwgMiAqIGwpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGcgKz0gJHQ7XG4gICAgICBjYXNlIFwicmVjdFJvdFwiOlxuICAgICAgICByID0gTWF0aC5jb3MoZykgKiBmLCBhID0gTWF0aC5zaW4oZykgKiBmLCBpLm1vdmVUbyhlIC0gciwgcyAtIGEpLCBpLmxpbmVUbyhlICsgYSwgcyAtIHIpLCBpLmxpbmVUbyhlICsgciwgcyArIGEpLCBpLmxpbmVUbyhlIC0gYSwgcyArIHIpLCBpLmNsb3NlUGF0aCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJjcm9zc1JvdFwiOlxuICAgICAgICBnICs9ICR0O1xuICAgICAgY2FzZSBcImNyb3NzXCI6XG4gICAgICAgIHIgPSBNYXRoLmNvcyhnKSAqIGYsIGEgPSBNYXRoLnNpbihnKSAqIGYsIGkubW92ZVRvKGUgLSByLCBzIC0gYSksIGkubGluZVRvKGUgKyByLCBzICsgYSksIGkubW92ZVRvKGUgKyBhLCBzIC0gciksIGkubGluZVRvKGUgLSBhLCBzICsgcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInN0YXJcIjpcbiAgICAgICAgciA9IE1hdGguY29zKGcpICogZiwgYSA9IE1hdGguc2luKGcpICogZiwgaS5tb3ZlVG8oZSAtIHIsIHMgLSBhKSwgaS5saW5lVG8oZSArIHIsIHMgKyBhKSwgaS5tb3ZlVG8oZSArIGEsIHMgLSByKSwgaS5saW5lVG8oZSAtIGEsIHMgKyByKSwgZyArPSAkdCwgciA9IE1hdGguY29zKGcpICogZiwgYSA9IE1hdGguc2luKGcpICogZiwgaS5tb3ZlVG8oZSAtIHIsIHMgLSBhKSwgaS5saW5lVG8oZSArIHIsIHMgKyBhKSwgaS5tb3ZlVG8oZSArIGEsIHMgLSByKSwgaS5saW5lVG8oZSAtIGEsIHMgKyByKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibGluZVwiOlxuICAgICAgICByID0gbiA/IG4gLyAyIDogTWF0aC5jb3MoZykgKiBmLCBhID0gTWF0aC5zaW4oZykgKiBmLCBpLm1vdmVUbyhlIC0gciwgcyAtIGEpLCBpLmxpbmVUbyhlICsgciwgcyArIGEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJkYXNoXCI6XG4gICAgICAgIGkubW92ZVRvKGUsIHMpLCBpLmxpbmVUbyhlICsgTWF0aC5jb3MoZykgKiBmLCBzICsgTWF0aC5zaW4oZykgKiBmKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGkuZmlsbCgpLCB0LmJvcmRlcldpZHRoID4gMCAmJiBpLnN0cm9rZSgpO1xuICB9XG59XG5mdW5jdGlvbiByZShpLCB0LCBlKSB7XG4gIHJldHVybiBlID0gZSB8fCAwLjUsICF0IHx8IGkgJiYgaS54ID4gdC5sZWZ0IC0gZSAmJiBpLnggPCB0LnJpZ2h0ICsgZSAmJiBpLnkgPiB0LnRvcCAtIGUgJiYgaS55IDwgdC5ib3R0b20gKyBlO1xufVxuZnVuY3Rpb24gWGUoaSwgdCkge1xuICBpLnNhdmUoKSwgaS5iZWdpblBhdGgoKSwgaS5yZWN0KHQubGVmdCwgdC50b3AsIHQucmlnaHQgLSB0LmxlZnQsIHQuYm90dG9tIC0gdC50b3ApLCBpLmNsaXAoKTtcbn1cbmZ1bmN0aW9uIFVlKGkpIHtcbiAgaS5yZXN0b3JlKCk7XG59XG5mdW5jdGlvbiBscihpLCB0LCBlLCBzLCBuKSB7XG4gIGlmICghdClcbiAgICByZXR1cm4gaS5saW5lVG8oZS54LCBlLnkpO1xuICBpZiAobiA9PT0gXCJtaWRkbGVcIikge1xuICAgIGNvbnN0IG8gPSAodC54ICsgZS54KSAvIDI7XG4gICAgaS5saW5lVG8obywgdC55KSwgaS5saW5lVG8obywgZS55KTtcbiAgfSBlbHNlXG4gICAgbiA9PT0gXCJhZnRlclwiICE9ICEhcyA/IGkubGluZVRvKHQueCwgZS55KSA6IGkubGluZVRvKGUueCwgdC55KTtcbiAgaS5saW5lVG8oZS54LCBlLnkpO1xufVxuZnVuY3Rpb24gY3IoaSwgdCwgZSwgcykge1xuICBpZiAoIXQpXG4gICAgcmV0dXJuIGkubGluZVRvKGUueCwgZS55KTtcbiAgaS5iZXppZXJDdXJ2ZVRvKFxuICAgIHMgPyB0LmNwMXggOiB0LmNwMngsXG4gICAgcyA/IHQuY3AxeSA6IHQuY3AyeSxcbiAgICBzID8gZS5jcDJ4IDogZS5jcDF4LFxuICAgIHMgPyBlLmNwMnkgOiBlLmNwMXksXG4gICAgZS54LFxuICAgIGUueVxuICApO1xufVxuZnVuY3Rpb24gVHQoaSwgdCwgZSwgcywgbiwgbyA9IHt9KSB7XG4gIGNvbnN0IHIgPSB6KHQpID8gdCA6IFt0XSwgYSA9IG8uc3Ryb2tlV2lkdGggPiAwICYmIG8uc3Ryb2tlQ29sb3IgIT09IFwiXCI7XG4gIGxldCBsLCBjO1xuICBmb3IgKGkuc2F2ZSgpLCBpLmZvbnQgPSBuLnN0cmluZywgaHIoaSwgbyksIGwgPSAwOyBsIDwgci5sZW5ndGg7ICsrbClcbiAgICBjID0gcltsXSwgYSAmJiAoby5zdHJva2VDb2xvciAmJiAoaS5zdHJva2VTdHlsZSA9IG8uc3Ryb2tlQ29sb3IpLCBUKG8uc3Ryb2tlV2lkdGgpIHx8IChpLmxpbmVXaWR0aCA9IG8uc3Ryb2tlV2lkdGgpLCBpLnN0cm9rZVRleHQoYywgZSwgcywgby5tYXhXaWR0aCkpLCBpLmZpbGxUZXh0KGMsIGUsIHMsIG8ubWF4V2lkdGgpLCBkcihpLCBlLCBzLCBjLCBvKSwgcyArPSBuLmxpbmVIZWlnaHQ7XG4gIGkucmVzdG9yZSgpO1xufVxuZnVuY3Rpb24gaHIoaSwgdCkge1xuICB0LnRyYW5zbGF0aW9uICYmIGkudHJhbnNsYXRlKHQudHJhbnNsYXRpb25bMF0sIHQudHJhbnNsYXRpb25bMV0pLCBUKHQucm90YXRpb24pIHx8IGkucm90YXRlKHQucm90YXRpb24pLCB0LmNvbG9yICYmIChpLmZpbGxTdHlsZSA9IHQuY29sb3IpLCB0LnRleHRBbGlnbiAmJiAoaS50ZXh0QWxpZ24gPSB0LnRleHRBbGlnbiksIHQudGV4dEJhc2VsaW5lICYmIChpLnRleHRCYXNlbGluZSA9IHQudGV4dEJhc2VsaW5lKTtcbn1cbmZ1bmN0aW9uIGRyKGksIHQsIGUsIHMsIG4pIHtcbiAgaWYgKG4uc3RyaWtldGhyb3VnaCB8fCBuLnVuZGVybGluZSkge1xuICAgIGNvbnN0IG8gPSBpLm1lYXN1cmVUZXh0KHMpLCByID0gdCAtIG8uYWN0dWFsQm91bmRpbmdCb3hMZWZ0LCBhID0gdCArIG8uYWN0dWFsQm91bmRpbmdCb3hSaWdodCwgbCA9IGUgLSBvLmFjdHVhbEJvdW5kaW5nQm94QXNjZW50LCBjID0gZSArIG8uYWN0dWFsQm91bmRpbmdCb3hEZXNjZW50LCBoID0gbi5zdHJpa2V0aHJvdWdoID8gKGwgKyBjKSAvIDIgOiBjO1xuICAgIGkuc3Ryb2tlU3R5bGUgPSBpLmZpbGxTdHlsZSwgaS5iZWdpblBhdGgoKSwgaS5saW5lV2lkdGggPSBuLmRlY29yYXRpb25XaWR0aCB8fCAyLCBpLm1vdmVUbyhyLCBoKSwgaS5saW5lVG8oYSwgaCksIGkuc3Ryb2tlKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGFlKGksIHQpIHtcbiAgY29uc3QgeyB4OiBlLCB5OiBzLCB3OiBuLCBoOiBvLCByYWRpdXM6IHIgfSA9IHQ7XG4gIGkuYXJjKGUgKyByLnRvcExlZnQsIHMgKyByLnRvcExlZnQsIHIudG9wTGVmdCwgLVYsIEIsICEwKSwgaS5saW5lVG8oZSwgcyArIG8gLSByLmJvdHRvbUxlZnQpLCBpLmFyYyhlICsgci5ib3R0b21MZWZ0LCBzICsgbyAtIHIuYm90dG9tTGVmdCwgci5ib3R0b21MZWZ0LCBCLCBWLCAhMCksIGkubGluZVRvKGUgKyBuIC0gci5ib3R0b21SaWdodCwgcyArIG8pLCBpLmFyYyhlICsgbiAtIHIuYm90dG9tUmlnaHQsIHMgKyBvIC0gci5ib3R0b21SaWdodCwgci5ib3R0b21SaWdodCwgViwgMCwgITApLCBpLmxpbmVUbyhlICsgbiwgcyArIHIudG9wUmlnaHQpLCBpLmFyYyhlICsgbiAtIHIudG9wUmlnaHQsIHMgKyByLnRvcFJpZ2h0LCByLnRvcFJpZ2h0LCAwLCAtViwgITApLCBpLmxpbmVUbyhlICsgci50b3BMZWZ0LCBzKTtcbn1cbmNvbnN0IHVyID0gbmV3IFJlZ0V4cCgvXihub3JtYWx8KFxcZCsoPzpcXC5cXGQrKT8pKHB4fGVtfCUpPykkLyksIGZyID0gbmV3IFJlZ0V4cCgvXihub3JtYWx8aXRhbGljfGluaXRpYWx8aW5oZXJpdHx1bnNldHwob2JsaXF1ZSggLT9bMC05XT9bMC05XWRlZyk/KSkkLyk7XG5mdW5jdGlvbiBncihpLCB0KSB7XG4gIGNvbnN0IGUgPSAoXCJcIiArIGkpLm1hdGNoKHVyKTtcbiAgaWYgKCFlIHx8IGVbMV0gPT09IFwibm9ybWFsXCIpXG4gICAgcmV0dXJuIHQgKiAxLjI7XG4gIHN3aXRjaCAoaSA9ICtlWzJdLCBlWzNdKSB7XG4gICAgY2FzZSBcInB4XCI6XG4gICAgICByZXR1cm4gaTtcbiAgICBjYXNlIFwiJVwiOlxuICAgICAgaSAvPSAxMDA7XG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4gdCAqIGk7XG59XG5jb25zdCBwciA9IChpKSA9PiAraSB8fCAwO1xuZnVuY3Rpb24gSWkoaSwgdCkge1xuICBjb25zdCBlID0ge30sIHMgPSBEKHQpLCBuID0gcyA/IE9iamVjdC5rZXlzKHQpIDogdCwgbyA9IEQoaSkgPyBzID8gKHIpID0+IEMoaVtyXSwgaVt0W3JdXSkgOiAocikgPT4gaVtyXSA6ICgpID0+IGk7XG4gIGZvciAoY29uc3QgciBvZiBuKVxuICAgIGVbcl0gPSBwcihvKHIpKTtcbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBrbihpKSB7XG4gIHJldHVybiBJaShpLCB7IHRvcDogXCJ5XCIsIHJpZ2h0OiBcInhcIiwgYm90dG9tOiBcInlcIiwgbGVmdDogXCJ4XCIgfSk7XG59XG5mdW5jdGlvbiBEdChpKSB7XG4gIHJldHVybiBJaShpLCBbXCJ0b3BMZWZ0XCIsIFwidG9wUmlnaHRcIiwgXCJib3R0b21MZWZ0XCIsIFwiYm90dG9tUmlnaHRcIl0pO1xufVxuZnVuY3Rpb24gSyhpKSB7XG4gIGNvbnN0IHQgPSBrbihpKTtcbiAgcmV0dXJuIHQud2lkdGggPSB0LmxlZnQgKyB0LnJpZ2h0LCB0LmhlaWdodCA9IHQudG9wICsgdC5ib3R0b20sIHQ7XG59XG5mdW5jdGlvbiAkKGksIHQpIHtcbiAgaSA9IGkgfHwge30sIHQgPSB0IHx8IE8uZm9udDtcbiAgbGV0IGUgPSBDKGkuc2l6ZSwgdC5zaXplKTtcbiAgdHlwZW9mIGUgPT0gXCJzdHJpbmdcIiAmJiAoZSA9IHBhcnNlSW50KGUsIDEwKSk7XG4gIGxldCBzID0gQyhpLnN0eWxlLCB0LnN0eWxlKTtcbiAgcyAmJiAhKFwiXCIgKyBzKS5tYXRjaChmcikgJiYgKGNvbnNvbGUud2FybignSW52YWxpZCBmb250IHN0eWxlIHNwZWNpZmllZDogXCInICsgcyArICdcIicpLCBzID0gXCJcIik7XG4gIGNvbnN0IG4gPSB7XG4gICAgZmFtaWx5OiBDKGkuZmFtaWx5LCB0LmZhbWlseSksXG4gICAgbGluZUhlaWdodDogZ3IoQyhpLmxpbmVIZWlnaHQsIHQubGluZUhlaWdodCksIGUpLFxuICAgIHNpemU6IGUsXG4gICAgc3R5bGU6IHMsXG4gICAgd2VpZ2h0OiBDKGkud2VpZ2h0LCB0LndlaWdodCksXG4gICAgc3RyaW5nOiBcIlwiXG4gIH07XG4gIHJldHVybiBuLnN0cmluZyA9IHJyKG4pLCBuO1xufVxuZnVuY3Rpb24gWnQoaSwgdCwgZSwgcykge1xuICBsZXQgbiA9ICEwLCBvLCByLCBhO1xuICBmb3IgKG8gPSAwLCByID0gaS5sZW5ndGg7IG8gPCByOyArK28pXG4gICAgaWYgKGEgPSBpW29dLCBhICE9PSB2b2lkIDAgJiYgKHQgIT09IHZvaWQgMCAmJiB0eXBlb2YgYSA9PSBcImZ1bmN0aW9uXCIgJiYgKGEgPSBhKHQpLCBuID0gITEpLCBlICE9PSB2b2lkIDAgJiYgeihhKSAmJiAoYSA9IGFbZSAlIGEubGVuZ3RoXSwgbiA9ICExKSwgYSAhPT0gdm9pZCAwKSlcbiAgICAgIHJldHVybiBzICYmICFuICYmIChzLmNhY2hlYWJsZSA9ICExKSwgYTtcbn1cbmZ1bmN0aW9uIG1yKGksIHQsIGUpIHtcbiAgY29uc3QgeyBtaW46IHMsIG1heDogbiB9ID0gaSwgbyA9IGFuKHQsIChuIC0gcykgLyAyKSwgciA9IChhLCBsKSA9PiBlICYmIGEgPT09IDAgPyAwIDogYSArIGw7XG4gIHJldHVybiB7XG4gICAgbWluOiByKHMsIC1NYXRoLmFicyhvKSksXG4gICAgbWF4OiByKG4sIG8pXG4gIH07XG59XG5mdW5jdGlvbiB2dChpLCB0KSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUoaSksIHQpO1xufVxuZnVuY3Rpb24gemkoaSwgdCA9IFtcIlwiXSwgZSA9IGksIHMsIG4gPSAoKSA9PiBpWzBdKSB7XG4gIGV0KHMpIHx8IChzID0gQ24oXCJfZmFsbGJhY2tcIiwgaSkpO1xuICBjb25zdCBvID0ge1xuICAgIFtTeW1ib2wudG9TdHJpbmdUYWddOiBcIk9iamVjdFwiLFxuICAgIF9jYWNoZWFibGU6ICEwLFxuICAgIF9zY29wZXM6IGksXG4gICAgX3Jvb3RTY29wZXM6IGUsXG4gICAgX2ZhbGxiYWNrOiBzLFxuICAgIF9nZXRUYXJnZXQ6IG4sXG4gICAgb3ZlcnJpZGU6IChyKSA9PiB6aShbciwgLi4uaV0sIHQsIGUsIHMpXG4gIH07XG4gIHJldHVybiBuZXcgUHJveHkobywge1xuICAgIGRlbGV0ZVByb3BlcnR5KHIsIGEpIHtcbiAgICAgIHJldHVybiBkZWxldGUgclthXSwgZGVsZXRlIHIuX2tleXMsIGRlbGV0ZSBpWzBdW2FdLCAhMDtcbiAgICB9LFxuICAgIGdldChyLCBhKSB7XG4gICAgICByZXR1cm4gU24oXG4gICAgICAgIHIsXG4gICAgICAgIGEsXG4gICAgICAgICgpID0+IHdyKGEsIHQsIGksIHIpXG4gICAgICApO1xuICAgIH0sXG4gICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHIsIGEpIHtcbiAgICAgIHJldHVybiBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihyLl9zY29wZXNbMF0sIGEpO1xuICAgIH0sXG4gICAgZ2V0UHJvdG90eXBlT2YoKSB7XG4gICAgICByZXR1cm4gUmVmbGVjdC5nZXRQcm90b3R5cGVPZihpWzBdKTtcbiAgICB9LFxuICAgIGhhcyhyLCBhKSB7XG4gICAgICByZXR1cm4gYXMocikuaW5jbHVkZXMoYSk7XG4gICAgfSxcbiAgICBvd25LZXlzKHIpIHtcbiAgICAgIHJldHVybiBhcyhyKTtcbiAgICB9LFxuICAgIHNldChyLCBhLCBsKSB7XG4gICAgICBjb25zdCBjID0gci5fc3RvcmFnZSB8fCAoci5fc3RvcmFnZSA9IG4oKSk7XG4gICAgICByZXR1cm4gclthXSA9IGNbYV0gPSBsLCBkZWxldGUgci5fa2V5cywgITA7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIFZ0KGksIHQsIGUsIHMpIHtcbiAgY29uc3QgbiA9IHtcbiAgICBfY2FjaGVhYmxlOiAhMSxcbiAgICBfcHJveHk6IGksXG4gICAgX2NvbnRleHQ6IHQsXG4gICAgX3N1YlByb3h5OiBlLFxuICAgIF9zdGFjazogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSxcbiAgICBfZGVzY3JpcHRvcnM6IHduKGksIHMpLFxuICAgIHNldENvbnRleHQ6IChvKSA9PiBWdChpLCBvLCBlLCBzKSxcbiAgICBvdmVycmlkZTogKG8pID0+IFZ0KGkub3ZlcnJpZGUobyksIHQsIGUsIHMpXG4gIH07XG4gIHJldHVybiBuZXcgUHJveHkobiwge1xuICAgIGRlbGV0ZVByb3BlcnR5KG8sIHIpIHtcbiAgICAgIHJldHVybiBkZWxldGUgb1tyXSwgZGVsZXRlIGlbcl0sICEwO1xuICAgIH0sXG4gICAgZ2V0KG8sIHIsIGEpIHtcbiAgICAgIHJldHVybiBTbihcbiAgICAgICAgbyxcbiAgICAgICAgcixcbiAgICAgICAgKCkgPT4geHIobywgciwgYSlcbiAgICAgICk7XG4gICAgfSxcbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iobywgcikge1xuICAgICAgcmV0dXJuIG8uX2Rlc2NyaXB0b3JzLmFsbEtleXMgPyBSZWZsZWN0LmhhcyhpLCByKSA/IHsgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAgfSA6IHZvaWQgMCA6IFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGksIHIpO1xuICAgIH0sXG4gICAgZ2V0UHJvdG90eXBlT2YoKSB7XG4gICAgICByZXR1cm4gUmVmbGVjdC5nZXRQcm90b3R5cGVPZihpKTtcbiAgICB9LFxuICAgIGhhcyhvLCByKSB7XG4gICAgICByZXR1cm4gUmVmbGVjdC5oYXMoaSwgcik7XG4gICAgfSxcbiAgICBvd25LZXlzKCkge1xuICAgICAgcmV0dXJuIFJlZmxlY3Qub3duS2V5cyhpKTtcbiAgICB9LFxuICAgIHNldChvLCByLCBhKSB7XG4gICAgICByZXR1cm4gaVtyXSA9IGEsIGRlbGV0ZSBvW3JdLCAhMDtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gd24oaSwgdCA9IHsgc2NyaXB0YWJsZTogITAsIGluZGV4YWJsZTogITAgfSkge1xuICBjb25zdCB7IF9zY3JpcHRhYmxlOiBlID0gdC5zY3JpcHRhYmxlLCBfaW5kZXhhYmxlOiBzID0gdC5pbmRleGFibGUsIF9hbGxLZXlzOiBuID0gdC5hbGxLZXlzIH0gPSBpO1xuICByZXR1cm4ge1xuICAgIGFsbEtleXM6IG4sXG4gICAgc2NyaXB0YWJsZTogZSxcbiAgICBpbmRleGFibGU6IHMsXG4gICAgaXNTY3JpcHRhYmxlOiB5dChlKSA/IGUgOiAoKSA9PiBlLFxuICAgIGlzSW5kZXhhYmxlOiB5dChzKSA/IHMgOiAoKSA9PiBzXG4gIH07XG59XG5jb25zdCBiciA9IChpLCB0KSA9PiBpID8gaSArIE9pKHQpIDogdCwgQmkgPSAoaSwgdCkgPT4gRCh0KSAmJiBpICE9PSBcImFkYXB0ZXJzXCIgJiYgKE9iamVjdC5nZXRQcm90b3R5cGVPZih0KSA9PT0gbnVsbCB8fCB0LmNvbnN0cnVjdG9yID09PSBPYmplY3QpO1xuZnVuY3Rpb24gU24oaSwgdCwgZSkge1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGksIHQpKVxuICAgIHJldHVybiBpW3RdO1xuICBjb25zdCBzID0gZSgpO1xuICByZXR1cm4gaVt0XSA9IHMsIHM7XG59XG5mdW5jdGlvbiB4cihpLCB0LCBlKSB7XG4gIGNvbnN0IHsgX3Byb3h5OiBzLCBfY29udGV4dDogbiwgX3N1YlByb3h5OiBvLCBfZGVzY3JpcHRvcnM6IHIgfSA9IGk7XG4gIGxldCBhID0gc1t0XTtcbiAgcmV0dXJuIHl0KGEpICYmIHIuaXNTY3JpcHRhYmxlKHQpICYmIChhID0gX3IodCwgYSwgaSwgZSkpLCB6KGEpICYmIGEubGVuZ3RoICYmIChhID0geXIodCwgYSwgaSwgci5pc0luZGV4YWJsZSkpLCBCaSh0LCBhKSAmJiAoYSA9IFZ0KGEsIG4sIG8gJiYgb1t0XSwgcikpLCBhO1xufVxuZnVuY3Rpb24gX3IoaSwgdCwgZSwgcykge1xuICBjb25zdCB7IF9wcm94eTogbiwgX2NvbnRleHQ6IG8sIF9zdWJQcm94eTogciwgX3N0YWNrOiBhIH0gPSBlO1xuICBpZiAoYS5oYXMoaSkpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUmVjdXJzaW9uIGRldGVjdGVkOiBcIiArIEFycmF5LmZyb20oYSkuam9pbihcIi0+XCIpICsgXCItPlwiICsgaSk7XG4gIHJldHVybiBhLmFkZChpKSwgdCA9IHQobywgciB8fCBzKSwgYS5kZWxldGUoaSksIEJpKGksIHQpICYmICh0ID0gVmkobi5fc2NvcGVzLCBuLCBpLCB0KSksIHQ7XG59XG5mdW5jdGlvbiB5cihpLCB0LCBlLCBzKSB7XG4gIGNvbnN0IHsgX3Byb3h5OiBuLCBfY29udGV4dDogbywgX3N1YlByb3h5OiByLCBfZGVzY3JpcHRvcnM6IGEgfSA9IGU7XG4gIGlmIChldChvLmluZGV4KSAmJiBzKGkpKVxuICAgIHQgPSB0W28uaW5kZXggJSB0Lmxlbmd0aF07XG4gIGVsc2UgaWYgKEQodFswXSkpIHtcbiAgICBjb25zdCBsID0gdCwgYyA9IG4uX3Njb3Blcy5maWx0ZXIoKGgpID0+IGggIT09IGwpO1xuICAgIHQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGggb2YgbCkge1xuICAgICAgY29uc3QgZCA9IFZpKGMsIG4sIGksIGgpO1xuICAgICAgdC5wdXNoKFZ0KGQsIG8sIHIgJiYgcltpXSwgYSkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdDtcbn1cbmZ1bmN0aW9uIFBuKGksIHQsIGUpIHtcbiAgcmV0dXJuIHl0KGkpID8gaSh0LCBlKSA6IGk7XG59XG5jb25zdCB2ciA9IChpLCB0KSA9PiBpID09PSAhMCA/IHQgOiB0eXBlb2YgaSA9PSBcInN0cmluZ1wiID8gX3QodCwgaSkgOiB2b2lkIDA7XG5mdW5jdGlvbiBNcihpLCB0LCBlLCBzLCBuKSB7XG4gIGZvciAoY29uc3QgbyBvZiB0KSB7XG4gICAgY29uc3QgciA9IHZyKGUsIG8pO1xuICAgIGlmIChyKSB7XG4gICAgICBpLmFkZChyKTtcbiAgICAgIGNvbnN0IGEgPSBQbihyLl9mYWxsYmFjaywgZSwgbik7XG4gICAgICBpZiAoZXQoYSkgJiYgYSAhPT0gZSAmJiBhICE9PSBzKVxuICAgICAgICByZXR1cm4gYTtcbiAgICB9IGVsc2UgaWYgKHIgPT09ICExICYmIGV0KHMpICYmIGUgIT09IHMpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gITE7XG59XG5mdW5jdGlvbiBWaShpLCB0LCBlLCBzKSB7XG4gIGNvbnN0IG4gPSB0Ll9yb290U2NvcGVzLCBvID0gUG4odC5fZmFsbGJhY2ssIGUsIHMpLCByID0gWy4uLmksIC4uLm5dLCBhID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgYS5hZGQocyk7XG4gIGxldCBsID0gcnMoYSwgciwgZSwgbyB8fCBlLCBzKTtcbiAgcmV0dXJuIGwgPT09IG51bGwgfHwgZXQobykgJiYgbyAhPT0gZSAmJiAobCA9IHJzKGEsIHIsIG8sIGwsIHMpLCBsID09PSBudWxsKSA/ICExIDogemkoXG4gICAgQXJyYXkuZnJvbShhKSxcbiAgICBbXCJcIl0sXG4gICAgbixcbiAgICBvLFxuICAgICgpID0+IGtyKHQsIGUsIHMpXG4gICk7XG59XG5mdW5jdGlvbiBycyhpLCB0LCBlLCBzLCBuKSB7XG4gIGZvciAoOyBlOyApXG4gICAgZSA9IE1yKGksIHQsIGUsIHMsIG4pO1xuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIGtyKGksIHQsIGUpIHtcbiAgY29uc3QgcyA9IGkuX2dldFRhcmdldCgpO1xuICB0IGluIHMgfHwgKHNbdF0gPSB7fSk7XG4gIGNvbnN0IG4gPSBzW3RdO1xuICByZXR1cm4geihuKSAmJiBEKGUpID8gZSA6IG47XG59XG5mdW5jdGlvbiB3cihpLCB0LCBlLCBzKSB7XG4gIGxldCBuO1xuICBmb3IgKGNvbnN0IG8gb2YgdClcbiAgICBpZiAobiA9IENuKGJyKG8sIGkpLCBlKSwgZXQobikpXG4gICAgICByZXR1cm4gQmkoaSwgbikgPyBWaShlLCBzLCBpLCBuKSA6IG47XG59XG5mdW5jdGlvbiBDbihpLCB0KSB7XG4gIGZvciAoY29uc3QgZSBvZiB0KSB7XG4gICAgaWYgKCFlKVxuICAgICAgY29udGludWU7XG4gICAgY29uc3QgcyA9IGVbaV07XG4gICAgaWYgKGV0KHMpKVxuICAgICAgcmV0dXJuIHM7XG4gIH1cbn1cbmZ1bmN0aW9uIGFzKGkpIHtcbiAgbGV0IHQgPSBpLl9rZXlzO1xuICByZXR1cm4gdCB8fCAodCA9IGkuX2tleXMgPSBTcihpLl9zY29wZXMpKSwgdDtcbn1cbmZ1bmN0aW9uIFNyKGkpIHtcbiAgY29uc3QgdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGZvciAoY29uc3QgZSBvZiBpKVxuICAgIGZvciAoY29uc3QgcyBvZiBPYmplY3Qua2V5cyhlKS5maWx0ZXIoKG4pID0+ICFuLnN0YXJ0c1dpdGgoXCJfXCIpKSlcbiAgICAgIHQuYWRkKHMpO1xuICByZXR1cm4gQXJyYXkuZnJvbSh0KTtcbn1cbmZ1bmN0aW9uIERuKGksIHQsIGUsIHMpIHtcbiAgY29uc3QgeyBpU2NhbGU6IG4gfSA9IGksIHsga2V5OiBvID0gXCJyXCIgfSA9IHRoaXMuX3BhcnNpbmcsIHIgPSBuZXcgQXJyYXkocyk7XG4gIGxldCBhLCBsLCBjLCBoO1xuICBmb3IgKGEgPSAwLCBsID0gczsgYSA8IGw7ICsrYSlcbiAgICBjID0gYSArIGUsIGggPSB0W2NdLCByW2FdID0ge1xuICAgICAgcjogbi5wYXJzZShfdChoLCBvKSwgYylcbiAgICB9O1xuICByZXR1cm4gcjtcbn1cbmNvbnN0IFByID0gTnVtYmVyLkVQU0lMT04gfHwgMWUtMTQsIFd0ID0gKGksIHQpID0+IHQgPCBpLmxlbmd0aCAmJiAhaVt0XS5za2lwICYmIGlbdF0sIE9uID0gKGkpID0+IGkgPT09IFwieFwiID8gXCJ5XCIgOiBcInhcIjtcbmZ1bmN0aW9uIENyKGksIHQsIGUsIHMpIHtcbiAgY29uc3QgbiA9IGkuc2tpcCA/IHQgOiBpLCBvID0gdCwgciA9IGUuc2tpcCA/IHQgOiBlLCBhID0gYmkobywgbiksIGwgPSBiaShyLCBvKTtcbiAgbGV0IGMgPSBhIC8gKGEgKyBsKSwgaCA9IGwgLyAoYSArIGwpO1xuICBjID0gaXNOYU4oYykgPyAwIDogYywgaCA9IGlzTmFOKGgpID8gMCA6IGg7XG4gIGNvbnN0IGQgPSBzICogYywgdSA9IHMgKiBoO1xuICByZXR1cm4ge1xuICAgIHByZXZpb3VzOiB7XG4gICAgICB4OiBvLnggLSBkICogKHIueCAtIG4ueCksXG4gICAgICB5OiBvLnkgLSBkICogKHIueSAtIG4ueSlcbiAgICB9LFxuICAgIG5leHQ6IHtcbiAgICAgIHg6IG8ueCArIHUgKiAoci54IC0gbi54KSxcbiAgICAgIHk6IG8ueSArIHUgKiAoci55IC0gbi55KVxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIERyKGksIHQsIGUpIHtcbiAgY29uc3QgcyA9IGkubGVuZ3RoO1xuICBsZXQgbiwgbywgciwgYSwgbCwgYyA9IFd0KGksIDApO1xuICBmb3IgKGxldCBoID0gMDsgaCA8IHMgLSAxOyArK2gpXG4gICAgaWYgKGwgPSBjLCBjID0gV3QoaSwgaCArIDEpLCAhKCFsIHx8ICFjKSkge1xuICAgICAgaWYgKHRlKHRbaF0sIDAsIFByKSkge1xuICAgICAgICBlW2hdID0gZVtoICsgMV0gPSAwO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIG4gPSBlW2hdIC8gdFtoXSwgbyA9IGVbaCArIDFdIC8gdFtoXSwgYSA9IE1hdGgucG93KG4sIDIpICsgTWF0aC5wb3cobywgMiksICEoYSA8PSA5KSAmJiAociA9IDMgLyBNYXRoLnNxcnQoYSksIGVbaF0gPSBuICogciAqIHRbaF0sIGVbaCArIDFdID0gbyAqIHIgKiB0W2hdKTtcbiAgICB9XG59XG5mdW5jdGlvbiBPcihpLCB0LCBlID0gXCJ4XCIpIHtcbiAgY29uc3QgcyA9IE9uKGUpLCBuID0gaS5sZW5ndGg7XG4gIGxldCBvLCByLCBhLCBsID0gV3QoaSwgMCk7XG4gIGZvciAobGV0IGMgPSAwOyBjIDwgbjsgKytjKSB7XG4gICAgaWYgKHIgPSBhLCBhID0gbCwgbCA9IFd0KGksIGMgKyAxKSwgIWEpXG4gICAgICBjb250aW51ZTtcbiAgICBjb25zdCBoID0gYVtlXSwgZCA9IGFbc107XG4gICAgciAmJiAobyA9IChoIC0gcltlXSkgLyAzLCBhW2BjcDEke2V9YF0gPSBoIC0gbywgYVtgY3AxJHtzfWBdID0gZCAtIG8gKiB0W2NdKSwgbCAmJiAobyA9IChsW2VdIC0gaCkgLyAzLCBhW2BjcDIke2V9YF0gPSBoICsgbywgYVtgY3AyJHtzfWBdID0gZCArIG8gKiB0W2NdKTtcbiAgfVxufVxuZnVuY3Rpb24gQXIoaSwgdCA9IFwieFwiKSB7XG4gIGNvbnN0IGUgPSBPbih0KSwgcyA9IGkubGVuZ3RoLCBuID0gQXJyYXkocykuZmlsbCgwKSwgbyA9IEFycmF5KHMpO1xuICBsZXQgciwgYSwgbCwgYyA9IFd0KGksIDApO1xuICBmb3IgKHIgPSAwOyByIDwgczsgKytyKVxuICAgIGlmIChhID0gbCwgbCA9IGMsIGMgPSBXdChpLCByICsgMSksICEhbCkge1xuICAgICAgaWYgKGMpIHtcbiAgICAgICAgY29uc3QgaCA9IGNbdF0gLSBsW3RdO1xuICAgICAgICBuW3JdID0gaCAhPT0gMCA/IChjW2VdIC0gbFtlXSkgLyBoIDogMDtcbiAgICAgIH1cbiAgICAgIG9bcl0gPSBhID8gYyA/IGx0KG5bciAtIDFdKSAhPT0gbHQobltyXSkgPyAwIDogKG5bciAtIDFdICsgbltyXSkgLyAyIDogbltyIC0gMV0gOiBuW3JdO1xuICAgIH1cbiAgRHIoaSwgbiwgbyksIE9yKGksIG8sIHQpO1xufVxuZnVuY3Rpb24gRGUoaSwgdCwgZSkge1xuICByZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4oaSwgZSksIHQpO1xufVxuZnVuY3Rpb24gVHIoaSwgdCkge1xuICBsZXQgZSwgcywgbiwgbywgciwgYSA9IHJlKGlbMF0sIHQpO1xuICBmb3IgKGUgPSAwLCBzID0gaS5sZW5ndGg7IGUgPCBzOyArK2UpXG4gICAgciA9IG8sIG8gPSBhLCBhID0gZSA8IHMgLSAxICYmIHJlKGlbZSArIDFdLCB0KSwgbyAmJiAobiA9IGlbZV0sIHIgJiYgKG4uY3AxeCA9IERlKG4uY3AxeCwgdC5sZWZ0LCB0LnJpZ2h0KSwgbi5jcDF5ID0gRGUobi5jcDF5LCB0LnRvcCwgdC5ib3R0b20pKSwgYSAmJiAobi5jcDJ4ID0gRGUobi5jcDJ4LCB0LmxlZnQsIHQucmlnaHQpLCBuLmNwMnkgPSBEZShuLmNwMnksIHQudG9wLCB0LmJvdHRvbSkpKTtcbn1cbmZ1bmN0aW9uIExyKGksIHQsIGUsIHMsIG4pIHtcbiAgbGV0IG8sIHIsIGEsIGw7XG4gIGlmICh0LnNwYW5HYXBzICYmIChpID0gaS5maWx0ZXIoKGMpID0+ICFjLnNraXApKSwgdC5jdWJpY0ludGVycG9sYXRpb25Nb2RlID09PSBcIm1vbm90b25lXCIpXG4gICAgQXIoaSwgbik7XG4gIGVsc2Uge1xuICAgIGxldCBjID0gcyA/IGlbaS5sZW5ndGggLSAxXSA6IGlbMF07XG4gICAgZm9yIChvID0gMCwgciA9IGkubGVuZ3RoOyBvIDwgcjsgKytvKVxuICAgICAgYSA9IGlbb10sIGwgPSBDcihcbiAgICAgICAgYyxcbiAgICAgICAgYSxcbiAgICAgICAgaVtNYXRoLm1pbihvICsgMSwgciAtIChzID8gMCA6IDEpKSAlIHJdLFxuICAgICAgICB0LnRlbnNpb25cbiAgICAgICksIGEuY3AxeCA9IGwucHJldmlvdXMueCwgYS5jcDF5ID0gbC5wcmV2aW91cy55LCBhLmNwMnggPSBsLm5leHQueCwgYS5jcDJ5ID0gbC5uZXh0LnksIGMgPSBhO1xuICB9XG4gIHQuY2FwQmV6aWVyUG9pbnRzICYmIFRyKGksIGUpO1xufVxuZnVuY3Rpb24gQW4oKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93IDwgXCJ1XCIgJiYgdHlwZW9mIGRvY3VtZW50IDwgXCJ1XCI7XG59XG5mdW5jdGlvbiBXaShpKSB7XG4gIGxldCB0ID0gaS5wYXJlbnROb2RlO1xuICByZXR1cm4gdCAmJiB0LnRvU3RyaW5nKCkgPT09IFwiW29iamVjdCBTaGFkb3dSb290XVwiICYmICh0ID0gdC5ob3N0KSwgdDtcbn1cbmZ1bmN0aW9uIEhlKGksIHQsIGUpIHtcbiAgbGV0IHM7XG4gIHJldHVybiB0eXBlb2YgaSA9PSBcInN0cmluZ1wiID8gKHMgPSBwYXJzZUludChpLCAxMCksIGkuaW5kZXhPZihcIiVcIikgIT09IC0xICYmIChzID0gcyAvIDEwMCAqIHQucGFyZW50Tm9kZVtlXSkpIDogcyA9IGksIHM7XG59XG5jb25zdCBLZSA9IChpKSA9PiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShpLCBudWxsKTtcbmZ1bmN0aW9uIFJyKGksIHQpIHtcbiAgcmV0dXJuIEtlKGkpLmdldFByb3BlcnR5VmFsdWUodCk7XG59XG5jb25zdCBFciA9IFtcInRvcFwiLCBcInJpZ2h0XCIsIFwiYm90dG9tXCIsIFwibGVmdFwiXTtcbmZ1bmN0aW9uIE90KGksIHQsIGUpIHtcbiAgY29uc3QgcyA9IHt9O1xuICBlID0gZSA/IFwiLVwiICsgZSA6IFwiXCI7XG4gIGZvciAobGV0IG4gPSAwOyBuIDwgNDsgbisrKSB7XG4gICAgY29uc3QgbyA9IEVyW25dO1xuICAgIHNbb10gPSBwYXJzZUZsb2F0KGlbdCArIFwiLVwiICsgbyArIGVdKSB8fCAwO1xuICB9XG4gIHJldHVybiBzLndpZHRoID0gcy5sZWZ0ICsgcy5yaWdodCwgcy5oZWlnaHQgPSBzLnRvcCArIHMuYm90dG9tLCBzO1xufVxuY29uc3QgRnIgPSAoaSwgdCwgZSkgPT4gKGkgPiAwIHx8IHQgPiAwKSAmJiAoIWUgfHwgIWUuc2hhZG93Um9vdCk7XG5mdW5jdGlvbiBJcihpLCB0KSB7XG4gIGNvbnN0IGUgPSBpLnRvdWNoZXMsIHMgPSBlICYmIGUubGVuZ3RoID8gZVswXSA6IGksIHsgb2Zmc2V0WDogbiwgb2Zmc2V0WTogbyB9ID0gcztcbiAgbGV0IHIgPSAhMSwgYSwgbDtcbiAgaWYgKEZyKG4sIG8sIGkudGFyZ2V0KSlcbiAgICBhID0gbiwgbCA9IG87XG4gIGVsc2Uge1xuICAgIGNvbnN0IGMgPSB0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGEgPSBzLmNsaWVudFggLSBjLmxlZnQsIGwgPSBzLmNsaWVudFkgLSBjLnRvcCwgciA9ICEwO1xuICB9XG4gIHJldHVybiB7IHg6IGEsIHk6IGwsIGJveDogciB9O1xufVxuZnVuY3Rpb24gUHQoaSwgdCkge1xuICBpZiAoXCJuYXRpdmVcIiBpbiBpKVxuICAgIHJldHVybiBpO1xuICBjb25zdCB7IGNhbnZhczogZSwgY3VycmVudERldmljZVBpeGVsUmF0aW86IHMgfSA9IHQsIG4gPSBLZShlKSwgbyA9IG4uYm94U2l6aW5nID09PSBcImJvcmRlci1ib3hcIiwgciA9IE90KG4sIFwicGFkZGluZ1wiKSwgYSA9IE90KG4sIFwiYm9yZGVyXCIsIFwid2lkdGhcIiksIHsgeDogbCwgeTogYywgYm94OiBoIH0gPSBJcihpLCBlKSwgZCA9IHIubGVmdCArIChoICYmIGEubGVmdCksIHUgPSByLnRvcCArIChoICYmIGEudG9wKTtcbiAgbGV0IHsgd2lkdGg6IGYsIGhlaWdodDogZyB9ID0gdDtcbiAgcmV0dXJuIG8gJiYgKGYgLT0gci53aWR0aCArIGEud2lkdGgsIGcgLT0gci5oZWlnaHQgKyBhLmhlaWdodCksIHtcbiAgICB4OiBNYXRoLnJvdW5kKChsIC0gZCkgLyBmICogZS53aWR0aCAvIHMpLFxuICAgIHk6IE1hdGgucm91bmQoKGMgLSB1KSAvIGcgKiBlLmhlaWdodCAvIHMpXG4gIH07XG59XG5mdW5jdGlvbiB6cihpLCB0LCBlKSB7XG4gIGxldCBzLCBuO1xuICBpZiAodCA9PT0gdm9pZCAwIHx8IGUgPT09IHZvaWQgMCkge1xuICAgIGNvbnN0IG8gPSBXaShpKTtcbiAgICBpZiAoIW8pXG4gICAgICB0ID0gaS5jbGllbnRXaWR0aCwgZSA9IGkuY2xpZW50SGVpZ2h0O1xuICAgIGVsc2Uge1xuICAgICAgY29uc3QgciA9IG8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGEgPSBLZShvKSwgbCA9IE90KGEsIFwiYm9yZGVyXCIsIFwid2lkdGhcIiksIGMgPSBPdChhLCBcInBhZGRpbmdcIik7XG4gICAgICB0ID0gci53aWR0aCAtIGMud2lkdGggLSBsLndpZHRoLCBlID0gci5oZWlnaHQgLSBjLmhlaWdodCAtIGwuaGVpZ2h0LCBzID0gSGUoYS5tYXhXaWR0aCwgbywgXCJjbGllbnRXaWR0aFwiKSwgbiA9IEhlKGEubWF4SGVpZ2h0LCBvLCBcImNsaWVudEhlaWdodFwiKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogdCxcbiAgICBoZWlnaHQ6IGUsXG4gICAgbWF4V2lkdGg6IHMgfHwgVmUsXG4gICAgbWF4SGVpZ2h0OiBuIHx8IFZlXG4gIH07XG59XG5jb25zdCBhaSA9IChpKSA9PiBNYXRoLnJvdW5kKGkgKiAxMCkgLyAxMDtcbmZ1bmN0aW9uIEJyKGksIHQsIGUsIHMpIHtcbiAgY29uc3QgbiA9IEtlKGkpLCBvID0gT3QobiwgXCJtYXJnaW5cIiksIHIgPSBIZShuLm1heFdpZHRoLCBpLCBcImNsaWVudFdpZHRoXCIpIHx8IFZlLCBhID0gSGUobi5tYXhIZWlnaHQsIGksIFwiY2xpZW50SGVpZ2h0XCIpIHx8IFZlLCBsID0genIoaSwgdCwgZSk7XG4gIGxldCB7IHdpZHRoOiBjLCBoZWlnaHQ6IGggfSA9IGw7XG4gIGlmIChuLmJveFNpemluZyA9PT0gXCJjb250ZW50LWJveFwiKSB7XG4gICAgY29uc3QgZCA9IE90KG4sIFwiYm9yZGVyXCIsIFwid2lkdGhcIiksIHUgPSBPdChuLCBcInBhZGRpbmdcIik7XG4gICAgYyAtPSB1LndpZHRoICsgZC53aWR0aCwgaCAtPSB1LmhlaWdodCArIGQuaGVpZ2h0O1xuICB9XG4gIHJldHVybiBjID0gTWF0aC5tYXgoMCwgYyAtIG8ud2lkdGgpLCBoID0gTWF0aC5tYXgoMCwgcyA/IE1hdGguZmxvb3IoYyAvIHMpIDogaCAtIG8uaGVpZ2h0KSwgYyA9IGFpKE1hdGgubWluKGMsIHIsIGwubWF4V2lkdGgpKSwgaCA9IGFpKE1hdGgubWluKGgsIGEsIGwubWF4SGVpZ2h0KSksIGMgJiYgIWggJiYgKGggPSBhaShjIC8gMikpLCB7XG4gICAgd2lkdGg6IGMsXG4gICAgaGVpZ2h0OiBoXG4gIH07XG59XG5mdW5jdGlvbiBscyhpLCB0LCBlKSB7XG4gIGNvbnN0IHMgPSB0IHx8IDEsIG4gPSBNYXRoLmZsb29yKGkuaGVpZ2h0ICogcyksIG8gPSBNYXRoLmZsb29yKGkud2lkdGggKiBzKTtcbiAgaS5oZWlnaHQgPSBuIC8gcywgaS53aWR0aCA9IG8gLyBzO1xuICBjb25zdCByID0gaS5jYW52YXM7XG4gIHJldHVybiByLnN0eWxlICYmIChlIHx8ICFyLnN0eWxlLmhlaWdodCAmJiAhci5zdHlsZS53aWR0aCkgJiYgKHIuc3R5bGUuaGVpZ2h0ID0gYCR7aS5oZWlnaHR9cHhgLCByLnN0eWxlLndpZHRoID0gYCR7aS53aWR0aH1weGApLCBpLmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvICE9PSBzIHx8IHIuaGVpZ2h0ICE9PSBuIHx8IHIud2lkdGggIT09IG8gPyAoaS5jdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyA9IHMsIHIuaGVpZ2h0ID0gbiwgci53aWR0aCA9IG8sIGkuY3R4LnNldFRyYW5zZm9ybShzLCAwLCAwLCBzLCAwLCAwKSwgITApIDogITE7XG59XG5jb25zdCBWciA9IGZ1bmN0aW9uKCkge1xuICBsZXQgaSA9ICExO1xuICB0cnkge1xuICAgIGNvbnN0IHQgPSB7XG4gICAgICBnZXQgcGFzc2l2ZSgpIHtcbiAgICAgICAgcmV0dXJuIGkgPSAhMCwgITE7XG4gICAgICB9XG4gICAgfTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInRlc3RcIiwgbnVsbCwgdCksIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwidGVzdFwiLCBudWxsLCB0KTtcbiAgfSBjYXRjaCB7XG4gIH1cbiAgcmV0dXJuIGk7XG59KCk7XG5mdW5jdGlvbiBjcyhpLCB0KSB7XG4gIGNvbnN0IGUgPSBScihpLCB0KSwgcyA9IGUgJiYgZS5tYXRjaCgvXihcXGQrKShcXC5cXGQrKT9weCQvKTtcbiAgcmV0dXJuIHMgPyArc1sxXSA6IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIEN0KGksIHQsIGUsIHMpIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBpLnggKyBlICogKHQueCAtIGkueCksXG4gICAgeTogaS55ICsgZSAqICh0LnkgLSBpLnkpXG4gIH07XG59XG5mdW5jdGlvbiBXcihpLCB0LCBlLCBzKSB7XG4gIHJldHVybiB7XG4gICAgeDogaS54ICsgZSAqICh0LnggLSBpLngpLFxuICAgIHk6IHMgPT09IFwibWlkZGxlXCIgPyBlIDwgMC41ID8gaS55IDogdC55IDogcyA9PT0gXCJhZnRlclwiID8gZSA8IDEgPyBpLnkgOiB0LnkgOiBlID4gMCA/IHQueSA6IGkueVxuICB9O1xufVxuZnVuY3Rpb24gTnIoaSwgdCwgZSwgcykge1xuICBjb25zdCBuID0geyB4OiBpLmNwMngsIHk6IGkuY3AyeSB9LCBvID0geyB4OiB0LmNwMXgsIHk6IHQuY3AxeSB9LCByID0gQ3QoaSwgbiwgZSksIGEgPSBDdChuLCBvLCBlKSwgbCA9IEN0KG8sIHQsIGUpLCBjID0gQ3QociwgYSwgZSksIGggPSBDdChhLCBsLCBlKTtcbiAgcmV0dXJuIEN0KGMsIGgsIGUpO1xufVxuY29uc3QgaHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuZnVuY3Rpb24gSHIoaSwgdCkge1xuICB0ID0gdCB8fCB7fTtcbiAgY29uc3QgZSA9IGkgKyBKU09OLnN0cmluZ2lmeSh0KTtcbiAgbGV0IHMgPSBocy5nZXQoZSk7XG4gIHJldHVybiBzIHx8IChzID0gbmV3IEludGwuTnVtYmVyRm9ybWF0KGksIHQpLCBocy5zZXQoZSwgcykpLCBzO1xufVxuZnVuY3Rpb24gZGUoaSwgdCwgZSkge1xuICByZXR1cm4gSHIodCwgZSkuZm9ybWF0KGkpO1xufVxuY29uc3QganIgPSBmdW5jdGlvbihpLCB0KSB7XG4gIHJldHVybiB7XG4gICAgeChlKSB7XG4gICAgICByZXR1cm4gaSArIGkgKyB0IC0gZTtcbiAgICB9LFxuICAgIHNldFdpZHRoKGUpIHtcbiAgICAgIHQgPSBlO1xuICAgIH0sXG4gICAgdGV4dEFsaWduKGUpIHtcbiAgICAgIHJldHVybiBlID09PSBcImNlbnRlclwiID8gZSA6IGUgPT09IFwicmlnaHRcIiA/IFwibGVmdFwiIDogXCJyaWdodFwiO1xuICAgIH0sXG4gICAgeFBsdXMoZSwgcykge1xuICAgICAgcmV0dXJuIGUgLSBzO1xuICAgIH0sXG4gICAgbGVmdEZvckx0cihlLCBzKSB7XG4gICAgICByZXR1cm4gZSAtIHM7XG4gICAgfVxuICB9O1xufSwgJHIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICB4KGkpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH0sXG4gICAgc2V0V2lkdGgoaSkge1xuICAgIH0sXG4gICAgdGV4dEFsaWduKGkpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH0sXG4gICAgeFBsdXMoaSwgdCkge1xuICAgICAgcmV0dXJuIGkgKyB0O1xuICAgIH0sXG4gICAgbGVmdEZvckx0cihpLCB0KSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH07XG59O1xuZnVuY3Rpb24genQoaSwgdCwgZSkge1xuICByZXR1cm4gaSA/IGpyKHQsIGUpIDogJHIoKTtcbn1cbmZ1bmN0aW9uIFRuKGksIHQpIHtcbiAgbGV0IGUsIHM7XG4gICh0ID09PSBcImx0clwiIHx8IHQgPT09IFwicnRsXCIpICYmIChlID0gaS5jYW52YXMuc3R5bGUsIHMgPSBbXG4gICAgZS5nZXRQcm9wZXJ0eVZhbHVlKFwiZGlyZWN0aW9uXCIpLFxuICAgIGUuZ2V0UHJvcGVydHlQcmlvcml0eShcImRpcmVjdGlvblwiKVxuICBdLCBlLnNldFByb3BlcnR5KFwiZGlyZWN0aW9uXCIsIHQsIFwiaW1wb3J0YW50XCIpLCBpLnByZXZUZXh0RGlyZWN0aW9uID0gcyk7XG59XG5mdW5jdGlvbiBMbihpLCB0KSB7XG4gIHQgIT09IHZvaWQgMCAmJiAoZGVsZXRlIGkucHJldlRleHREaXJlY3Rpb24sIGkuY2FudmFzLnN0eWxlLnNldFByb3BlcnR5KFwiZGlyZWN0aW9uXCIsIHRbMF0sIHRbMV0pKTtcbn1cbmZ1bmN0aW9uIFJuKGkpIHtcbiAgcmV0dXJuIGkgPT09IFwiYW5nbGVcIiA/IHtcbiAgICBiZXR3ZWVuOiBvZSxcbiAgICBjb21wYXJlOiBBbyxcbiAgICBub3JtYWxpemU6IFpcbiAgfSA6IHtcbiAgICBiZXR3ZWVuOiB1dCxcbiAgICBjb21wYXJlOiAodCwgZSkgPT4gdCAtIGUsXG4gICAgbm9ybWFsaXplOiAodCkgPT4gdFxuICB9O1xufVxuZnVuY3Rpb24gZHMoeyBzdGFydDogaSwgZW5kOiB0LCBjb3VudDogZSwgbG9vcDogcywgc3R5bGU6IG4gfSkge1xuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBpICUgZSxcbiAgICBlbmQ6IHQgJSBlLFxuICAgIGxvb3A6IHMgJiYgKHQgLSBpICsgMSkgJSBlID09PSAwLFxuICAgIHN0eWxlOiBuXG4gIH07XG59XG5mdW5jdGlvbiBZcihpLCB0LCBlKSB7XG4gIGNvbnN0IHsgcHJvcGVydHk6IHMsIHN0YXJ0OiBuLCBlbmQ6IG8gfSA9IGUsIHsgYmV0d2Vlbjogciwgbm9ybWFsaXplOiBhIH0gPSBSbihzKSwgbCA9IHQubGVuZ3RoO1xuICBsZXQgeyBzdGFydDogYywgZW5kOiBoLCBsb29wOiBkIH0gPSBpLCB1LCBmO1xuICBpZiAoZCkge1xuICAgIGZvciAoYyArPSBsLCBoICs9IGwsIHUgPSAwLCBmID0gbDsgdSA8IGYgJiYgcihhKHRbYyAlIGxdW3NdKSwgbiwgbyk7ICsrdSlcbiAgICAgIGMtLSwgaC0tO1xuICAgIGMgJT0gbCwgaCAlPSBsO1xuICB9XG4gIHJldHVybiBoIDwgYyAmJiAoaCArPSBsKSwgeyBzdGFydDogYywgZW5kOiBoLCBsb29wOiBkLCBzdHlsZTogaS5zdHlsZSB9O1xufVxuZnVuY3Rpb24gRW4oaSwgdCwgZSkge1xuICBpZiAoIWUpXG4gICAgcmV0dXJuIFtpXTtcbiAgY29uc3QgeyBwcm9wZXJ0eTogcywgc3RhcnQ6IG4sIGVuZDogbyB9ID0gZSwgciA9IHQubGVuZ3RoLCB7IGNvbXBhcmU6IGEsIGJldHdlZW46IGwsIG5vcm1hbGl6ZTogYyB9ID0gUm4ocyksIHsgc3RhcnQ6IGgsIGVuZDogZCwgbG9vcDogdSwgc3R5bGU6IGYgfSA9IFlyKGksIHQsIGUpLCBnID0gW107XG4gIGxldCBwID0gITEsIG0gPSBudWxsLCBiLCB4LCB2O1xuICBjb25zdCB5ID0gKCkgPT4gbChuLCB2LCBiKSAmJiBhKG4sIHYpICE9PSAwLCBfID0gKCkgPT4gYShvLCBiKSA9PT0gMCB8fCBsKG8sIHYsIGIpLCBNID0gKCkgPT4gcCB8fCB5KCksIGsgPSAoKSA9PiAhcCB8fCBfKCk7XG4gIGZvciAobGV0IFMgPSBoLCB3ID0gaDsgUyA8PSBkOyArK1MpXG4gICAgeCA9IHRbUyAlIHJdLCAheC5za2lwICYmIChiID0gYyh4W3NdKSwgYiAhPT0gdiAmJiAocCA9IGwoYiwgbiwgbyksIG0gPT09IG51bGwgJiYgTSgpICYmIChtID0gYShiLCBuKSA9PT0gMCA/IFMgOiB3KSwgbSAhPT0gbnVsbCAmJiBrKCkgJiYgKGcucHVzaChkcyh7IHN0YXJ0OiBtLCBlbmQ6IFMsIGxvb3A6IHUsIGNvdW50OiByLCBzdHlsZTogZiB9KSksIG0gPSBudWxsKSwgdyA9IFMsIHYgPSBiKSk7XG4gIHJldHVybiBtICE9PSBudWxsICYmIGcucHVzaChkcyh7IHN0YXJ0OiBtLCBlbmQ6IGQsIGxvb3A6IHUsIGNvdW50OiByLCBzdHlsZTogZiB9KSksIGc7XG59XG5mdW5jdGlvbiBGbihpLCB0KSB7XG4gIGNvbnN0IGUgPSBbXSwgcyA9IGkuc2VnbWVudHM7XG4gIGZvciAobGV0IG4gPSAwOyBuIDwgcy5sZW5ndGg7IG4rKykge1xuICAgIGNvbnN0IG8gPSBFbihzW25dLCBpLnBvaW50cywgdCk7XG4gICAgby5sZW5ndGggJiYgZS5wdXNoKC4uLm8pO1xuICB9XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gWHIoaSwgdCwgZSwgcykge1xuICBsZXQgbiA9IDAsIG8gPSB0IC0gMTtcbiAgaWYgKGUgJiYgIXMpXG4gICAgZm9yICg7IG4gPCB0ICYmICFpW25dLnNraXA7IClcbiAgICAgIG4rKztcbiAgZm9yICg7IG4gPCB0ICYmIGlbbl0uc2tpcDsgKVxuICAgIG4rKztcbiAgZm9yIChuICU9IHQsIGUgJiYgKG8gKz0gbik7IG8gPiBuICYmIGlbbyAlIHRdLnNraXA7IClcbiAgICBvLS07XG4gIHJldHVybiBvICU9IHQsIHsgc3RhcnQ6IG4sIGVuZDogbyB9O1xufVxuZnVuY3Rpb24gVXIoaSwgdCwgZSwgcykge1xuICBjb25zdCBuID0gaS5sZW5ndGgsIG8gPSBbXTtcbiAgbGV0IHIgPSB0LCBhID0gaVt0XSwgbDtcbiAgZm9yIChsID0gdCArIDE7IGwgPD0gZTsgKytsKSB7XG4gICAgY29uc3QgYyA9IGlbbCAlIG5dO1xuICAgIGMuc2tpcCB8fCBjLnN0b3AgPyBhLnNraXAgfHwgKHMgPSAhMSwgby5wdXNoKHsgc3RhcnQ6IHQgJSBuLCBlbmQ6IChsIC0gMSkgJSBuLCBsb29wOiBzIH0pLCB0ID0gciA9IGMuc3RvcCA/IGwgOiBudWxsKSA6IChyID0gbCwgYS5za2lwICYmICh0ID0gbCkpLCBhID0gYztcbiAgfVxuICByZXR1cm4gciAhPT0gbnVsbCAmJiBvLnB1c2goeyBzdGFydDogdCAlIG4sIGVuZDogciAlIG4sIGxvb3A6IHMgfSksIG87XG59XG5mdW5jdGlvbiBLcihpLCB0KSB7XG4gIGNvbnN0IGUgPSBpLnBvaW50cywgcyA9IGkub3B0aW9ucy5zcGFuR2FwcywgbiA9IGUubGVuZ3RoO1xuICBpZiAoIW4pXG4gICAgcmV0dXJuIFtdO1xuICBjb25zdCBvID0gISFpLl9sb29wLCB7IHN0YXJ0OiByLCBlbmQ6IGEgfSA9IFhyKGUsIG4sIG8sIHMpO1xuICBpZiAocyA9PT0gITApXG4gICAgcmV0dXJuIHVzKGksIFt7IHN0YXJ0OiByLCBlbmQ6IGEsIGxvb3A6IG8gfV0sIGUsIHQpO1xuICBjb25zdCBsID0gYSA8IHIgPyBhICsgbiA6IGEsIGMgPSAhIWkuX2Z1bGxMb29wICYmIHIgPT09IDAgJiYgYSA9PT0gbiAtIDE7XG4gIHJldHVybiB1cyhpLCBVcihlLCByLCBsLCBjKSwgZSwgdCk7XG59XG5mdW5jdGlvbiB1cyhpLCB0LCBlLCBzKSB7XG4gIHJldHVybiAhcyB8fCAhcy5zZXRDb250ZXh0IHx8ICFlID8gdCA6IHFyKGksIHQsIGUsIHMpO1xufVxuZnVuY3Rpb24gcXIoaSwgdCwgZSwgcykge1xuICBjb25zdCBuID0gaS5fY2hhcnQuZ2V0Q29udGV4dCgpLCBvID0gZnMoaS5vcHRpb25zKSwgeyBfZGF0YXNldEluZGV4OiByLCBvcHRpb25zOiB7IHNwYW5HYXBzOiBhIH0gfSA9IGksIGwgPSBlLmxlbmd0aCwgYyA9IFtdO1xuICBsZXQgaCA9IG8sIGQgPSB0WzBdLnN0YXJ0LCB1ID0gZDtcbiAgZnVuY3Rpb24gZihnLCBwLCBtLCBiKSB7XG4gICAgY29uc3QgeCA9IGEgPyAtMSA6IDE7XG4gICAgaWYgKGcgIT09IHApIHtcbiAgICAgIGZvciAoZyArPSBsOyBlW2cgJSBsXS5za2lwOyApXG4gICAgICAgIGcgLT0geDtcbiAgICAgIGZvciAoOyBlW3AgJSBsXS5za2lwOyApXG4gICAgICAgIHAgKz0geDtcbiAgICAgIGcgJSBsICE9PSBwICUgbCAmJiAoYy5wdXNoKHsgc3RhcnQ6IGcgJSBsLCBlbmQ6IHAgJSBsLCBsb29wOiBtLCBzdHlsZTogYiB9KSwgaCA9IGIsIGQgPSBwICUgbCk7XG4gICAgfVxuICB9XG4gIGZvciAoY29uc3QgZyBvZiB0KSB7XG4gICAgZCA9IGEgPyBkIDogZy5zdGFydDtcbiAgICBsZXQgcCA9IGVbZCAlIGxdLCBtO1xuICAgIGZvciAodSA9IGQgKyAxOyB1IDw9IGcuZW5kOyB1KyspIHtcbiAgICAgIGNvbnN0IGIgPSBlW3UgJSBsXTtcbiAgICAgIG0gPSBmcyhzLnNldENvbnRleHQodnQobiwge1xuICAgICAgICB0eXBlOiBcInNlZ21lbnRcIixcbiAgICAgICAgcDA6IHAsXG4gICAgICAgIHAxOiBiLFxuICAgICAgICBwMERhdGFJbmRleDogKHUgLSAxKSAlIGwsXG4gICAgICAgIHAxRGF0YUluZGV4OiB1ICUgbCxcbiAgICAgICAgZGF0YXNldEluZGV4OiByXG4gICAgICB9KSkpLCBHcihtLCBoKSAmJiBmKGQsIHUgLSAxLCBnLmxvb3AsIGgpLCBwID0gYiwgaCA9IG07XG4gICAgfVxuICAgIGQgPCB1IC0gMSAmJiBmKGQsIHUgLSAxLCBnLmxvb3AsIGgpO1xuICB9XG4gIHJldHVybiBjO1xufVxuZnVuY3Rpb24gZnMoaSkge1xuICByZXR1cm4ge1xuICAgIGJhY2tncm91bmRDb2xvcjogaS5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgYm9yZGVyQ2FwU3R5bGU6IGkuYm9yZGVyQ2FwU3R5bGUsXG4gICAgYm9yZGVyRGFzaDogaS5ib3JkZXJEYXNoLFxuICAgIGJvcmRlckRhc2hPZmZzZXQ6IGkuYm9yZGVyRGFzaE9mZnNldCxcbiAgICBib3JkZXJKb2luU3R5bGU6IGkuYm9yZGVySm9pblN0eWxlLFxuICAgIGJvcmRlcldpZHRoOiBpLmJvcmRlcldpZHRoLFxuICAgIGJvcmRlckNvbG9yOiBpLmJvcmRlckNvbG9yXG4gIH07XG59XG5mdW5jdGlvbiBHcihpLCB0KSB7XG4gIHJldHVybiB0ICYmIEpTT04uc3RyaW5naWZ5KGkpICE9PSBKU09OLnN0cmluZ2lmeSh0KTtcbn1cbi8qIVxuICogQ2hhcnQuanMgdjMuOS4xXG4gKiBodHRwczovL3d3dy5jaGFydGpzLm9yZ1xuICogKGMpIDIwMjIgQ2hhcnQuanMgQ29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqL1xuY2xhc3MgWnIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9yZXF1ZXN0ID0gbnVsbCwgdGhpcy5fY2hhcnRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgdGhpcy5fcnVubmluZyA9ICExLCB0aGlzLl9sYXN0RGF0ZSA9IHZvaWQgMDtcbiAgfVxuICBfbm90aWZ5KHQsIGUsIHMsIG4pIHtcbiAgICBjb25zdCBvID0gZS5saXN0ZW5lcnNbbl0sIHIgPSBlLmR1cmF0aW9uO1xuICAgIG8uZm9yRWFjaCgoYSkgPT4gYSh7XG4gICAgICBjaGFydDogdCxcbiAgICAgIGluaXRpYWw6IGUuaW5pdGlhbCxcbiAgICAgIG51bVN0ZXBzOiByLFxuICAgICAgY3VycmVudFN0ZXA6IE1hdGgubWluKHMgLSBlLnN0YXJ0LCByKVxuICAgIH0pKTtcbiAgfVxuICBfcmVmcmVzaCgpIHtcbiAgICB0aGlzLl9yZXF1ZXN0IHx8ICh0aGlzLl9ydW5uaW5nID0gITAsIHRoaXMuX3JlcXVlc3QgPSBmbi5jYWxsKHdpbmRvdywgKCkgPT4ge1xuICAgICAgdGhpcy5fdXBkYXRlKCksIHRoaXMuX3JlcXVlc3QgPSBudWxsLCB0aGlzLl9ydW5uaW5nICYmIHRoaXMuX3JlZnJlc2goKTtcbiAgICB9KSk7XG4gIH1cbiAgX3VwZGF0ZSh0ID0gRGF0ZS5ub3coKSkge1xuICAgIGxldCBlID0gMDtcbiAgICB0aGlzLl9jaGFydHMuZm9yRWFjaCgocywgbikgPT4ge1xuICAgICAgaWYgKCFzLnJ1bm5pbmcgfHwgIXMuaXRlbXMubGVuZ3RoKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBvID0gcy5pdGVtcztcbiAgICAgIGxldCByID0gby5sZW5ndGggLSAxLCBhID0gITEsIGw7XG4gICAgICBmb3IgKDsgciA+PSAwOyAtLXIpXG4gICAgICAgIGwgPSBvW3JdLCBsLl9hY3RpdmUgPyAobC5fdG90YWwgPiBzLmR1cmF0aW9uICYmIChzLmR1cmF0aW9uID0gbC5fdG90YWwpLCBsLnRpY2sodCksIGEgPSAhMCkgOiAob1tyXSA9IG9bby5sZW5ndGggLSAxXSwgby5wb3AoKSk7XG4gICAgICBhICYmIChuLmRyYXcoKSwgdGhpcy5fbm90aWZ5KG4sIHMsIHQsIFwicHJvZ3Jlc3NcIikpLCBvLmxlbmd0aCB8fCAocy5ydW5uaW5nID0gITEsIHRoaXMuX25vdGlmeShuLCBzLCB0LCBcImNvbXBsZXRlXCIpLCBzLmluaXRpYWwgPSAhMSksIGUgKz0gby5sZW5ndGg7XG4gICAgfSksIHRoaXMuX2xhc3REYXRlID0gdCwgZSA9PT0gMCAmJiAodGhpcy5fcnVubmluZyA9ICExKTtcbiAgfVxuICBfZ2V0QW5pbXModCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLl9jaGFydHM7XG4gICAgbGV0IHMgPSBlLmdldCh0KTtcbiAgICByZXR1cm4gcyB8fCAocyA9IHtcbiAgICAgIHJ1bm5pbmc6ICExLFxuICAgICAgaW5pdGlhbDogITAsXG4gICAgICBpdGVtczogW10sXG4gICAgICBsaXN0ZW5lcnM6IHtcbiAgICAgICAgY29tcGxldGU6IFtdLFxuICAgICAgICBwcm9ncmVzczogW11cbiAgICAgIH1cbiAgICB9LCBlLnNldCh0LCBzKSksIHM7XG4gIH1cbiAgbGlzdGVuKHQsIGUsIHMpIHtcbiAgICB0aGlzLl9nZXRBbmltcyh0KS5saXN0ZW5lcnNbZV0ucHVzaChzKTtcbiAgfVxuICBhZGQodCwgZSkge1xuICAgICFlIHx8ICFlLmxlbmd0aCB8fCB0aGlzLl9nZXRBbmltcyh0KS5pdGVtcy5wdXNoKC4uLmUpO1xuICB9XG4gIGhhcyh0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldEFuaW1zKHQpLml0ZW1zLmxlbmd0aCA+IDA7XG4gIH1cbiAgc3RhcnQodCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLl9jaGFydHMuZ2V0KHQpO1xuICAgIGUgJiYgKGUucnVubmluZyA9ICEwLCBlLnN0YXJ0ID0gRGF0ZS5ub3coKSwgZS5kdXJhdGlvbiA9IGUuaXRlbXMucmVkdWNlKChzLCBuKSA9PiBNYXRoLm1heChzLCBuLl9kdXJhdGlvbiksIDApLCB0aGlzLl9yZWZyZXNoKCkpO1xuICB9XG4gIHJ1bm5pbmcodCkge1xuICAgIGlmICghdGhpcy5fcnVubmluZylcbiAgICAgIHJldHVybiAhMTtcbiAgICBjb25zdCBlID0gdGhpcy5fY2hhcnRzLmdldCh0KTtcbiAgICByZXR1cm4gISghZSB8fCAhZS5ydW5uaW5nIHx8ICFlLml0ZW1zLmxlbmd0aCk7XG4gIH1cbiAgc3RvcCh0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuX2NoYXJ0cy5nZXQodCk7XG4gICAgaWYgKCFlIHx8ICFlLml0ZW1zLmxlbmd0aClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBzID0gZS5pdGVtcztcbiAgICBsZXQgbiA9IHMubGVuZ3RoIC0gMTtcbiAgICBmb3IgKDsgbiA+PSAwOyAtLW4pXG4gICAgICBzW25dLmNhbmNlbCgpO1xuICAgIGUuaXRlbXMgPSBbXSwgdGhpcy5fbm90aWZ5KHQsIGUsIERhdGUubm93KCksIFwiY29tcGxldGVcIik7XG4gIH1cbiAgcmVtb3ZlKHQpIHtcbiAgICByZXR1cm4gdGhpcy5fY2hhcnRzLmRlbGV0ZSh0KTtcbiAgfVxufVxudmFyIGF0ID0gbmV3IFpyKCk7XG5jb25zdCBncyA9IFwidHJhbnNwYXJlbnRcIiwgSnIgPSB7XG4gIGJvb2xlYW4oaSwgdCwgZSkge1xuICAgIHJldHVybiBlID4gMC41ID8gdCA6IGk7XG4gIH0sXG4gIGNvbG9yKGksIHQsIGUpIHtcbiAgICBjb25zdCBzID0gbnMoaSB8fCBncyksIG4gPSBzLnZhbGlkICYmIG5zKHQgfHwgZ3MpO1xuICAgIHJldHVybiBuICYmIG4udmFsaWQgPyBuLm1peChzLCBlKS5oZXhTdHJpbmcoKSA6IHQ7XG4gIH0sXG4gIG51bWJlcihpLCB0LCBlKSB7XG4gICAgcmV0dXJuIGkgKyAodCAtIGkpICogZTtcbiAgfVxufTtcbmNsYXNzIEluIHtcbiAgY29uc3RydWN0b3IodCwgZSwgcywgbikge1xuICAgIGNvbnN0IG8gPSBlW3NdO1xuICAgIG4gPSBadChbdC50bywgbiwgbywgdC5mcm9tXSk7XG4gICAgY29uc3QgciA9IFp0KFt0LmZyb20sIG8sIG5dKTtcbiAgICB0aGlzLl9hY3RpdmUgPSAhMCwgdGhpcy5fZm4gPSB0LmZuIHx8IEpyW3QudHlwZSB8fCB0eXBlb2Ygcl0sIHRoaXMuX2Vhc2luZyA9IGVlW3QuZWFzaW5nXSB8fCBlZS5saW5lYXIsIHRoaXMuX3N0YXJ0ID0gTWF0aC5mbG9vcihEYXRlLm5vdygpICsgKHQuZGVsYXkgfHwgMCkpLCB0aGlzLl9kdXJhdGlvbiA9IHRoaXMuX3RvdGFsID0gTWF0aC5mbG9vcih0LmR1cmF0aW9uKSwgdGhpcy5fbG9vcCA9ICEhdC5sb29wLCB0aGlzLl90YXJnZXQgPSBlLCB0aGlzLl9wcm9wID0gcywgdGhpcy5fZnJvbSA9IHIsIHRoaXMuX3RvID0gbiwgdGhpcy5fcHJvbWlzZXMgPSB2b2lkIDA7XG4gIH1cbiAgYWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLl9hY3RpdmU7XG4gIH1cbiAgdXBkYXRlKHQsIGUsIHMpIHtcbiAgICBpZiAodGhpcy5fYWN0aXZlKSB7XG4gICAgICB0aGlzLl9ub3RpZnkoITEpO1xuICAgICAgY29uc3QgbiA9IHRoaXMuX3RhcmdldFt0aGlzLl9wcm9wXSwgbyA9IHMgLSB0aGlzLl9zdGFydCwgciA9IHRoaXMuX2R1cmF0aW9uIC0gbztcbiAgICAgIHRoaXMuX3N0YXJ0ID0gcywgdGhpcy5fZHVyYXRpb24gPSBNYXRoLmZsb29yKE1hdGgubWF4KHIsIHQuZHVyYXRpb24pKSwgdGhpcy5fdG90YWwgKz0gbywgdGhpcy5fbG9vcCA9ICEhdC5sb29wLCB0aGlzLl90byA9IFp0KFt0LnRvLCBlLCBuLCB0LmZyb21dKSwgdGhpcy5fZnJvbSA9IFp0KFt0LmZyb20sIG4sIGVdKTtcbiAgICB9XG4gIH1cbiAgY2FuY2VsKCkge1xuICAgIHRoaXMuX2FjdGl2ZSAmJiAodGhpcy50aWNrKERhdGUubm93KCkpLCB0aGlzLl9hY3RpdmUgPSAhMSwgdGhpcy5fbm90aWZ5KCExKSk7XG4gIH1cbiAgdGljayh0KSB7XG4gICAgY29uc3QgZSA9IHQgLSB0aGlzLl9zdGFydCwgcyA9IHRoaXMuX2R1cmF0aW9uLCBuID0gdGhpcy5fcHJvcCwgbyA9IHRoaXMuX2Zyb20sIHIgPSB0aGlzLl9sb29wLCBhID0gdGhpcy5fdG87XG4gICAgbGV0IGw7XG4gICAgaWYgKHRoaXMuX2FjdGl2ZSA9IG8gIT09IGEgJiYgKHIgfHwgZSA8IHMpLCAhdGhpcy5fYWN0aXZlKSB7XG4gICAgICB0aGlzLl90YXJnZXRbbl0gPSBhLCB0aGlzLl9ub3RpZnkoITApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZSA8IDApIHtcbiAgICAgIHRoaXMuX3RhcmdldFtuXSA9IG87XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGwgPSBlIC8gcyAlIDIsIGwgPSByICYmIGwgPiAxID8gMiAtIGwgOiBsLCBsID0gdGhpcy5fZWFzaW5nKE1hdGgubWluKDEsIE1hdGgubWF4KDAsIGwpKSksIHRoaXMuX3RhcmdldFtuXSA9IHRoaXMuX2ZuKG8sIGEsIGwpO1xuICB9XG4gIHdhaXQoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX3Byb21pc2VzIHx8ICh0aGlzLl9wcm9taXNlcyA9IFtdKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKGUsIHMpID0+IHtcbiAgICAgIHQucHVzaCh7IHJlczogZSwgcmVqOiBzIH0pO1xuICAgIH0pO1xuICB9XG4gIF9ub3RpZnkodCkge1xuICAgIGNvbnN0IGUgPSB0ID8gXCJyZXNcIiA6IFwicmVqXCIsIHMgPSB0aGlzLl9wcm9taXNlcyB8fCBbXTtcbiAgICBmb3IgKGxldCBuID0gMDsgbiA8IHMubGVuZ3RoOyBuKyspXG4gICAgICBzW25dW2VdKCk7XG4gIH1cbn1cbmNvbnN0IFFyID0gW1wieFwiLCBcInlcIiwgXCJib3JkZXJXaWR0aFwiLCBcInJhZGl1c1wiLCBcInRlbnNpb25cIl0sIHRhID0gW1wiY29sb3JcIiwgXCJib3JkZXJDb2xvclwiLCBcImJhY2tncm91bmRDb2xvclwiXTtcbk8uc2V0KFwiYW5pbWF0aW9uXCIsIHtcbiAgZGVsYXk6IHZvaWQgMCxcbiAgZHVyYXRpb246IDFlMyxcbiAgZWFzaW5nOiBcImVhc2VPdXRRdWFydFwiLFxuICBmbjogdm9pZCAwLFxuICBmcm9tOiB2b2lkIDAsXG4gIGxvb3A6IHZvaWQgMCxcbiAgdG86IHZvaWQgMCxcbiAgdHlwZTogdm9pZCAwXG59KTtcbmNvbnN0IGVhID0gT2JqZWN0LmtleXMoTy5hbmltYXRpb24pO1xuTy5kZXNjcmliZShcImFuaW1hdGlvblwiLCB7XG4gIF9mYWxsYmFjazogITEsXG4gIF9pbmRleGFibGU6ICExLFxuICBfc2NyaXB0YWJsZTogKGkpID0+IGkgIT09IFwib25Qcm9ncmVzc1wiICYmIGkgIT09IFwib25Db21wbGV0ZVwiICYmIGkgIT09IFwiZm5cIlxufSk7XG5PLnNldChcImFuaW1hdGlvbnNcIiwge1xuICBjb2xvcnM6IHtcbiAgICB0eXBlOiBcImNvbG9yXCIsXG4gICAgcHJvcGVydGllczogdGFcbiAgfSxcbiAgbnVtYmVyczoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgcHJvcGVydGllczogUXJcbiAgfVxufSk7XG5PLmRlc2NyaWJlKFwiYW5pbWF0aW9uc1wiLCB7XG4gIF9mYWxsYmFjazogXCJhbmltYXRpb25cIlxufSk7XG5PLnNldChcInRyYW5zaXRpb25zXCIsIHtcbiAgYWN0aXZlOiB7XG4gICAgYW5pbWF0aW9uOiB7XG4gICAgICBkdXJhdGlvbjogNDAwXG4gICAgfVxuICB9LFxuICByZXNpemU6IHtcbiAgICBhbmltYXRpb246IHtcbiAgICAgIGR1cmF0aW9uOiAwXG4gICAgfVxuICB9LFxuICBzaG93OiB7XG4gICAgYW5pbWF0aW9uczoge1xuICAgICAgY29sb3JzOiB7XG4gICAgICAgIGZyb206IFwidHJhbnNwYXJlbnRcIlxuICAgICAgfSxcbiAgICAgIHZpc2libGU6IHtcbiAgICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBoaWRlOiB7XG4gICAgYW5pbWF0aW9uczoge1xuICAgICAgY29sb3JzOiB7XG4gICAgICAgIHRvOiBcInRyYW5zcGFyZW50XCJcbiAgICAgIH0sXG4gICAgICB2aXNpYmxlOiB7XG4gICAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgICBlYXNpbmc6IFwibGluZWFyXCIsXG4gICAgICAgIGZuOiAoaSkgPT4gaSB8IDBcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pO1xuY2xhc3MgTmkge1xuICBjb25zdHJ1Y3Rvcih0LCBlKSB7XG4gICAgdGhpcy5fY2hhcnQgPSB0LCB0aGlzLl9wcm9wZXJ0aWVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgdGhpcy5jb25maWd1cmUoZSk7XG4gIH1cbiAgY29uZmlndXJlKHQpIHtcbiAgICBpZiAoIUQodCkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZSA9IHRoaXMuX3Byb3BlcnRpZXM7XG4gICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModCkuZm9yRWFjaCgocykgPT4ge1xuICAgICAgY29uc3QgbiA9IHRbc107XG4gICAgICBpZiAoIUQobikpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IG8gPSB7fTtcbiAgICAgIGZvciAoY29uc3QgciBvZiBlYSlcbiAgICAgICAgb1tyXSA9IG5bcl07XG4gICAgICAoeihuLnByb3BlcnRpZXMpICYmIG4ucHJvcGVydGllcyB8fCBbc10pLmZvckVhY2goKHIpID0+IHtcbiAgICAgICAgKHIgPT09IHMgfHwgIWUuaGFzKHIpKSAmJiBlLnNldChyLCBvKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIF9hbmltYXRlT3B0aW9ucyh0LCBlKSB7XG4gICAgY29uc3QgcyA9IGUub3B0aW9ucywgbiA9IHNhKHQsIHMpO1xuICAgIGlmICghbilcbiAgICAgIHJldHVybiBbXTtcbiAgICBjb25zdCBvID0gdGhpcy5fY3JlYXRlQW5pbWF0aW9ucyhuLCBzKTtcbiAgICByZXR1cm4gcy4kc2hhcmVkICYmIGlhKHQub3B0aW9ucy4kYW5pbWF0aW9ucywgcykudGhlbigoKSA9PiB7XG4gICAgICB0Lm9wdGlvbnMgPSBzO1xuICAgIH0sICgpID0+IHtcbiAgICB9KSwgbztcbiAgfVxuICBfY3JlYXRlQW5pbWF0aW9ucyh0LCBlKSB7XG4gICAgY29uc3QgcyA9IHRoaXMuX3Byb3BlcnRpZXMsIG4gPSBbXSwgbyA9IHQuJGFuaW1hdGlvbnMgfHwgKHQuJGFuaW1hdGlvbnMgPSB7fSksIHIgPSBPYmplY3Qua2V5cyhlKSwgYSA9IERhdGUubm93KCk7XG4gICAgbGV0IGw7XG4gICAgZm9yIChsID0gci5sZW5ndGggLSAxOyBsID49IDA7IC0tbCkge1xuICAgICAgY29uc3QgYyA9IHJbbF07XG4gICAgICBpZiAoYy5jaGFyQXQoMCkgPT09IFwiJFwiKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGlmIChjID09PSBcIm9wdGlvbnNcIikge1xuICAgICAgICBuLnB1c2goLi4udGhpcy5fYW5pbWF0ZU9wdGlvbnModCwgZSkpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGggPSBlW2NdO1xuICAgICAgbGV0IGQgPSBvW2NdO1xuICAgICAgY29uc3QgdSA9IHMuZ2V0KGMpO1xuICAgICAgaWYgKGQpXG4gICAgICAgIGlmICh1ICYmIGQuYWN0aXZlKCkpIHtcbiAgICAgICAgICBkLnVwZGF0ZSh1LCBoLCBhKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgZC5jYW5jZWwoKTtcbiAgICAgIGlmICghdSB8fCAhdS5kdXJhdGlvbikge1xuICAgICAgICB0W2NdID0gaDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBvW2NdID0gZCA9IG5ldyBJbih1LCB0LCBjLCBoKSwgbi5wdXNoKGQpO1xuICAgIH1cbiAgICByZXR1cm4gbjtcbiAgfVxuICB1cGRhdGUodCwgZSkge1xuICAgIGlmICh0aGlzLl9wcm9wZXJ0aWVzLnNpemUgPT09IDApIHtcbiAgICAgIE9iamVjdC5hc3NpZ24odCwgZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHMgPSB0aGlzLl9jcmVhdGVBbmltYXRpb25zKHQsIGUpO1xuICAgIGlmIChzLmxlbmd0aClcbiAgICAgIHJldHVybiBhdC5hZGQodGhpcy5fY2hhcnQsIHMpLCAhMDtcbiAgfVxufVxuZnVuY3Rpb24gaWEoaSwgdCkge1xuICBjb25zdCBlID0gW10sIHMgPSBPYmplY3Qua2V5cyh0KTtcbiAgZm9yIChsZXQgbiA9IDA7IG4gPCBzLmxlbmd0aDsgbisrKSB7XG4gICAgY29uc3QgbyA9IGlbc1tuXV07XG4gICAgbyAmJiBvLmFjdGl2ZSgpICYmIGUucHVzaChvLndhaXQoKSk7XG4gIH1cbiAgcmV0dXJuIFByb21pc2UuYWxsKGUpO1xufVxuZnVuY3Rpb24gc2EoaSwgdCkge1xuICBpZiAoIXQpXG4gICAgcmV0dXJuO1xuICBsZXQgZSA9IGkub3B0aW9ucztcbiAgaWYgKCFlKSB7XG4gICAgaS5vcHRpb25zID0gdDtcbiAgICByZXR1cm47XG4gIH1cbiAgcmV0dXJuIGUuJHNoYXJlZCAmJiAoaS5vcHRpb25zID0gZSA9IE9iamVjdC5hc3NpZ24oe30sIGUsIHsgJHNoYXJlZDogITEsICRhbmltYXRpb25zOiB7fSB9KSksIGU7XG59XG5mdW5jdGlvbiBwcyhpLCB0KSB7XG4gIGNvbnN0IGUgPSBpICYmIGkub3B0aW9ucyB8fCB7fSwgcyA9IGUucmV2ZXJzZSwgbiA9IGUubWluID09PSB2b2lkIDAgPyB0IDogMCwgbyA9IGUubWF4ID09PSB2b2lkIDAgPyB0IDogMDtcbiAgcmV0dXJuIHtcbiAgICBzdGFydDogcyA/IG8gOiBuLFxuICAgIGVuZDogcyA/IG4gOiBvXG4gIH07XG59XG5mdW5jdGlvbiBuYShpLCB0LCBlKSB7XG4gIGlmIChlID09PSAhMSlcbiAgICByZXR1cm4gITE7XG4gIGNvbnN0IHMgPSBwcyhpLCBlKSwgbiA9IHBzKHQsIGUpO1xuICByZXR1cm4ge1xuICAgIHRvcDogbi5lbmQsXG4gICAgcmlnaHQ6IHMuZW5kLFxuICAgIGJvdHRvbTogbi5zdGFydCxcbiAgICBsZWZ0OiBzLnN0YXJ0XG4gIH07XG59XG5mdW5jdGlvbiBvYShpKSB7XG4gIGxldCB0LCBlLCBzLCBuO1xuICByZXR1cm4gRChpKSA/ICh0ID0gaS50b3AsIGUgPSBpLnJpZ2h0LCBzID0gaS5ib3R0b20sIG4gPSBpLmxlZnQpIDogdCA9IGUgPSBzID0gbiA9IGksIHtcbiAgICB0b3A6IHQsXG4gICAgcmlnaHQ6IGUsXG4gICAgYm90dG9tOiBzLFxuICAgIGxlZnQ6IG4sXG4gICAgZGlzYWJsZWQ6IGkgPT09ICExXG4gIH07XG59XG5mdW5jdGlvbiB6bihpLCB0KSB7XG4gIGNvbnN0IGUgPSBbXSwgcyA9IGkuX2dldFNvcnRlZERhdGFzZXRNZXRhcyh0KTtcbiAgbGV0IG4sIG87XG4gIGZvciAobiA9IDAsIG8gPSBzLmxlbmd0aDsgbiA8IG87ICsrbilcbiAgICBlLnB1c2goc1tuXS5pbmRleCk7XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gbXMoaSwgdCwgZSwgcyA9IHt9KSB7XG4gIGNvbnN0IG4gPSBpLmtleXMsIG8gPSBzLm1vZGUgPT09IFwic2luZ2xlXCI7XG4gIGxldCByLCBhLCBsLCBjO1xuICBpZiAodCAhPT0gbnVsbCkge1xuICAgIGZvciAociA9IDAsIGEgPSBuLmxlbmd0aDsgciA8IGE7ICsrcikge1xuICAgICAgaWYgKGwgPSArbltyXSwgbCA9PT0gZSkge1xuICAgICAgICBpZiAocy5hbGwpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgYyA9IGkudmFsdWVzW2xdLCBOKGMpICYmIChvIHx8IHQgPT09IDAgfHwgbHQodCkgPT09IGx0KGMpKSAmJiAodCArPSBjKTtcbiAgICB9XG4gICAgcmV0dXJuIHQ7XG4gIH1cbn1cbmZ1bmN0aW9uIHJhKGkpIHtcbiAgY29uc3QgdCA9IE9iamVjdC5rZXlzKGkpLCBlID0gbmV3IEFycmF5KHQubGVuZ3RoKTtcbiAgbGV0IHMsIG4sIG87XG4gIGZvciAocyA9IDAsIG4gPSB0Lmxlbmd0aDsgcyA8IG47ICsrcylcbiAgICBvID0gdFtzXSwgZVtzXSA9IHtcbiAgICAgIHg6IG8sXG4gICAgICB5OiBpW29dXG4gICAgfTtcbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBicyhpLCB0KSB7XG4gIGNvbnN0IGUgPSBpICYmIGkub3B0aW9ucy5zdGFja2VkO1xuICByZXR1cm4gZSB8fCBlID09PSB2b2lkIDAgJiYgdC5zdGFjayAhPT0gdm9pZCAwO1xufVxuZnVuY3Rpb24gYWEoaSwgdCwgZSkge1xuICByZXR1cm4gYCR7aS5pZH0uJHt0LmlkfS4ke2Uuc3RhY2sgfHwgZS50eXBlfWA7XG59XG5mdW5jdGlvbiBsYShpKSB7XG4gIGNvbnN0IHsgbWluOiB0LCBtYXg6IGUsIG1pbkRlZmluZWQ6IHMsIG1heERlZmluZWQ6IG4gfSA9IGkuZ2V0VXNlckJvdW5kcygpO1xuICByZXR1cm4ge1xuICAgIG1pbjogcyA/IHQgOiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksXG4gICAgbWF4OiBuID8gZSA6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWVxuICB9O1xufVxuZnVuY3Rpb24gY2EoaSwgdCwgZSkge1xuICBjb25zdCBzID0gaVt0XSB8fCAoaVt0XSA9IHt9KTtcbiAgcmV0dXJuIHNbZV0gfHwgKHNbZV0gPSB7fSk7XG59XG5mdW5jdGlvbiB4cyhpLCB0LCBlLCBzKSB7XG4gIGZvciAoY29uc3QgbiBvZiB0LmdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKHMpLnJldmVyc2UoKSkge1xuICAgIGNvbnN0IG8gPSBpW24uaW5kZXhdO1xuICAgIGlmIChlICYmIG8gPiAwIHx8ICFlICYmIG8gPCAwKVxuICAgICAgcmV0dXJuIG4uaW5kZXg7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBfcyhpLCB0KSB7XG4gIGNvbnN0IHsgY2hhcnQ6IGUsIF9jYWNoZWRNZXRhOiBzIH0gPSBpLCBuID0gZS5fc3RhY2tzIHx8IChlLl9zdGFja3MgPSB7fSksIHsgaVNjYWxlOiBvLCB2U2NhbGU6IHIsIGluZGV4OiBhIH0gPSBzLCBsID0gby5heGlzLCBjID0gci5heGlzLCBoID0gYWEobywgciwgcyksIGQgPSB0Lmxlbmd0aDtcbiAgbGV0IHU7XG4gIGZvciAobGV0IGYgPSAwOyBmIDwgZDsgKytmKSB7XG4gICAgY29uc3QgZyA9IHRbZl0sIHsgW2xdOiBwLCBbY106IG0gfSA9IGcsIGIgPSBnLl9zdGFja3MgfHwgKGcuX3N0YWNrcyA9IHt9KTtcbiAgICB1ID0gYltjXSA9IGNhKG4sIGgsIHApLCB1W2FdID0gbSwgdS5fdG9wID0geHModSwgciwgITAsIHMudHlwZSksIHUuX2JvdHRvbSA9IHhzKHUsIHIsICExLCBzLnR5cGUpO1xuICB9XG59XG5mdW5jdGlvbiBsaShpLCB0KSB7XG4gIGNvbnN0IGUgPSBpLnNjYWxlcztcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGUpLmZpbHRlcigocykgPT4gZVtzXS5heGlzID09PSB0KS5zaGlmdCgpO1xufVxuZnVuY3Rpb24gaGEoaSwgdCkge1xuICByZXR1cm4gdnQoXG4gICAgaSxcbiAgICB7XG4gICAgICBhY3RpdmU6ICExLFxuICAgICAgZGF0YXNldDogdm9pZCAwLFxuICAgICAgZGF0YXNldEluZGV4OiB0LFxuICAgICAgaW5kZXg6IHQsXG4gICAgICBtb2RlOiBcImRlZmF1bHRcIixcbiAgICAgIHR5cGU6IFwiZGF0YXNldFwiXG4gICAgfVxuICApO1xufVxuZnVuY3Rpb24gZGEoaSwgdCwgZSkge1xuICByZXR1cm4gdnQoaSwge1xuICAgIGFjdGl2ZTogITEsXG4gICAgZGF0YUluZGV4OiB0LFxuICAgIHBhcnNlZDogdm9pZCAwLFxuICAgIHJhdzogdm9pZCAwLFxuICAgIGVsZW1lbnQ6IGUsXG4gICAgaW5kZXg6IHQsXG4gICAgbW9kZTogXCJkZWZhdWx0XCIsXG4gICAgdHlwZTogXCJkYXRhXCJcbiAgfSk7XG59XG5mdW5jdGlvbiBZdChpLCB0KSB7XG4gIGNvbnN0IGUgPSBpLmNvbnRyb2xsZXIuaW5kZXgsIHMgPSBpLnZTY2FsZSAmJiBpLnZTY2FsZS5heGlzO1xuICBpZiAocykge1xuICAgIHQgPSB0IHx8IGkuX3BhcnNlZDtcbiAgICBmb3IgKGNvbnN0IG4gb2YgdCkge1xuICAgICAgY29uc3QgbyA9IG4uX3N0YWNrcztcbiAgICAgIGlmICghbyB8fCBvW3NdID09PSB2b2lkIDAgfHwgb1tzXVtlXSA9PT0gdm9pZCAwKVxuICAgICAgICByZXR1cm47XG4gICAgICBkZWxldGUgb1tzXVtlXTtcbiAgICB9XG4gIH1cbn1cbmNvbnN0IGNpID0gKGkpID0+IGkgPT09IFwicmVzZXRcIiB8fCBpID09PSBcIm5vbmVcIiwgeXMgPSAoaSwgdCkgPT4gdCA/IGkgOiBPYmplY3QuYXNzaWduKHt9LCBpKSwgdWEgPSAoaSwgdCwgZSkgPT4gaSAmJiAhdC5oaWRkZW4gJiYgdC5fc3RhY2tlZCAmJiB7IGtleXM6IHpuKGUsICEwKSwgdmFsdWVzOiBudWxsIH07XG5jbGFzcyBpdCB7XG4gIGNvbnN0cnVjdG9yKHQsIGUpIHtcbiAgICB0aGlzLmNoYXJ0ID0gdCwgdGhpcy5fY3R4ID0gdC5jdHgsIHRoaXMuaW5kZXggPSBlLCB0aGlzLl9jYWNoZWREYXRhT3B0cyA9IHt9LCB0aGlzLl9jYWNoZWRNZXRhID0gdGhpcy5nZXRNZXRhKCksIHRoaXMuX3R5cGUgPSB0aGlzLl9jYWNoZWRNZXRhLnR5cGUsIHRoaXMub3B0aW9ucyA9IHZvaWQgMCwgdGhpcy5fcGFyc2luZyA9ICExLCB0aGlzLl9kYXRhID0gdm9pZCAwLCB0aGlzLl9vYmplY3REYXRhID0gdm9pZCAwLCB0aGlzLl9zaGFyZWRPcHRpb25zID0gdm9pZCAwLCB0aGlzLl9kcmF3U3RhcnQgPSB2b2lkIDAsIHRoaXMuX2RyYXdDb3VudCA9IHZvaWQgMCwgdGhpcy5lbmFibGVPcHRpb25TaGFyaW5nID0gITEsIHRoaXMuc3VwcG9ydHNEZWNpbWF0aW9uID0gITEsIHRoaXMuJGNvbnRleHQgPSB2b2lkIDAsIHRoaXMuX3N5bmNMaXN0ID0gW10sIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICB9XG4gIGluaXRpYWxpemUoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgdGhpcy5jb25maWd1cmUoKSwgdGhpcy5saW5rU2NhbGVzKCksIHQuX3N0YWNrZWQgPSBicyh0LnZTY2FsZSwgdCksIHRoaXMuYWRkRWxlbWVudHMoKTtcbiAgfVxuICB1cGRhdGVJbmRleCh0KSB7XG4gICAgdGhpcy5pbmRleCAhPT0gdCAmJiBZdCh0aGlzLl9jYWNoZWRNZXRhKSwgdGhpcy5pbmRleCA9IHQ7XG4gIH1cbiAgbGlua1NjYWxlcygpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5jaGFydCwgZSA9IHRoaXMuX2NhY2hlZE1ldGEsIHMgPSB0aGlzLmdldERhdGFzZXQoKSwgbiA9IChkLCB1LCBmLCBnKSA9PiBkID09PSBcInhcIiA/IHUgOiBkID09PSBcInJcIiA/IGcgOiBmLCBvID0gZS54QXhpc0lEID0gQyhzLnhBeGlzSUQsIGxpKHQsIFwieFwiKSksIHIgPSBlLnlBeGlzSUQgPSBDKHMueUF4aXNJRCwgbGkodCwgXCJ5XCIpKSwgYSA9IGUuckF4aXNJRCA9IEMocy5yQXhpc0lELCBsaSh0LCBcInJcIikpLCBsID0gZS5pbmRleEF4aXMsIGMgPSBlLmlBeGlzSUQgPSBuKGwsIG8sIHIsIGEpLCBoID0gZS52QXhpc0lEID0gbihsLCByLCBvLCBhKTtcbiAgICBlLnhTY2FsZSA9IHRoaXMuZ2V0U2NhbGVGb3JJZChvKSwgZS55U2NhbGUgPSB0aGlzLmdldFNjYWxlRm9ySWQociksIGUuclNjYWxlID0gdGhpcy5nZXRTY2FsZUZvcklkKGEpLCBlLmlTY2FsZSA9IHRoaXMuZ2V0U2NhbGVGb3JJZChjKSwgZS52U2NhbGUgPSB0aGlzLmdldFNjYWxlRm9ySWQoaCk7XG4gIH1cbiAgZ2V0RGF0YXNldCgpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzW3RoaXMuaW5kZXhdO1xuICB9XG4gIGdldE1ldGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhcnQuZ2V0RGF0YXNldE1ldGEodGhpcy5pbmRleCk7XG4gIH1cbiAgZ2V0U2NhbGVGb3JJZCh0KSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhcnQuc2NhbGVzW3RdO1xuICB9XG4gIF9nZXRPdGhlclNjYWxlKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICByZXR1cm4gdCA9PT0gZS5pU2NhbGUgPyBlLnZTY2FsZSA6IGUuaVNjYWxlO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHRoaXMuX3VwZGF0ZShcInJlc2V0XCIpO1xuICB9XG4gIF9kZXN0cm95KCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIHRoaXMuX2RhdGEgJiYgWmkodGhpcy5fZGF0YSwgdGhpcyksIHQuX3N0YWNrZWQgJiYgWXQodCk7XG4gIH1cbiAgX2RhdGFDaGVjaygpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5nZXREYXRhc2V0KCksIGUgPSB0LmRhdGEgfHwgKHQuZGF0YSA9IFtdKSwgcyA9IHRoaXMuX2RhdGE7XG4gICAgaWYgKEQoZSkpXG4gICAgICB0aGlzLl9kYXRhID0gcmEoZSk7XG4gICAgZWxzZSBpZiAocyAhPT0gZSkge1xuICAgICAgaWYgKHMpIHtcbiAgICAgICAgWmkocywgdGhpcyk7XG4gICAgICAgIGNvbnN0IG4gPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgICAgICBZdChuKSwgbi5fcGFyc2VkID0gW107XG4gICAgICB9XG4gICAgICBlICYmIE9iamVjdC5pc0V4dGVuc2libGUoZSkgJiYgRW8oZSwgdGhpcyksIHRoaXMuX3N5bmNMaXN0ID0gW10sIHRoaXMuX2RhdGEgPSBlO1xuICAgIH1cbiAgfVxuICBhZGRFbGVtZW50cygpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICB0aGlzLl9kYXRhQ2hlY2soKSwgdGhpcy5kYXRhc2V0RWxlbWVudFR5cGUgJiYgKHQuZGF0YXNldCA9IG5ldyB0aGlzLmRhdGFzZXRFbGVtZW50VHlwZSgpKTtcbiAgfVxuICBidWlsZE9yVXBkYXRlRWxlbWVudHModCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLl9jYWNoZWRNZXRhLCBzID0gdGhpcy5nZXREYXRhc2V0KCk7XG4gICAgbGV0IG4gPSAhMTtcbiAgICB0aGlzLl9kYXRhQ2hlY2soKTtcbiAgICBjb25zdCBvID0gZS5fc3RhY2tlZDtcbiAgICBlLl9zdGFja2VkID0gYnMoZS52U2NhbGUsIGUpLCBlLnN0YWNrICE9PSBzLnN0YWNrICYmIChuID0gITAsIFl0KGUpLCBlLnN0YWNrID0gcy5zdGFjayksIHRoaXMuX3Jlc3luY0VsZW1lbnRzKHQpLCAobiB8fCBvICE9PSBlLl9zdGFja2VkKSAmJiBfcyh0aGlzLCBlLl9wYXJzZWQpO1xuICB9XG4gIGNvbmZpZ3VyZSgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5jaGFydC5jb25maWcsIGUgPSB0LmRhdGFzZXRTY29wZUtleXModGhpcy5fdHlwZSksIHMgPSB0LmdldE9wdGlvblNjb3Blcyh0aGlzLmdldERhdGFzZXQoKSwgZSwgITApO1xuICAgIHRoaXMub3B0aW9ucyA9IHQuY3JlYXRlUmVzb2x2ZXIocywgdGhpcy5nZXRDb250ZXh0KCkpLCB0aGlzLl9wYXJzaW5nID0gdGhpcy5vcHRpb25zLnBhcnNpbmcsIHRoaXMuX2NhY2hlZERhdGFPcHRzID0ge307XG4gIH1cbiAgcGFyc2UodCwgZSkge1xuICAgIGNvbnN0IHsgX2NhY2hlZE1ldGE6IHMsIF9kYXRhOiBuIH0gPSB0aGlzLCB7IGlTY2FsZTogbywgX3N0YWNrZWQ6IHIgfSA9IHMsIGEgPSBvLmF4aXM7XG4gICAgbGV0IGwgPSB0ID09PSAwICYmIGUgPT09IG4ubGVuZ3RoID8gITAgOiBzLl9zb3J0ZWQsIGMgPSB0ID4gMCAmJiBzLl9wYXJzZWRbdCAtIDFdLCBoLCBkLCB1O1xuICAgIGlmICh0aGlzLl9wYXJzaW5nID09PSAhMSlcbiAgICAgIHMuX3BhcnNlZCA9IG4sIHMuX3NvcnRlZCA9ICEwLCB1ID0gbjtcbiAgICBlbHNlIHtcbiAgICAgIHooblt0XSkgPyB1ID0gdGhpcy5wYXJzZUFycmF5RGF0YShzLCBuLCB0LCBlKSA6IEQoblt0XSkgPyB1ID0gdGhpcy5wYXJzZU9iamVjdERhdGEocywgbiwgdCwgZSkgOiB1ID0gdGhpcy5wYXJzZVByaW1pdGl2ZURhdGEocywgbiwgdCwgZSk7XG4gICAgICBjb25zdCBmID0gKCkgPT4gZFthXSA9PT0gbnVsbCB8fCBjICYmIGRbYV0gPCBjW2FdO1xuICAgICAgZm9yIChoID0gMDsgaCA8IGU7ICsraClcbiAgICAgICAgcy5fcGFyc2VkW2ggKyB0XSA9IGQgPSB1W2hdLCBsICYmIChmKCkgJiYgKGwgPSAhMSksIGMgPSBkKTtcbiAgICAgIHMuX3NvcnRlZCA9IGw7XG4gICAgfVxuICAgIHIgJiYgX3ModGhpcywgdSk7XG4gIH1cbiAgcGFyc2VQcmltaXRpdmVEYXRhKHQsIGUsIHMsIG4pIHtcbiAgICBjb25zdCB7IGlTY2FsZTogbywgdlNjYWxlOiByIH0gPSB0LCBhID0gby5heGlzLCBsID0gci5heGlzLCBjID0gby5nZXRMYWJlbHMoKSwgaCA9IG8gPT09IHIsIGQgPSBuZXcgQXJyYXkobik7XG4gICAgbGV0IHUsIGYsIGc7XG4gICAgZm9yICh1ID0gMCwgZiA9IG47IHUgPCBmOyArK3UpXG4gICAgICBnID0gdSArIHMsIGRbdV0gPSB7XG4gICAgICAgIFthXTogaCB8fCBvLnBhcnNlKGNbZ10sIGcpLFxuICAgICAgICBbbF06IHIucGFyc2UoZVtnXSwgZylcbiAgICAgIH07XG4gICAgcmV0dXJuIGQ7XG4gIH1cbiAgcGFyc2VBcnJheURhdGEodCwgZSwgcywgbikge1xuICAgIGNvbnN0IHsgeFNjYWxlOiBvLCB5U2NhbGU6IHIgfSA9IHQsIGEgPSBuZXcgQXJyYXkobik7XG4gICAgbGV0IGwsIGMsIGgsIGQ7XG4gICAgZm9yIChsID0gMCwgYyA9IG47IGwgPCBjOyArK2wpXG4gICAgICBoID0gbCArIHMsIGQgPSBlW2hdLCBhW2xdID0ge1xuICAgICAgICB4OiBvLnBhcnNlKGRbMF0sIGgpLFxuICAgICAgICB5OiByLnBhcnNlKGRbMV0sIGgpXG4gICAgICB9O1xuICAgIHJldHVybiBhO1xuICB9XG4gIHBhcnNlT2JqZWN0RGF0YSh0LCBlLCBzLCBuKSB7XG4gICAgY29uc3QgeyB4U2NhbGU6IG8sIHlTY2FsZTogciB9ID0gdCwgeyB4QXhpc0tleTogYSA9IFwieFwiLCB5QXhpc0tleTogbCA9IFwieVwiIH0gPSB0aGlzLl9wYXJzaW5nLCBjID0gbmV3IEFycmF5KG4pO1xuICAgIGxldCBoLCBkLCB1LCBmO1xuICAgIGZvciAoaCA9IDAsIGQgPSBuOyBoIDwgZDsgKytoKVxuICAgICAgdSA9IGggKyBzLCBmID0gZVt1XSwgY1toXSA9IHtcbiAgICAgICAgeDogby5wYXJzZShfdChmLCBhKSwgdSksXG4gICAgICAgIHk6IHIucGFyc2UoX3QoZiwgbCksIHUpXG4gICAgICB9O1xuICAgIHJldHVybiBjO1xuICB9XG4gIGdldFBhcnNlZCh0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZE1ldGEuX3BhcnNlZFt0XTtcbiAgfVxuICBnZXREYXRhRWxlbWVudCh0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZE1ldGEuZGF0YVt0XTtcbiAgfVxuICBhcHBseVN0YWNrKHQsIGUsIHMpIHtcbiAgICBjb25zdCBuID0gdGhpcy5jaGFydCwgbyA9IHRoaXMuX2NhY2hlZE1ldGEsIHIgPSBlW3QuYXhpc10sIGEgPSB7XG4gICAgICBrZXlzOiB6bihuLCAhMCksXG4gICAgICB2YWx1ZXM6IGUuX3N0YWNrc1t0LmF4aXNdXG4gICAgfTtcbiAgICByZXR1cm4gbXMoYSwgciwgby5pbmRleCwgeyBtb2RlOiBzIH0pO1xuICB9XG4gIHVwZGF0ZVJhbmdlRnJvbVBhcnNlZCh0LCBlLCBzLCBuKSB7XG4gICAgY29uc3QgbyA9IHNbZS5heGlzXTtcbiAgICBsZXQgciA9IG8gPT09IG51bGwgPyBOYU4gOiBvO1xuICAgIGNvbnN0IGEgPSBuICYmIHMuX3N0YWNrc1tlLmF4aXNdO1xuICAgIG4gJiYgYSAmJiAobi52YWx1ZXMgPSBhLCByID0gbXMobiwgbywgdGhpcy5fY2FjaGVkTWV0YS5pbmRleCkpLCB0Lm1pbiA9IE1hdGgubWluKHQubWluLCByKSwgdC5tYXggPSBNYXRoLm1heCh0Lm1heCwgcik7XG4gIH1cbiAgZ2V0TWluTWF4KHQsIGUpIHtcbiAgICBjb25zdCBzID0gdGhpcy5fY2FjaGVkTWV0YSwgbiA9IHMuX3BhcnNlZCwgbyA9IHMuX3NvcnRlZCAmJiB0ID09PSBzLmlTY2FsZSwgciA9IG4ubGVuZ3RoLCBhID0gdGhpcy5fZ2V0T3RoZXJTY2FsZSh0KSwgbCA9IHVhKGUsIHMsIHRoaXMuY2hhcnQpLCBjID0geyBtaW46IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgbWF4OiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkgfSwgeyBtaW46IGgsIG1heDogZCB9ID0gbGEoYSk7XG4gICAgbGV0IHUsIGY7XG4gICAgZnVuY3Rpb24gZygpIHtcbiAgICAgIGYgPSBuW3VdO1xuICAgICAgY29uc3QgcCA9IGZbYS5heGlzXTtcbiAgICAgIHJldHVybiAhTihmW3QuYXhpc10pIHx8IGggPiBwIHx8IGQgPCBwO1xuICAgIH1cbiAgICBmb3IgKHUgPSAwOyB1IDwgciAmJiAhKCFnKCkgJiYgKHRoaXMudXBkYXRlUmFuZ2VGcm9tUGFyc2VkKGMsIHQsIGYsIGwpLCBvKSk7ICsrdSlcbiAgICAgIDtcbiAgICBpZiAobykge1xuICAgICAgZm9yICh1ID0gciAtIDE7IHUgPj0gMDsgLS11KVxuICAgICAgICBpZiAoIWcoKSkge1xuICAgICAgICAgIHRoaXMudXBkYXRlUmFuZ2VGcm9tUGFyc2VkKGMsIHQsIGYsIGwpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjO1xuICB9XG4gIGdldEFsbFBhcnNlZFZhbHVlcyh0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuX2NhY2hlZE1ldGEuX3BhcnNlZCwgcyA9IFtdO1xuICAgIGxldCBuLCBvLCByO1xuICAgIGZvciAobiA9IDAsIG8gPSBlLmxlbmd0aDsgbiA8IG87ICsrbilcbiAgICAgIHIgPSBlW25dW3QuYXhpc10sIE4ocikgJiYgcy5wdXNoKHIpO1xuICAgIHJldHVybiBzO1xuICB9XG4gIGdldE1heE92ZXJmbG93KCkge1xuICAgIHJldHVybiAhMTtcbiAgfVxuICBnZXRMYWJlbEFuZFZhbHVlKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5fY2FjaGVkTWV0YSwgcyA9IGUuaVNjYWxlLCBuID0gZS52U2NhbGUsIG8gPSB0aGlzLmdldFBhcnNlZCh0KTtcbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWw6IHMgPyBcIlwiICsgcy5nZXRMYWJlbEZvclZhbHVlKG9bcy5heGlzXSkgOiBcIlwiLFxuICAgICAgdmFsdWU6IG4gPyBcIlwiICsgbi5nZXRMYWJlbEZvclZhbHVlKG9bbi5heGlzXSkgOiBcIlwiXG4gICAgfTtcbiAgfVxuICBfdXBkYXRlKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICB0aGlzLnVwZGF0ZSh0IHx8IFwiZGVmYXVsdFwiKSwgZS5fY2xpcCA9IG9hKEModGhpcy5vcHRpb25zLmNsaXAsIG5hKGUueFNjYWxlLCBlLnlTY2FsZSwgdGhpcy5nZXRNYXhPdmVyZmxvdygpKSkpO1xuICB9XG4gIHVwZGF0ZSh0KSB7XG4gIH1cbiAgZHJhdygpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fY3R4LCBlID0gdGhpcy5jaGFydCwgcyA9IHRoaXMuX2NhY2hlZE1ldGEsIG4gPSBzLmRhdGEgfHwgW10sIG8gPSBlLmNoYXJ0QXJlYSwgciA9IFtdLCBhID0gdGhpcy5fZHJhd1N0YXJ0IHx8IDAsIGwgPSB0aGlzLl9kcmF3Q291bnQgfHwgbi5sZW5ndGggLSBhLCBjID0gdGhpcy5vcHRpb25zLmRyYXdBY3RpdmVFbGVtZW50c09uVG9wO1xuICAgIGxldCBoO1xuICAgIGZvciAocy5kYXRhc2V0ICYmIHMuZGF0YXNldC5kcmF3KHQsIG8sIGEsIGwpLCBoID0gYTsgaCA8IGEgKyBsOyArK2gpIHtcbiAgICAgIGNvbnN0IGQgPSBuW2hdO1xuICAgICAgZC5oaWRkZW4gfHwgKGQuYWN0aXZlICYmIGMgPyByLnB1c2goZCkgOiBkLmRyYXcodCwgbykpO1xuICAgIH1cbiAgICBmb3IgKGggPSAwOyBoIDwgci5sZW5ndGg7ICsraClcbiAgICAgIHJbaF0uZHJhdyh0LCBvKTtcbiAgfVxuICBnZXRTdHlsZSh0LCBlKSB7XG4gICAgY29uc3QgcyA9IGUgPyBcImFjdGl2ZVwiIDogXCJkZWZhdWx0XCI7XG4gICAgcmV0dXJuIHQgPT09IHZvaWQgMCAmJiB0aGlzLl9jYWNoZWRNZXRhLmRhdGFzZXQgPyB0aGlzLnJlc29sdmVEYXRhc2V0RWxlbWVudE9wdGlvbnMocykgOiB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnModCB8fCAwLCBzKTtcbiAgfVxuICBnZXRDb250ZXh0KHQsIGUsIHMpIHtcbiAgICBjb25zdCBuID0gdGhpcy5nZXREYXRhc2V0KCk7XG4gICAgbGV0IG87XG4gICAgaWYgKHQgPj0gMCAmJiB0IDwgdGhpcy5fY2FjaGVkTWV0YS5kYXRhLmxlbmd0aCkge1xuICAgICAgY29uc3QgciA9IHRoaXMuX2NhY2hlZE1ldGEuZGF0YVt0XTtcbiAgICAgIG8gPSByLiRjb250ZXh0IHx8IChyLiRjb250ZXh0ID0gZGEodGhpcy5nZXRDb250ZXh0KCksIHQsIHIpKSwgby5wYXJzZWQgPSB0aGlzLmdldFBhcnNlZCh0KSwgby5yYXcgPSBuLmRhdGFbdF0sIG8uaW5kZXggPSBvLmRhdGFJbmRleCA9IHQ7XG4gICAgfSBlbHNlXG4gICAgICBvID0gdGhpcy4kY29udGV4dCB8fCAodGhpcy4kY29udGV4dCA9IGhhKHRoaXMuY2hhcnQuZ2V0Q29udGV4dCgpLCB0aGlzLmluZGV4KSksIG8uZGF0YXNldCA9IG4sIG8uaW5kZXggPSBvLmRhdGFzZXRJbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgcmV0dXJuIG8uYWN0aXZlID0gISFlLCBvLm1vZGUgPSBzLCBvO1xuICB9XG4gIHJlc29sdmVEYXRhc2V0RWxlbWVudE9wdGlvbnModCkge1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlRWxlbWVudE9wdGlvbnModGhpcy5kYXRhc2V0RWxlbWVudFR5cGUuaWQsIHQpO1xuICB9XG4gIHJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnModCwgZSkge1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlRWxlbWVudE9wdGlvbnModGhpcy5kYXRhRWxlbWVudFR5cGUuaWQsIGUsIHQpO1xuICB9XG4gIF9yZXNvbHZlRWxlbWVudE9wdGlvbnModCwgZSA9IFwiZGVmYXVsdFwiLCBzKSB7XG4gICAgY29uc3QgbiA9IGUgPT09IFwiYWN0aXZlXCIsIG8gPSB0aGlzLl9jYWNoZWREYXRhT3B0cywgciA9IHQgKyBcIi1cIiArIGUsIGEgPSBvW3JdLCBsID0gdGhpcy5lbmFibGVPcHRpb25TaGFyaW5nICYmIGV0KHMpO1xuICAgIGlmIChhKVxuICAgICAgcmV0dXJuIHlzKGEsIGwpO1xuICAgIGNvbnN0IGMgPSB0aGlzLmNoYXJ0LmNvbmZpZywgaCA9IGMuZGF0YXNldEVsZW1lbnRTY29wZUtleXModGhpcy5fdHlwZSwgdCksIGQgPSBuID8gW2Ake3R9SG92ZXJgLCBcImhvdmVyXCIsIHQsIFwiXCJdIDogW3QsIFwiXCJdLCB1ID0gYy5nZXRPcHRpb25TY29wZXModGhpcy5nZXREYXRhc2V0KCksIGgpLCBmID0gT2JqZWN0LmtleXMoTy5lbGVtZW50c1t0XSksIGcgPSAoKSA9PiB0aGlzLmdldENvbnRleHQocywgbiksIHAgPSBjLnJlc29sdmVOYW1lZE9wdGlvbnModSwgZiwgZywgZCk7XG4gICAgcmV0dXJuIHAuJHNoYXJlZCAmJiAocC4kc2hhcmVkID0gbCwgb1tyXSA9IE9iamVjdC5mcmVlemUoeXMocCwgbCkpKSwgcDtcbiAgfVxuICBfcmVzb2x2ZUFuaW1hdGlvbnModCwgZSwgcykge1xuICAgIGNvbnN0IG4gPSB0aGlzLmNoYXJ0LCBvID0gdGhpcy5fY2FjaGVkRGF0YU9wdHMsIHIgPSBgYW5pbWF0aW9uLSR7ZX1gLCBhID0gb1tyXTtcbiAgICBpZiAoYSlcbiAgICAgIHJldHVybiBhO1xuICAgIGxldCBsO1xuICAgIGlmIChuLm9wdGlvbnMuYW5pbWF0aW9uICE9PSAhMSkge1xuICAgICAgY29uc3QgaCA9IHRoaXMuY2hhcnQuY29uZmlnLCBkID0gaC5kYXRhc2V0QW5pbWF0aW9uU2NvcGVLZXlzKHRoaXMuX3R5cGUsIGUpLCB1ID0gaC5nZXRPcHRpb25TY29wZXModGhpcy5nZXREYXRhc2V0KCksIGQpO1xuICAgICAgbCA9IGguY3JlYXRlUmVzb2x2ZXIodSwgdGhpcy5nZXRDb250ZXh0KHQsIHMsIGUpKTtcbiAgICB9XG4gICAgY29uc3QgYyA9IG5ldyBOaShuLCBsICYmIGwuYW5pbWF0aW9ucyk7XG4gICAgcmV0dXJuIGwgJiYgbC5fY2FjaGVhYmxlICYmIChvW3JdID0gT2JqZWN0LmZyZWV6ZShjKSksIGM7XG4gIH1cbiAgZ2V0U2hhcmVkT3B0aW9ucyh0KSB7XG4gICAgaWYgKHQuJHNoYXJlZClcbiAgICAgIHJldHVybiB0aGlzLl9zaGFyZWRPcHRpb25zIHx8ICh0aGlzLl9zaGFyZWRPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgdCkpO1xuICB9XG4gIGluY2x1ZGVPcHRpb25zKHQsIGUpIHtcbiAgICByZXR1cm4gIWUgfHwgY2kodCkgfHwgdGhpcy5jaGFydC5fYW5pbWF0aW9uc0Rpc2FibGVkO1xuICB9XG4gIF9nZXRTaGFyZWRPcHRpb25zKHQsIGUpIHtcbiAgICBjb25zdCBzID0gdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKHQsIGUpLCBuID0gdGhpcy5fc2hhcmVkT3B0aW9ucywgbyA9IHRoaXMuZ2V0U2hhcmVkT3B0aW9ucyhzKSwgciA9IHRoaXMuaW5jbHVkZU9wdGlvbnMoZSwgbykgfHwgbyAhPT0gbjtcbiAgICByZXR1cm4gdGhpcy51cGRhdGVTaGFyZWRPcHRpb25zKG8sIGUsIHMpLCB7IHNoYXJlZE9wdGlvbnM6IG8sIGluY2x1ZGVPcHRpb25zOiByIH07XG4gIH1cbiAgdXBkYXRlRWxlbWVudCh0LCBlLCBzLCBuKSB7XG4gICAgY2kobikgPyBPYmplY3QuYXNzaWduKHQsIHMpIDogdGhpcy5fcmVzb2x2ZUFuaW1hdGlvbnMoZSwgbikudXBkYXRlKHQsIHMpO1xuICB9XG4gIHVwZGF0ZVNoYXJlZE9wdGlvbnModCwgZSwgcykge1xuICAgIHQgJiYgIWNpKGUpICYmIHRoaXMuX3Jlc29sdmVBbmltYXRpb25zKHZvaWQgMCwgZSkudXBkYXRlKHQsIHMpO1xuICB9XG4gIF9zZXRTdHlsZSh0LCBlLCBzLCBuKSB7XG4gICAgdC5hY3RpdmUgPSBuO1xuICAgIGNvbnN0IG8gPSB0aGlzLmdldFN0eWxlKGUsIG4pO1xuICAgIHRoaXMuX3Jlc29sdmVBbmltYXRpb25zKGUsIHMsIG4pLnVwZGF0ZSh0LCB7XG4gICAgICBvcHRpb25zOiAhbiAmJiB0aGlzLmdldFNoYXJlZE9wdGlvbnMobykgfHwgb1xuICAgIH0pO1xuICB9XG4gIHJlbW92ZUhvdmVyU3R5bGUodCwgZSwgcykge1xuICAgIHRoaXMuX3NldFN0eWxlKHQsIHMsIFwiYWN0aXZlXCIsICExKTtcbiAgfVxuICBzZXRIb3ZlclN0eWxlKHQsIGUsIHMpIHtcbiAgICB0aGlzLl9zZXRTdHlsZSh0LCBzLCBcImFjdGl2ZVwiLCAhMCk7XG4gIH1cbiAgX3JlbW92ZURhdGFzZXRIb3ZlclN0eWxlKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9jYWNoZWRNZXRhLmRhdGFzZXQ7XG4gICAgdCAmJiB0aGlzLl9zZXRTdHlsZSh0LCB2b2lkIDAsIFwiYWN0aXZlXCIsICExKTtcbiAgfVxuICBfc2V0RGF0YXNldEhvdmVyU3R5bGUoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX2NhY2hlZE1ldGEuZGF0YXNldDtcbiAgICB0ICYmIHRoaXMuX3NldFN0eWxlKHQsIHZvaWQgMCwgXCJhY3RpdmVcIiwgITApO1xuICB9XG4gIF9yZXN5bmNFbGVtZW50cyh0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuX2RhdGEsIHMgPSB0aGlzLl9jYWNoZWRNZXRhLmRhdGE7XG4gICAgZm9yIChjb25zdCBbYSwgbCwgY10gb2YgdGhpcy5fc3luY0xpc3QpXG4gICAgICB0aGlzW2FdKGwsIGMpO1xuICAgIHRoaXMuX3N5bmNMaXN0ID0gW107XG4gICAgY29uc3QgbiA9IHMubGVuZ3RoLCBvID0gZS5sZW5ndGgsIHIgPSBNYXRoLm1pbihvLCBuKTtcbiAgICByICYmIHRoaXMucGFyc2UoMCwgciksIG8gPiBuID8gdGhpcy5faW5zZXJ0RWxlbWVudHMobiwgbyAtIG4sIHQpIDogbyA8IG4gJiYgdGhpcy5fcmVtb3ZlRWxlbWVudHMobywgbiAtIG8pO1xuICB9XG4gIF9pbnNlcnRFbGVtZW50cyh0LCBlLCBzID0gITApIHtcbiAgICBjb25zdCBuID0gdGhpcy5fY2FjaGVkTWV0YSwgbyA9IG4uZGF0YSwgciA9IHQgKyBlO1xuICAgIGxldCBhO1xuICAgIGNvbnN0IGwgPSAoYykgPT4ge1xuICAgICAgZm9yIChjLmxlbmd0aCArPSBlLCBhID0gYy5sZW5ndGggLSAxOyBhID49IHI7IGEtLSlcbiAgICAgICAgY1thXSA9IGNbYSAtIGVdO1xuICAgIH07XG4gICAgZm9yIChsKG8pLCBhID0gdDsgYSA8IHI7ICsrYSlcbiAgICAgIG9bYV0gPSBuZXcgdGhpcy5kYXRhRWxlbWVudFR5cGUoKTtcbiAgICB0aGlzLl9wYXJzaW5nICYmIGwobi5fcGFyc2VkKSwgdGhpcy5wYXJzZSh0LCBlKSwgcyAmJiB0aGlzLnVwZGF0ZUVsZW1lbnRzKG8sIHQsIGUsIFwicmVzZXRcIik7XG4gIH1cbiAgdXBkYXRlRWxlbWVudHModCwgZSwgcywgbikge1xuICB9XG4gIF9yZW1vdmVFbGVtZW50cyh0LCBlKSB7XG4gICAgY29uc3QgcyA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgaWYgKHRoaXMuX3BhcnNpbmcpIHtcbiAgICAgIGNvbnN0IG4gPSBzLl9wYXJzZWQuc3BsaWNlKHQsIGUpO1xuICAgICAgcy5fc3RhY2tlZCAmJiBZdChzLCBuKTtcbiAgICB9XG4gICAgcy5kYXRhLnNwbGljZSh0LCBlKTtcbiAgfVxuICBfc3luYyh0KSB7XG4gICAgaWYgKHRoaXMuX3BhcnNpbmcpXG4gICAgICB0aGlzLl9zeW5jTGlzdC5wdXNoKHQpO1xuICAgIGVsc2Uge1xuICAgICAgY29uc3QgW2UsIHMsIG5dID0gdDtcbiAgICAgIHRoaXNbZV0ocywgbik7XG4gICAgfVxuICAgIHRoaXMuY2hhcnQuX2RhdGFDaGFuZ2VzLnB1c2goW3RoaXMuaW5kZXgsIC4uLnRdKTtcbiAgfVxuICBfb25EYXRhUHVzaCgpIHtcbiAgICBjb25zdCB0ID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB0aGlzLl9zeW5jKFtcIl9pbnNlcnRFbGVtZW50c1wiLCB0aGlzLmdldERhdGFzZXQoKS5kYXRhLmxlbmd0aCAtIHQsIHRdKTtcbiAgfVxuICBfb25EYXRhUG9wKCkge1xuICAgIHRoaXMuX3N5bmMoW1wiX3JlbW92ZUVsZW1lbnRzXCIsIHRoaXMuX2NhY2hlZE1ldGEuZGF0YS5sZW5ndGggLSAxLCAxXSk7XG4gIH1cbiAgX29uRGF0YVNoaWZ0KCkge1xuICAgIHRoaXMuX3N5bmMoW1wiX3JlbW92ZUVsZW1lbnRzXCIsIDAsIDFdKTtcbiAgfVxuICBfb25EYXRhU3BsaWNlKHQsIGUpIHtcbiAgICBlICYmIHRoaXMuX3N5bmMoW1wiX3JlbW92ZUVsZW1lbnRzXCIsIHQsIGVdKTtcbiAgICBjb25zdCBzID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG4gICAgcyAmJiB0aGlzLl9zeW5jKFtcIl9pbnNlcnRFbGVtZW50c1wiLCB0LCBzXSk7XG4gIH1cbiAgX29uRGF0YVVuc2hpZnQoKSB7XG4gICAgdGhpcy5fc3luYyhbXCJfaW5zZXJ0RWxlbWVudHNcIiwgMCwgYXJndW1lbnRzLmxlbmd0aF0pO1xuICB9XG59XG5pdC5kZWZhdWx0cyA9IHt9O1xuaXQucHJvdG90eXBlLmRhdGFzZXRFbGVtZW50VHlwZSA9IG51bGw7XG5pdC5wcm90b3R5cGUuZGF0YUVsZW1lbnRUeXBlID0gbnVsbDtcbmZ1bmN0aW9uIGZhKGksIHQpIHtcbiAgaWYgKCFpLl9jYWNoZS4kYmFyKSB7XG4gICAgY29uc3QgZSA9IGkuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXModCk7XG4gICAgbGV0IHMgPSBbXTtcbiAgICBmb3IgKGxldCBuID0gMCwgbyA9IGUubGVuZ3RoOyBuIDwgbzsgbisrKVxuICAgICAgcyA9IHMuY29uY2F0KGVbbl0uY29udHJvbGxlci5nZXRBbGxQYXJzZWRWYWx1ZXMoaSkpO1xuICAgIGkuX2NhY2hlLiRiYXIgPSB1bihzLnNvcnQoKG4sIG8pID0+IG4gLSBvKSk7XG4gIH1cbiAgcmV0dXJuIGkuX2NhY2hlLiRiYXI7XG59XG5mdW5jdGlvbiBnYShpKSB7XG4gIGNvbnN0IHQgPSBpLmlTY2FsZSwgZSA9IGZhKHQsIGkudHlwZSk7XG4gIGxldCBzID0gdC5fbGVuZ3RoLCBuLCBvLCByLCBhO1xuICBjb25zdCBsID0gKCkgPT4ge1xuICAgIHIgPT09IDMyNzY3IHx8IHIgPT09IC0zMjc2OCB8fCAoZXQoYSkgJiYgKHMgPSBNYXRoLm1pbihzLCBNYXRoLmFicyhyIC0gYSkgfHwgcykpLCBhID0gcik7XG4gIH07XG4gIGZvciAobiA9IDAsIG8gPSBlLmxlbmd0aDsgbiA8IG87ICsrbilcbiAgICByID0gdC5nZXRQaXhlbEZvclZhbHVlKGVbbl0pLCBsKCk7XG4gIGZvciAoYSA9IHZvaWQgMCwgbiA9IDAsIG8gPSB0LnRpY2tzLmxlbmd0aDsgbiA8IG87ICsrbilcbiAgICByID0gdC5nZXRQaXhlbEZvclRpY2sobiksIGwoKTtcbiAgcmV0dXJuIHM7XG59XG5mdW5jdGlvbiBwYShpLCB0LCBlLCBzKSB7XG4gIGNvbnN0IG4gPSBlLmJhclRoaWNrbmVzcztcbiAgbGV0IG8sIHI7XG4gIHJldHVybiBUKG4pID8gKG8gPSB0Lm1pbiAqIGUuY2F0ZWdvcnlQZXJjZW50YWdlLCByID0gZS5iYXJQZXJjZW50YWdlKSA6IChvID0gbiAqIHMsIHIgPSAxKSwge1xuICAgIGNodW5rOiBvIC8gcyxcbiAgICByYXRpbzogcixcbiAgICBzdGFydDogdC5waXhlbHNbaV0gLSBvIC8gMlxuICB9O1xufVxuZnVuY3Rpb24gbWEoaSwgdCwgZSwgcykge1xuICBjb25zdCBuID0gdC5waXhlbHMsIG8gPSBuW2ldO1xuICBsZXQgciA9IGkgPiAwID8gbltpIC0gMV0gOiBudWxsLCBhID0gaSA8IG4ubGVuZ3RoIC0gMSA/IG5baSArIDFdIDogbnVsbDtcbiAgY29uc3QgbCA9IGUuY2F0ZWdvcnlQZXJjZW50YWdlO1xuICByID09PSBudWxsICYmIChyID0gbyAtIChhID09PSBudWxsID8gdC5lbmQgLSB0LnN0YXJ0IDogYSAtIG8pKSwgYSA9PT0gbnVsbCAmJiAoYSA9IG8gKyBvIC0gcik7XG4gIGNvbnN0IGMgPSBvIC0gKG8gLSBNYXRoLm1pbihyLCBhKSkgLyAyICogbDtcbiAgcmV0dXJuIHtcbiAgICBjaHVuazogTWF0aC5hYnMoYSAtIHIpIC8gMiAqIGwgLyBzLFxuICAgIHJhdGlvOiBlLmJhclBlcmNlbnRhZ2UsXG4gICAgc3RhcnQ6IGNcbiAgfTtcbn1cbmZ1bmN0aW9uIGJhKGksIHQsIGUsIHMpIHtcbiAgY29uc3QgbiA9IGUucGFyc2UoaVswXSwgcyksIG8gPSBlLnBhcnNlKGlbMV0sIHMpLCByID0gTWF0aC5taW4obiwgbyksIGEgPSBNYXRoLm1heChuLCBvKTtcbiAgbGV0IGwgPSByLCBjID0gYTtcbiAgTWF0aC5hYnMocikgPiBNYXRoLmFicyhhKSAmJiAobCA9IGEsIGMgPSByKSwgdFtlLmF4aXNdID0gYywgdC5fY3VzdG9tID0ge1xuICAgIGJhclN0YXJ0OiBsLFxuICAgIGJhckVuZDogYyxcbiAgICBzdGFydDogbixcbiAgICBlbmQ6IG8sXG4gICAgbWluOiByLFxuICAgIG1heDogYVxuICB9O1xufVxuZnVuY3Rpb24gQm4oaSwgdCwgZSwgcykge1xuICByZXR1cm4geihpKSA/IGJhKGksIHQsIGUsIHMpIDogdFtlLmF4aXNdID0gZS5wYXJzZShpLCBzKSwgdDtcbn1cbmZ1bmN0aW9uIHZzKGksIHQsIGUsIHMpIHtcbiAgY29uc3QgbiA9IGkuaVNjYWxlLCBvID0gaS52U2NhbGUsIHIgPSBuLmdldExhYmVscygpLCBhID0gbiA9PT0gbywgbCA9IFtdO1xuICBsZXQgYywgaCwgZCwgdTtcbiAgZm9yIChjID0gZSwgaCA9IGUgKyBzOyBjIDwgaDsgKytjKVxuICAgIHUgPSB0W2NdLCBkID0ge30sIGRbbi5heGlzXSA9IGEgfHwgbi5wYXJzZShyW2NdLCBjKSwgbC5wdXNoKEJuKHUsIGQsIG8sIGMpKTtcbiAgcmV0dXJuIGw7XG59XG5mdW5jdGlvbiBoaShpKSB7XG4gIHJldHVybiBpICYmIGkuYmFyU3RhcnQgIT09IHZvaWQgMCAmJiBpLmJhckVuZCAhPT0gdm9pZCAwO1xufVxuZnVuY3Rpb24geGEoaSwgdCwgZSkge1xuICByZXR1cm4gaSAhPT0gMCA/IGx0KGkpIDogKHQuaXNIb3Jpem9udGFsKCkgPyAxIDogLTEpICogKHQubWluID49IGUgPyAxIDogLTEpO1xufVxuZnVuY3Rpb24gX2EoaSkge1xuICBsZXQgdCwgZSwgcywgbiwgbztcbiAgcmV0dXJuIGkuaG9yaXpvbnRhbCA/ICh0ID0gaS5iYXNlID4gaS54LCBlID0gXCJsZWZ0XCIsIHMgPSBcInJpZ2h0XCIpIDogKHQgPSBpLmJhc2UgPCBpLnksIGUgPSBcImJvdHRvbVwiLCBzID0gXCJ0b3BcIiksIHQgPyAobiA9IFwiZW5kXCIsIG8gPSBcInN0YXJ0XCIpIDogKG4gPSBcInN0YXJ0XCIsIG8gPSBcImVuZFwiKSwgeyBzdGFydDogZSwgZW5kOiBzLCByZXZlcnNlOiB0LCB0b3A6IG4sIGJvdHRvbTogbyB9O1xufVxuZnVuY3Rpb24geWEoaSwgdCwgZSwgcykge1xuICBsZXQgbiA9IHQuYm9yZGVyU2tpcHBlZDtcbiAgY29uc3QgbyA9IHt9O1xuICBpZiAoIW4pIHtcbiAgICBpLmJvcmRlclNraXBwZWQgPSBvO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAobiA9PT0gITApIHtcbiAgICBpLmJvcmRlclNraXBwZWQgPSB7IHRvcDogITAsIHJpZ2h0OiAhMCwgYm90dG9tOiAhMCwgbGVmdDogITAgfTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgeyBzdGFydDogciwgZW5kOiBhLCByZXZlcnNlOiBsLCB0b3A6IGMsIGJvdHRvbTogaCB9ID0gX2EoaSk7XG4gIG4gPT09IFwibWlkZGxlXCIgJiYgZSAmJiAoaS5lbmFibGVCb3JkZXJSYWRpdXMgPSAhMCwgKGUuX3RvcCB8fCAwKSA9PT0gcyA/IG4gPSBjIDogKGUuX2JvdHRvbSB8fCAwKSA9PT0gcyA/IG4gPSBoIDogKG9bTXMoaCwgciwgYSwgbCldID0gITAsIG4gPSBjKSksIG9bTXMobiwgciwgYSwgbCldID0gITAsIGkuYm9yZGVyU2tpcHBlZCA9IG87XG59XG5mdW5jdGlvbiBNcyhpLCB0LCBlLCBzKSB7XG4gIHJldHVybiBzID8gKGkgPSB2YShpLCB0LCBlKSwgaSA9IGtzKGksIGUsIHQpKSA6IGkgPSBrcyhpLCB0LCBlKSwgaTtcbn1cbmZ1bmN0aW9uIHZhKGksIHQsIGUpIHtcbiAgcmV0dXJuIGkgPT09IHQgPyBlIDogaSA9PT0gZSA/IHQgOiBpO1xufVxuZnVuY3Rpb24ga3MoaSwgdCwgZSkge1xuICByZXR1cm4gaSA9PT0gXCJzdGFydFwiID8gdCA6IGkgPT09IFwiZW5kXCIgPyBlIDogaTtcbn1cbmZ1bmN0aW9uIE1hKGksIHsgaW5mbGF0ZUFtb3VudDogdCB9LCBlKSB7XG4gIGkuaW5mbGF0ZUFtb3VudCA9IHQgPT09IFwiYXV0b1wiID8gZSA9PT0gMSA/IDAuMzMgOiAwIDogdDtcbn1cbmNsYXNzIHVlIGV4dGVuZHMgaXQge1xuICBwYXJzZVByaW1pdGl2ZURhdGEodCwgZSwgcywgbikge1xuICAgIHJldHVybiB2cyh0LCBlLCBzLCBuKTtcbiAgfVxuICBwYXJzZUFycmF5RGF0YSh0LCBlLCBzLCBuKSB7XG4gICAgcmV0dXJuIHZzKHQsIGUsIHMsIG4pO1xuICB9XG4gIHBhcnNlT2JqZWN0RGF0YSh0LCBlLCBzLCBuKSB7XG4gICAgY29uc3QgeyBpU2NhbGU6IG8sIHZTY2FsZTogciB9ID0gdCwgeyB4QXhpc0tleTogYSA9IFwieFwiLCB5QXhpc0tleTogbCA9IFwieVwiIH0gPSB0aGlzLl9wYXJzaW5nLCBjID0gby5heGlzID09PSBcInhcIiA/IGEgOiBsLCBoID0gci5heGlzID09PSBcInhcIiA/IGEgOiBsLCBkID0gW107XG4gICAgbGV0IHUsIGYsIGcsIHA7XG4gICAgZm9yICh1ID0gcywgZiA9IHMgKyBuOyB1IDwgZjsgKyt1KVxuICAgICAgcCA9IGVbdV0sIGcgPSB7fSwgZ1tvLmF4aXNdID0gby5wYXJzZShfdChwLCBjKSwgdSksIGQucHVzaChCbihfdChwLCBoKSwgZywgciwgdSkpO1xuICAgIHJldHVybiBkO1xuICB9XG4gIHVwZGF0ZVJhbmdlRnJvbVBhcnNlZCh0LCBlLCBzLCBuKSB7XG4gICAgc3VwZXIudXBkYXRlUmFuZ2VGcm9tUGFyc2VkKHQsIGUsIHMsIG4pO1xuICAgIGNvbnN0IG8gPSBzLl9jdXN0b207XG4gICAgbyAmJiBlID09PSB0aGlzLl9jYWNoZWRNZXRhLnZTY2FsZSAmJiAodC5taW4gPSBNYXRoLm1pbih0Lm1pbiwgby5taW4pLCB0Lm1heCA9IE1hdGgubWF4KHQubWF4LCBvLm1heCkpO1xuICB9XG4gIGdldE1heE92ZXJmbG93KCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGdldExhYmVsQW5kVmFsdWUodCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLl9jYWNoZWRNZXRhLCB7IGlTY2FsZTogcywgdlNjYWxlOiBuIH0gPSBlLCBvID0gdGhpcy5nZXRQYXJzZWQodCksIHIgPSBvLl9jdXN0b20sIGEgPSBoaShyKSA/IFwiW1wiICsgci5zdGFydCArIFwiLCBcIiArIHIuZW5kICsgXCJdXCIgOiBcIlwiICsgbi5nZXRMYWJlbEZvclZhbHVlKG9bbi5heGlzXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxhYmVsOiBcIlwiICsgcy5nZXRMYWJlbEZvclZhbHVlKG9bcy5heGlzXSksXG4gICAgICB2YWx1ZTogYVxuICAgIH07XG4gIH1cbiAgaW5pdGlhbGl6ZSgpIHtcbiAgICB0aGlzLmVuYWJsZU9wdGlvblNoYXJpbmcgPSAhMCwgc3VwZXIuaW5pdGlhbGl6ZSgpO1xuICAgIGNvbnN0IHQgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIHQuc3RhY2sgPSB0aGlzLmdldERhdGFzZXQoKS5zdGFjaztcbiAgfVxuICB1cGRhdGUodCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIHRoaXMudXBkYXRlRWxlbWVudHMoZS5kYXRhLCAwLCBlLmRhdGEubGVuZ3RoLCB0KTtcbiAgfVxuICB1cGRhdGVFbGVtZW50cyh0LCBlLCBzLCBuKSB7XG4gICAgY29uc3QgbyA9IG4gPT09IFwicmVzZXRcIiwgeyBpbmRleDogciwgX2NhY2hlZE1ldGE6IHsgdlNjYWxlOiBhIH0gfSA9IHRoaXMsIGwgPSBhLmdldEJhc2VQaXhlbCgpLCBjID0gYS5pc0hvcml6b250YWwoKSwgaCA9IHRoaXMuX2dldFJ1bGVyKCksIHsgc2hhcmVkT3B0aW9uczogZCwgaW5jbHVkZU9wdGlvbnM6IHUgfSA9IHRoaXMuX2dldFNoYXJlZE9wdGlvbnMoZSwgbik7XG4gICAgZm9yIChsZXQgZiA9IGU7IGYgPCBlICsgczsgZisrKSB7XG4gICAgICBjb25zdCBnID0gdGhpcy5nZXRQYXJzZWQoZiksIHAgPSBvIHx8IFQoZ1thLmF4aXNdKSA/IHsgYmFzZTogbCwgaGVhZDogbCB9IDogdGhpcy5fY2FsY3VsYXRlQmFyVmFsdWVQaXhlbHMoZiksIG0gPSB0aGlzLl9jYWxjdWxhdGVCYXJJbmRleFBpeGVscyhmLCBoKSwgYiA9IChnLl9zdGFja3MgfHwge30pW2EuYXhpc10sIHggPSB7XG4gICAgICAgIGhvcml6b250YWw6IGMsXG4gICAgICAgIGJhc2U6IHAuYmFzZSxcbiAgICAgICAgZW5hYmxlQm9yZGVyUmFkaXVzOiAhYiB8fCBoaShnLl9jdXN0b20pIHx8IHIgPT09IGIuX3RvcCB8fCByID09PSBiLl9ib3R0b20sXG4gICAgICAgIHg6IGMgPyBwLmhlYWQgOiBtLmNlbnRlcixcbiAgICAgICAgeTogYyA/IG0uY2VudGVyIDogcC5oZWFkLFxuICAgICAgICBoZWlnaHQ6IGMgPyBtLnNpemUgOiBNYXRoLmFicyhwLnNpemUpLFxuICAgICAgICB3aWR0aDogYyA/IE1hdGguYWJzKHAuc2l6ZSkgOiBtLnNpemVcbiAgICAgIH07XG4gICAgICB1ICYmICh4Lm9wdGlvbnMgPSBkIHx8IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhmLCB0W2ZdLmFjdGl2ZSA/IFwiYWN0aXZlXCIgOiBuKSk7XG4gICAgICBjb25zdCB2ID0geC5vcHRpb25zIHx8IHRbZl0ub3B0aW9ucztcbiAgICAgIHlhKHgsIHYsIGIsIHIpLCBNYSh4LCB2LCBoLnJhdGlvKSwgdGhpcy51cGRhdGVFbGVtZW50KHRbZl0sIGYsIHgsIG4pO1xuICAgIH1cbiAgfVxuICBfZ2V0U3RhY2tzKHQsIGUpIHtcbiAgICBjb25zdCB7IGlTY2FsZTogcyB9ID0gdGhpcy5fY2FjaGVkTWV0YSwgbiA9IHMuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXModGhpcy5fdHlwZSkuZmlsdGVyKChsKSA9PiBsLmNvbnRyb2xsZXIub3B0aW9ucy5ncm91cGVkKSwgbyA9IHMub3B0aW9ucy5zdGFja2VkLCByID0gW10sIGEgPSAobCkgPT4ge1xuICAgICAgY29uc3QgYyA9IGwuY29udHJvbGxlci5nZXRQYXJzZWQoZSksIGggPSBjICYmIGNbbC52U2NhbGUuYXhpc107XG4gICAgICBpZiAoVChoKSB8fCBpc05hTihoKSlcbiAgICAgICAgcmV0dXJuICEwO1xuICAgIH07XG4gICAgZm9yIChjb25zdCBsIG9mIG4pXG4gICAgICBpZiAoIShlICE9PSB2b2lkIDAgJiYgYShsKSkgJiYgKChvID09PSAhMSB8fCByLmluZGV4T2YobC5zdGFjaykgPT09IC0xIHx8IG8gPT09IHZvaWQgMCAmJiBsLnN0YWNrID09PSB2b2lkIDApICYmIHIucHVzaChsLnN0YWNrKSwgbC5pbmRleCA9PT0gdCkpXG4gICAgICAgIGJyZWFrO1xuICAgIHJldHVybiByLmxlbmd0aCB8fCByLnB1c2godm9pZCAwKSwgcjtcbiAgfVxuICBfZ2V0U3RhY2tDb3VudCh0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFN0YWNrcyh2b2lkIDAsIHQpLmxlbmd0aDtcbiAgfVxuICBfZ2V0U3RhY2tJbmRleCh0LCBlLCBzKSB7XG4gICAgY29uc3QgbiA9IHRoaXMuX2dldFN0YWNrcyh0LCBzKSwgbyA9IGUgIT09IHZvaWQgMCA/IG4uaW5kZXhPZihlKSA6IC0xO1xuICAgIHJldHVybiBvID09PSAtMSA/IG4ubGVuZ3RoIC0gMSA6IG87XG4gIH1cbiAgX2dldFJ1bGVyKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLm9wdGlvbnMsIGUgPSB0aGlzLl9jYWNoZWRNZXRhLCBzID0gZS5pU2NhbGUsIG4gPSBbXTtcbiAgICBsZXQgbywgcjtcbiAgICBmb3IgKG8gPSAwLCByID0gZS5kYXRhLmxlbmd0aDsgbyA8IHI7ICsrbylcbiAgICAgIG4ucHVzaChzLmdldFBpeGVsRm9yVmFsdWUodGhpcy5nZXRQYXJzZWQobylbcy5heGlzXSwgbykpO1xuICAgIGNvbnN0IGEgPSB0LmJhclRoaWNrbmVzcztcbiAgICByZXR1cm4ge1xuICAgICAgbWluOiBhIHx8IGdhKGUpLFxuICAgICAgcGl4ZWxzOiBuLFxuICAgICAgc3RhcnQ6IHMuX3N0YXJ0UGl4ZWwsXG4gICAgICBlbmQ6IHMuX2VuZFBpeGVsLFxuICAgICAgc3RhY2tDb3VudDogdGhpcy5fZ2V0U3RhY2tDb3VudCgpLFxuICAgICAgc2NhbGU6IHMsXG4gICAgICBncm91cGVkOiB0Lmdyb3VwZWQsXG4gICAgICByYXRpbzogYSA/IDEgOiB0LmNhdGVnb3J5UGVyY2VudGFnZSAqIHQuYmFyUGVyY2VudGFnZVxuICAgIH07XG4gIH1cbiAgX2NhbGN1bGF0ZUJhclZhbHVlUGl4ZWxzKHQpIHtcbiAgICBjb25zdCB7IF9jYWNoZWRNZXRhOiB7IHZTY2FsZTogZSwgX3N0YWNrZWQ6IHMgfSwgb3B0aW9uczogeyBiYXNlOiBuLCBtaW5CYXJMZW5ndGg6IG8gfSB9ID0gdGhpcywgciA9IG4gfHwgMCwgYSA9IHRoaXMuZ2V0UGFyc2VkKHQpLCBsID0gYS5fY3VzdG9tLCBjID0gaGkobCk7XG4gICAgbGV0IGggPSBhW2UuYXhpc10sIGQgPSAwLCB1ID0gcyA/IHRoaXMuYXBwbHlTdGFjayhlLCBhLCBzKSA6IGgsIGYsIGc7XG4gICAgdSAhPT0gaCAmJiAoZCA9IHUgLSBoLCB1ID0gaCksIGMgJiYgKGggPSBsLmJhclN0YXJ0LCB1ID0gbC5iYXJFbmQgLSBsLmJhclN0YXJ0LCBoICE9PSAwICYmIGx0KGgpICE9PSBsdChsLmJhckVuZCkgJiYgKGQgPSAwKSwgZCArPSBoKTtcbiAgICBjb25zdCBwID0gIVQobikgJiYgIWMgPyBuIDogZDtcbiAgICBsZXQgbSA9IGUuZ2V0UGl4ZWxGb3JWYWx1ZShwKTtcbiAgICBpZiAodGhpcy5jaGFydC5nZXREYXRhVmlzaWJpbGl0eSh0KSA/IGYgPSBlLmdldFBpeGVsRm9yVmFsdWUoZCArIHUpIDogZiA9IG0sIGcgPSBmIC0gbSwgTWF0aC5hYnMoZykgPCBvKSB7XG4gICAgICBnID0geGEoZywgZSwgcikgKiBvLCBoID09PSByICYmIChtIC09IGcgLyAyKTtcbiAgICAgIGNvbnN0IGIgPSBlLmdldFBpeGVsRm9yRGVjaW1hbCgwKSwgeCA9IGUuZ2V0UGl4ZWxGb3JEZWNpbWFsKDEpLCB2ID0gTWF0aC5taW4oYiwgeCksIHkgPSBNYXRoLm1heChiLCB4KTtcbiAgICAgIG0gPSBNYXRoLm1heChNYXRoLm1pbihtLCB5KSwgdiksIGYgPSBtICsgZztcbiAgICB9XG4gICAgaWYgKG0gPT09IGUuZ2V0UGl4ZWxGb3JWYWx1ZShyKSkge1xuICAgICAgY29uc3QgYiA9IGx0KGcpICogZS5nZXRMaW5lV2lkdGhGb3JWYWx1ZShyKSAvIDI7XG4gICAgICBtICs9IGIsIGcgLT0gYjtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHNpemU6IGcsXG4gICAgICBiYXNlOiBtLFxuICAgICAgaGVhZDogZixcbiAgICAgIGNlbnRlcjogZiArIGcgLyAyXG4gICAgfTtcbiAgfVxuICBfY2FsY3VsYXRlQmFySW5kZXhQaXhlbHModCwgZSkge1xuICAgIGNvbnN0IHMgPSBlLnNjYWxlLCBuID0gdGhpcy5vcHRpb25zLCBvID0gbi5za2lwTnVsbCwgciA9IEMobi5tYXhCYXJUaGlja25lc3MsIDEgLyAwKTtcbiAgICBsZXQgYSwgbDtcbiAgICBpZiAoZS5ncm91cGVkKSB7XG4gICAgICBjb25zdCBjID0gbyA/IHRoaXMuX2dldFN0YWNrQ291bnQodCkgOiBlLnN0YWNrQ291bnQsIGggPSBuLmJhclRoaWNrbmVzcyA9PT0gXCJmbGV4XCIgPyBtYSh0LCBlLCBuLCBjKSA6IHBhKHQsIGUsIG4sIGMpLCBkID0gdGhpcy5fZ2V0U3RhY2tJbmRleCh0aGlzLmluZGV4LCB0aGlzLl9jYWNoZWRNZXRhLnN0YWNrLCBvID8gdCA6IHZvaWQgMCk7XG4gICAgICBhID0gaC5zdGFydCArIGguY2h1bmsgKiBkICsgaC5jaHVuayAvIDIsIGwgPSBNYXRoLm1pbihyLCBoLmNodW5rICogaC5yYXRpbyk7XG4gICAgfSBlbHNlXG4gICAgICBhID0gcy5nZXRQaXhlbEZvclZhbHVlKHRoaXMuZ2V0UGFyc2VkKHQpW3MuYXhpc10sIHQpLCBsID0gTWF0aC5taW4ociwgZS5taW4gKiBlLnJhdGlvKTtcbiAgICByZXR1cm4ge1xuICAgICAgYmFzZTogYSAtIGwgLyAyLFxuICAgICAgaGVhZDogYSArIGwgLyAyLFxuICAgICAgY2VudGVyOiBhLFxuICAgICAgc2l6ZTogbFxuICAgIH07XG4gIH1cbiAgZHJhdygpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fY2FjaGVkTWV0YSwgZSA9IHQudlNjYWxlLCBzID0gdC5kYXRhLCBuID0gcy5sZW5ndGg7XG4gICAgbGV0IG8gPSAwO1xuICAgIGZvciAoOyBvIDwgbjsgKytvKVxuICAgICAgdGhpcy5nZXRQYXJzZWQobylbZS5heGlzXSAhPT0gbnVsbCAmJiBzW29dLmRyYXcodGhpcy5fY3R4KTtcbiAgfVxufVxudWUuaWQgPSBcImJhclwiO1xudWUuZGVmYXVsdHMgPSB7XG4gIGRhdGFzZXRFbGVtZW50VHlwZTogITEsXG4gIGRhdGFFbGVtZW50VHlwZTogXCJiYXJcIixcbiAgY2F0ZWdvcnlQZXJjZW50YWdlOiAwLjgsXG4gIGJhclBlcmNlbnRhZ2U6IDAuOSxcbiAgZ3JvdXBlZDogITAsXG4gIGFuaW1hdGlvbnM6IHtcbiAgICBudW1iZXJzOiB7XG4gICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgcHJvcGVydGllczogW1wieFwiLCBcInlcIiwgXCJiYXNlXCIsIFwid2lkdGhcIiwgXCJoZWlnaHRcIl1cbiAgICB9XG4gIH1cbn07XG51ZS5vdmVycmlkZXMgPSB7XG4gIHNjYWxlczoge1xuICAgIF9pbmRleF86IHtcbiAgICAgIHR5cGU6IFwiY2F0ZWdvcnlcIixcbiAgICAgIG9mZnNldDogITAsXG4gICAgICBncmlkOiB7XG4gICAgICAgIG9mZnNldDogITBcbiAgICAgIH1cbiAgICB9LFxuICAgIF92YWx1ZV86IHtcbiAgICAgIHR5cGU6IFwibGluZWFyXCIsXG4gICAgICBiZWdpbkF0WmVybzogITBcbiAgICB9XG4gIH1cbn07XG5jbGFzcyBmZSBleHRlbmRzIGl0IHtcbiAgaW5pdGlhbGl6ZSgpIHtcbiAgICB0aGlzLmVuYWJsZU9wdGlvblNoYXJpbmcgPSAhMCwgc3VwZXIuaW5pdGlhbGl6ZSgpO1xuICB9XG4gIHBhcnNlUHJpbWl0aXZlRGF0YSh0LCBlLCBzLCBuKSB7XG4gICAgY29uc3QgbyA9IHN1cGVyLnBhcnNlUHJpbWl0aXZlRGF0YSh0LCBlLCBzLCBuKTtcbiAgICBmb3IgKGxldCByID0gMDsgciA8IG8ubGVuZ3RoOyByKyspXG4gICAgICBvW3JdLl9jdXN0b20gPSB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMociArIHMpLnJhZGl1cztcbiAgICByZXR1cm4gbztcbiAgfVxuICBwYXJzZUFycmF5RGF0YSh0LCBlLCBzLCBuKSB7XG4gICAgY29uc3QgbyA9IHN1cGVyLnBhcnNlQXJyYXlEYXRhKHQsIGUsIHMsIG4pO1xuICAgIGZvciAobGV0IHIgPSAwOyByIDwgby5sZW5ndGg7IHIrKykge1xuICAgICAgY29uc3QgYSA9IGVbcyArIHJdO1xuICAgICAgb1tyXS5fY3VzdG9tID0gQyhhWzJdLCB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMociArIHMpLnJhZGl1cyk7XG4gICAgfVxuICAgIHJldHVybiBvO1xuICB9XG4gIHBhcnNlT2JqZWN0RGF0YSh0LCBlLCBzLCBuKSB7XG4gICAgY29uc3QgbyA9IHN1cGVyLnBhcnNlT2JqZWN0RGF0YSh0LCBlLCBzLCBuKTtcbiAgICBmb3IgKGxldCByID0gMDsgciA8IG8ubGVuZ3RoOyByKyspIHtcbiAgICAgIGNvbnN0IGEgPSBlW3MgKyByXTtcbiAgICAgIG9bcl0uX2N1c3RvbSA9IEMoYSAmJiBhLnIgJiYgK2EuciwgdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKHIgKyBzKS5yYWRpdXMpO1xuICAgIH1cbiAgICByZXR1cm4gbztcbiAgfVxuICBnZXRNYXhPdmVyZmxvdygpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhO1xuICAgIGxldCBlID0gMDtcbiAgICBmb3IgKGxldCBzID0gdC5sZW5ndGggLSAxOyBzID49IDA7IC0tcylcbiAgICAgIGUgPSBNYXRoLm1heChlLCB0W3NdLnNpemUodGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKHMpKSAvIDIpO1xuICAgIHJldHVybiBlID4gMCAmJiBlO1xuICB9XG4gIGdldExhYmVsQW5kVmFsdWUodCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLl9jYWNoZWRNZXRhLCB7IHhTY2FsZTogcywgeVNjYWxlOiBuIH0gPSBlLCBvID0gdGhpcy5nZXRQYXJzZWQodCksIHIgPSBzLmdldExhYmVsRm9yVmFsdWUoby54KSwgYSA9IG4uZ2V0TGFiZWxGb3JWYWx1ZShvLnkpLCBsID0gby5fY3VzdG9tO1xuICAgIHJldHVybiB7XG4gICAgICBsYWJlbDogZS5sYWJlbCxcbiAgICAgIHZhbHVlOiBcIihcIiArIHIgKyBcIiwgXCIgKyBhICsgKGwgPyBcIiwgXCIgKyBsIDogXCJcIikgKyBcIilcIlxuICAgIH07XG4gIH1cbiAgdXBkYXRlKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhO1xuICAgIHRoaXMudXBkYXRlRWxlbWVudHMoZSwgMCwgZS5sZW5ndGgsIHQpO1xuICB9XG4gIHVwZGF0ZUVsZW1lbnRzKHQsIGUsIHMsIG4pIHtcbiAgICBjb25zdCBvID0gbiA9PT0gXCJyZXNldFwiLCB7IGlTY2FsZTogciwgdlNjYWxlOiBhIH0gPSB0aGlzLl9jYWNoZWRNZXRhLCB7IHNoYXJlZE9wdGlvbnM6IGwsIGluY2x1ZGVPcHRpb25zOiBjIH0gPSB0aGlzLl9nZXRTaGFyZWRPcHRpb25zKGUsIG4pLCBoID0gci5heGlzLCBkID0gYS5heGlzO1xuICAgIGZvciAobGV0IHUgPSBlOyB1IDwgZSArIHM7IHUrKykge1xuICAgICAgY29uc3QgZiA9IHRbdV0sIGcgPSAhbyAmJiB0aGlzLmdldFBhcnNlZCh1KSwgcCA9IHt9LCBtID0gcFtoXSA9IG8gPyByLmdldFBpeGVsRm9yRGVjaW1hbCgwLjUpIDogci5nZXRQaXhlbEZvclZhbHVlKGdbaF0pLCBiID0gcFtkXSA9IG8gPyBhLmdldEJhc2VQaXhlbCgpIDogYS5nZXRQaXhlbEZvclZhbHVlKGdbZF0pO1xuICAgICAgcC5za2lwID0gaXNOYU4obSkgfHwgaXNOYU4oYiksIGMgJiYgKHAub3B0aW9ucyA9IGwgfHwgdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKHUsIGYuYWN0aXZlID8gXCJhY3RpdmVcIiA6IG4pLCBvICYmIChwLm9wdGlvbnMucmFkaXVzID0gMCkpLCB0aGlzLnVwZGF0ZUVsZW1lbnQoZiwgdSwgcCwgbik7XG4gICAgfVxuICB9XG4gIHJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnModCwgZSkge1xuICAgIGNvbnN0IHMgPSB0aGlzLmdldFBhcnNlZCh0KTtcbiAgICBsZXQgbiA9IHN1cGVyLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnModCwgZSk7XG4gICAgbi4kc2hhcmVkICYmIChuID0gT2JqZWN0LmFzc2lnbih7fSwgbiwgeyAkc2hhcmVkOiAhMSB9KSk7XG4gICAgY29uc3QgbyA9IG4ucmFkaXVzO1xuICAgIHJldHVybiBlICE9PSBcImFjdGl2ZVwiICYmIChuLnJhZGl1cyA9IDApLCBuLnJhZGl1cyArPSBDKHMgJiYgcy5fY3VzdG9tLCBvKSwgbjtcbiAgfVxufVxuZmUuaWQgPSBcImJ1YmJsZVwiO1xuZmUuZGVmYXVsdHMgPSB7XG4gIGRhdGFzZXRFbGVtZW50VHlwZTogITEsXG4gIGRhdGFFbGVtZW50VHlwZTogXCJwb2ludFwiLFxuICBhbmltYXRpb25zOiB7XG4gICAgbnVtYmVyczoge1xuICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgIHByb3BlcnRpZXM6IFtcInhcIiwgXCJ5XCIsIFwiYm9yZGVyV2lkdGhcIiwgXCJyYWRpdXNcIl1cbiAgICB9XG4gIH1cbn07XG5mZS5vdmVycmlkZXMgPSB7XG4gIHNjYWxlczoge1xuICAgIHg6IHtcbiAgICAgIHR5cGU6IFwibGluZWFyXCJcbiAgICB9LFxuICAgIHk6IHtcbiAgICAgIHR5cGU6IFwibGluZWFyXCJcbiAgICB9XG4gIH0sXG4gIHBsdWdpbnM6IHtcbiAgICB0b29sdGlwOiB7XG4gICAgICBjYWxsYmFja3M6IHtcbiAgICAgICAgdGl0bGUoKSB7XG4gICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5mdW5jdGlvbiBrYShpLCB0LCBlKSB7XG4gIGxldCBzID0gMSwgbiA9IDEsIG8gPSAwLCByID0gMDtcbiAgaWYgKHQgPCBGKSB7XG4gICAgY29uc3QgYSA9IGksIGwgPSBhICsgdCwgYyA9IE1hdGguY29zKGEpLCBoID0gTWF0aC5zaW4oYSksIGQgPSBNYXRoLmNvcyhsKSwgdSA9IE1hdGguc2luKGwpLCBmID0gKHYsIHksIF8pID0+IG9lKHYsIGEsIGwsICEwKSA/IDEgOiBNYXRoLm1heCh5LCB5ICogZSwgXywgXyAqIGUpLCBnID0gKHYsIHksIF8pID0+IG9lKHYsIGEsIGwsICEwKSA/IC0xIDogTWF0aC5taW4oeSwgeSAqIGUsIF8sIF8gKiBlKSwgcCA9IGYoMCwgYywgZCksIG0gPSBmKFYsIGgsIHUpLCBiID0gZyhCLCBjLCBkKSwgeCA9IGcoQiArIFYsIGgsIHUpO1xuICAgIHMgPSAocCAtIGIpIC8gMiwgbiA9IChtIC0geCkgLyAyLCBvID0gLShwICsgYikgLyAyLCByID0gLShtICsgeCkgLyAyO1xuICB9XG4gIHJldHVybiB7IHJhdGlvWDogcywgcmF0aW9ZOiBuLCBvZmZzZXRYOiBvLCBvZmZzZXRZOiByIH07XG59XG5jbGFzcyBMdCBleHRlbmRzIGl0IHtcbiAgY29uc3RydWN0b3IodCwgZSkge1xuICAgIHN1cGVyKHQsIGUpLCB0aGlzLmVuYWJsZU9wdGlvblNoYXJpbmcgPSAhMCwgdGhpcy5pbm5lclJhZGl1cyA9IHZvaWQgMCwgdGhpcy5vdXRlclJhZGl1cyA9IHZvaWQgMCwgdGhpcy5vZmZzZXRYID0gdm9pZCAwLCB0aGlzLm9mZnNldFkgPSB2b2lkIDA7XG4gIH1cbiAgbGlua1NjYWxlcygpIHtcbiAgfVxuICBwYXJzZSh0LCBlKSB7XG4gICAgY29uc3QgcyA9IHRoaXMuZ2V0RGF0YXNldCgpLmRhdGEsIG4gPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGlmICh0aGlzLl9wYXJzaW5nID09PSAhMSlcbiAgICAgIG4uX3BhcnNlZCA9IHM7XG4gICAgZWxzZSB7XG4gICAgICBsZXQgbyA9IChsKSA9PiArc1tsXTtcbiAgICAgIGlmIChEKHNbdF0pKSB7XG4gICAgICAgIGNvbnN0IHsga2V5OiBsID0gXCJ2YWx1ZVwiIH0gPSB0aGlzLl9wYXJzaW5nO1xuICAgICAgICBvID0gKGMpID0+ICtfdChzW2NdLCBsKTtcbiAgICAgIH1cbiAgICAgIGxldCByLCBhO1xuICAgICAgZm9yIChyID0gdCwgYSA9IHQgKyBlOyByIDwgYTsgKytyKVxuICAgICAgICBuLl9wYXJzZWRbcl0gPSBvKHIpO1xuICAgIH1cbiAgfVxuICBfZ2V0Um90YXRpb24oKSB7XG4gICAgcmV0dXJuIG50KHRoaXMub3B0aW9ucy5yb3RhdGlvbiAtIDkwKTtcbiAgfVxuICBfZ2V0Q2lyY3VtZmVyZW5jZSgpIHtcbiAgICByZXR1cm4gbnQodGhpcy5vcHRpb25zLmNpcmN1bWZlcmVuY2UpO1xuICB9XG4gIF9nZXRSb3RhdGlvbkV4dGVudHMoKSB7XG4gICAgbGV0IHQgPSBGLCBlID0gLUY7XG4gICAgZm9yIChsZXQgcyA9IDA7IHMgPCB0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHMubGVuZ3RoOyArK3MpXG4gICAgICBpZiAodGhpcy5jaGFydC5pc0RhdGFzZXRWaXNpYmxlKHMpKSB7XG4gICAgICAgIGNvbnN0IG4gPSB0aGlzLmNoYXJ0LmdldERhdGFzZXRNZXRhKHMpLmNvbnRyb2xsZXIsIG8gPSBuLl9nZXRSb3RhdGlvbigpLCByID0gbi5fZ2V0Q2lyY3VtZmVyZW5jZSgpO1xuICAgICAgICB0ID0gTWF0aC5taW4odCwgbyksIGUgPSBNYXRoLm1heChlLCBvICsgcik7XG4gICAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvdGF0aW9uOiB0LFxuICAgICAgY2lyY3VtZmVyZW5jZTogZSAtIHRcbiAgICB9O1xuICB9XG4gIHVwZGF0ZSh0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuY2hhcnQsIHsgY2hhcnRBcmVhOiBzIH0gPSBlLCBuID0gdGhpcy5fY2FjaGVkTWV0YSwgbyA9IG4uZGF0YSwgciA9IHRoaXMuZ2V0TWF4Qm9yZGVyV2lkdGgoKSArIHRoaXMuZ2V0TWF4T2Zmc2V0KG8pICsgdGhpcy5vcHRpb25zLnNwYWNpbmcsIGEgPSBNYXRoLm1heCgoTWF0aC5taW4ocy53aWR0aCwgcy5oZWlnaHQpIC0gcikgLyAyLCAwKSwgbCA9IE1hdGgubWluKHlvKHRoaXMub3B0aW9ucy5jdXRvdXQsIGEpLCAxKSwgYyA9IHRoaXMuX2dldFJpbmdXZWlnaHQodGhpcy5pbmRleCksIHsgY2lyY3VtZmVyZW5jZTogaCwgcm90YXRpb246IGQgfSA9IHRoaXMuX2dldFJvdGF0aW9uRXh0ZW50cygpLCB7IHJhdGlvWDogdSwgcmF0aW9ZOiBmLCBvZmZzZXRYOiBnLCBvZmZzZXRZOiBwIH0gPSBrYShkLCBoLCBsKSwgbSA9IChzLndpZHRoIC0gcikgLyB1LCBiID0gKHMuaGVpZ2h0IC0gcikgLyBmLCB4ID0gTWF0aC5tYXgoTWF0aC5taW4obSwgYikgLyAyLCAwKSwgdiA9IGFuKHRoaXMub3B0aW9ucy5yYWRpdXMsIHgpLCB5ID0gTWF0aC5tYXgodiAqIGwsIDApLCBfID0gKHYgLSB5KSAvIHRoaXMuX2dldFZpc2libGVEYXRhc2V0V2VpZ2h0VG90YWwoKTtcbiAgICB0aGlzLm9mZnNldFggPSBnICogdiwgdGhpcy5vZmZzZXRZID0gcCAqIHYsIG4udG90YWwgPSB0aGlzLmNhbGN1bGF0ZVRvdGFsKCksIHRoaXMub3V0ZXJSYWRpdXMgPSB2IC0gXyAqIHRoaXMuX2dldFJpbmdXZWlnaHRPZmZzZXQodGhpcy5pbmRleCksIHRoaXMuaW5uZXJSYWRpdXMgPSBNYXRoLm1heCh0aGlzLm91dGVyUmFkaXVzIC0gXyAqIGMsIDApLCB0aGlzLnVwZGF0ZUVsZW1lbnRzKG8sIDAsIG8ubGVuZ3RoLCB0KTtcbiAgfVxuICBfY2lyY3VtZmVyZW5jZSh0LCBlKSB7XG4gICAgY29uc3QgcyA9IHRoaXMub3B0aW9ucywgbiA9IHRoaXMuX2NhY2hlZE1ldGEsIG8gPSB0aGlzLl9nZXRDaXJjdW1mZXJlbmNlKCk7XG4gICAgcmV0dXJuIGUgJiYgcy5hbmltYXRpb24uYW5pbWF0ZVJvdGF0ZSB8fCAhdGhpcy5jaGFydC5nZXREYXRhVmlzaWJpbGl0eSh0KSB8fCBuLl9wYXJzZWRbdF0gPT09IG51bGwgfHwgbi5kYXRhW3RdLmhpZGRlbiA/IDAgOiB0aGlzLmNhbGN1bGF0ZUNpcmN1bWZlcmVuY2Uobi5fcGFyc2VkW3RdICogbyAvIEYpO1xuICB9XG4gIHVwZGF0ZUVsZW1lbnRzKHQsIGUsIHMsIG4pIHtcbiAgICBjb25zdCBvID0gbiA9PT0gXCJyZXNldFwiLCByID0gdGhpcy5jaGFydCwgYSA9IHIuY2hhcnRBcmVhLCBjID0gci5vcHRpb25zLmFuaW1hdGlvbiwgaCA9IChhLmxlZnQgKyBhLnJpZ2h0KSAvIDIsIGQgPSAoYS50b3AgKyBhLmJvdHRvbSkgLyAyLCB1ID0gbyAmJiBjLmFuaW1hdGVTY2FsZSwgZiA9IHUgPyAwIDogdGhpcy5pbm5lclJhZGl1cywgZyA9IHUgPyAwIDogdGhpcy5vdXRlclJhZGl1cywgeyBzaGFyZWRPcHRpb25zOiBwLCBpbmNsdWRlT3B0aW9uczogbSB9ID0gdGhpcy5fZ2V0U2hhcmVkT3B0aW9ucyhlLCBuKTtcbiAgICBsZXQgYiA9IHRoaXMuX2dldFJvdGF0aW9uKCksIHg7XG4gICAgZm9yICh4ID0gMDsgeCA8IGU7ICsreClcbiAgICAgIGIgKz0gdGhpcy5fY2lyY3VtZmVyZW5jZSh4LCBvKTtcbiAgICBmb3IgKHggPSBlOyB4IDwgZSArIHM7ICsreCkge1xuICAgICAgY29uc3QgdiA9IHRoaXMuX2NpcmN1bWZlcmVuY2UoeCwgbyksIHkgPSB0W3hdLCBfID0ge1xuICAgICAgICB4OiBoICsgdGhpcy5vZmZzZXRYLFxuICAgICAgICB5OiBkICsgdGhpcy5vZmZzZXRZLFxuICAgICAgICBzdGFydEFuZ2xlOiBiLFxuICAgICAgICBlbmRBbmdsZTogYiArIHYsXG4gICAgICAgIGNpcmN1bWZlcmVuY2U6IHYsXG4gICAgICAgIG91dGVyUmFkaXVzOiBnLFxuICAgICAgICBpbm5lclJhZGl1czogZlxuICAgICAgfTtcbiAgICAgIG0gJiYgKF8ub3B0aW9ucyA9IHAgfHwgdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKHgsIHkuYWN0aXZlID8gXCJhY3RpdmVcIiA6IG4pKSwgYiArPSB2LCB0aGlzLnVwZGF0ZUVsZW1lbnQoeSwgeCwgXywgbik7XG4gICAgfVxuICB9XG4gIGNhbGN1bGF0ZVRvdGFsKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9jYWNoZWRNZXRhLCBlID0gdC5kYXRhO1xuICAgIGxldCBzID0gMCwgbjtcbiAgICBmb3IgKG4gPSAwOyBuIDwgZS5sZW5ndGg7IG4rKykge1xuICAgICAgY29uc3QgbyA9IHQuX3BhcnNlZFtuXTtcbiAgICAgIG8gIT09IG51bGwgJiYgIWlzTmFOKG8pICYmIHRoaXMuY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkobikgJiYgIWVbbl0uaGlkZGVuICYmIChzICs9IE1hdGguYWJzKG8pKTtcbiAgICB9XG4gICAgcmV0dXJuIHM7XG4gIH1cbiAgY2FsY3VsYXRlQ2lyY3VtZmVyZW5jZSh0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuX2NhY2hlZE1ldGEudG90YWw7XG4gICAgcmV0dXJuIGUgPiAwICYmICFpc05hTih0KSA/IEYgKiAoTWF0aC5hYnModCkgLyBlKSA6IDA7XG4gIH1cbiAgZ2V0TGFiZWxBbmRWYWx1ZSh0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuX2NhY2hlZE1ldGEsIHMgPSB0aGlzLmNoYXJ0LCBuID0gcy5kYXRhLmxhYmVscyB8fCBbXSwgbyA9IGRlKGUuX3BhcnNlZFt0XSwgcy5vcHRpb25zLmxvY2FsZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxhYmVsOiBuW3RdIHx8IFwiXCIsXG4gICAgICB2YWx1ZTogb1xuICAgIH07XG4gIH1cbiAgZ2V0TWF4Qm9yZGVyV2lkdGgodCkge1xuICAgIGxldCBlID0gMDtcbiAgICBjb25zdCBzID0gdGhpcy5jaGFydDtcbiAgICBsZXQgbiwgbywgciwgYSwgbDtcbiAgICBpZiAoIXQpIHtcbiAgICAgIGZvciAobiA9IDAsIG8gPSBzLmRhdGEuZGF0YXNldHMubGVuZ3RoOyBuIDwgbzsgKytuKVxuICAgICAgICBpZiAocy5pc0RhdGFzZXRWaXNpYmxlKG4pKSB7XG4gICAgICAgICAgciA9IHMuZ2V0RGF0YXNldE1ldGEobiksIHQgPSByLmRhdGEsIGEgPSByLmNvbnRyb2xsZXI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0KVxuICAgICAgcmV0dXJuIDA7XG4gICAgZm9yIChuID0gMCwgbyA9IHQubGVuZ3RoOyBuIDwgbzsgKytuKVxuICAgICAgbCA9IGEucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhuKSwgbC5ib3JkZXJBbGlnbiAhPT0gXCJpbm5lclwiICYmIChlID0gTWF0aC5tYXgoZSwgbC5ib3JkZXJXaWR0aCB8fCAwLCBsLmhvdmVyQm9yZGVyV2lkdGggfHwgMCkpO1xuICAgIHJldHVybiBlO1xuICB9XG4gIGdldE1heE9mZnNldCh0KSB7XG4gICAgbGV0IGUgPSAwO1xuICAgIGZvciAobGV0IHMgPSAwLCBuID0gdC5sZW5ndGg7IHMgPCBuOyArK3MpIHtcbiAgICAgIGNvbnN0IG8gPSB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMocyk7XG4gICAgICBlID0gTWF0aC5tYXgoZSwgby5vZmZzZXQgfHwgMCwgby5ob3Zlck9mZnNldCB8fCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIGU7XG4gIH1cbiAgX2dldFJpbmdXZWlnaHRPZmZzZXQodCkge1xuICAgIGxldCBlID0gMDtcbiAgICBmb3IgKGxldCBzID0gMDsgcyA8IHQ7ICsrcylcbiAgICAgIHRoaXMuY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShzKSAmJiAoZSArPSB0aGlzLl9nZXRSaW5nV2VpZ2h0KHMpKTtcbiAgICByZXR1cm4gZTtcbiAgfVxuICBfZ2V0UmluZ1dlaWdodCh0KSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KEModGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzW3RdLndlaWdodCwgMSksIDApO1xuICB9XG4gIF9nZXRWaXNpYmxlRGF0YXNldFdlaWdodFRvdGFsKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRSaW5nV2VpZ2h0T2Zmc2V0KHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0cy5sZW5ndGgpIHx8IDE7XG4gIH1cbn1cbkx0LmlkID0gXCJkb3VnaG51dFwiO1xuTHQuZGVmYXVsdHMgPSB7XG4gIGRhdGFzZXRFbGVtZW50VHlwZTogITEsXG4gIGRhdGFFbGVtZW50VHlwZTogXCJhcmNcIixcbiAgYW5pbWF0aW9uOiB7XG4gICAgYW5pbWF0ZVJvdGF0ZTogITAsXG4gICAgYW5pbWF0ZVNjYWxlOiAhMVxuICB9LFxuICBhbmltYXRpb25zOiB7XG4gICAgbnVtYmVyczoge1xuICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgIHByb3BlcnRpZXM6IFtcImNpcmN1bWZlcmVuY2VcIiwgXCJlbmRBbmdsZVwiLCBcImlubmVyUmFkaXVzXCIsIFwib3V0ZXJSYWRpdXNcIiwgXCJzdGFydEFuZ2xlXCIsIFwieFwiLCBcInlcIiwgXCJvZmZzZXRcIiwgXCJib3JkZXJXaWR0aFwiLCBcInNwYWNpbmdcIl1cbiAgICB9XG4gIH0sXG4gIGN1dG91dDogXCI1MCVcIixcbiAgcm90YXRpb246IDAsXG4gIGNpcmN1bWZlcmVuY2U6IDM2MCxcbiAgcmFkaXVzOiBcIjEwMCVcIixcbiAgc3BhY2luZzogMCxcbiAgaW5kZXhBeGlzOiBcInJcIlxufTtcbkx0LmRlc2NyaXB0b3JzID0ge1xuICBfc2NyaXB0YWJsZTogKGkpID0+IGkgIT09IFwic3BhY2luZ1wiLFxuICBfaW5kZXhhYmxlOiAoaSkgPT4gaSAhPT0gXCJzcGFjaW5nXCJcbn07XG5MdC5vdmVycmlkZXMgPSB7XG4gIGFzcGVjdFJhdGlvOiAxLFxuICBwbHVnaW5zOiB7XG4gICAgbGVnZW5kOiB7XG4gICAgICBsYWJlbHM6IHtcbiAgICAgICAgZ2VuZXJhdGVMYWJlbHMoaSkge1xuICAgICAgICAgIGNvbnN0IHQgPSBpLmRhdGE7XG4gICAgICAgICAgaWYgKHQubGFiZWxzLmxlbmd0aCAmJiB0LmRhdGFzZXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgeyBsYWJlbHM6IHsgcG9pbnRTdHlsZTogZSB9IH0gPSBpLmxlZ2VuZC5vcHRpb25zO1xuICAgICAgICAgICAgcmV0dXJuIHQubGFiZWxzLm1hcCgocywgbikgPT4ge1xuICAgICAgICAgICAgICBjb25zdCByID0gaS5nZXREYXRhc2V0TWV0YSgwKS5jb250cm9sbGVyLmdldFN0eWxlKG4pO1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRleHQ6IHMsXG4gICAgICAgICAgICAgICAgZmlsbFN0eWxlOiByLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICAgICAgICBzdHJva2VTdHlsZTogci5ib3JkZXJDb2xvcixcbiAgICAgICAgICAgICAgICBsaW5lV2lkdGg6IHIuYm9yZGVyV2lkdGgsXG4gICAgICAgICAgICAgICAgcG9pbnRTdHlsZTogZSxcbiAgICAgICAgICAgICAgICBoaWRkZW46ICFpLmdldERhdGFWaXNpYmlsaXR5KG4pLFxuICAgICAgICAgICAgICAgIGluZGV4OiBuXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25DbGljayhpLCB0LCBlKSB7XG4gICAgICAgIGUuY2hhcnQudG9nZ2xlRGF0YVZpc2liaWxpdHkodC5pbmRleCksIGUuY2hhcnQudXBkYXRlKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICB0b29sdGlwOiB7XG4gICAgICBjYWxsYmFja3M6IHtcbiAgICAgICAgdGl0bGUoKSB7XG4gICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIH0sXG4gICAgICAgIGxhYmVsKGkpIHtcbiAgICAgICAgICBsZXQgdCA9IGkubGFiZWw7XG4gICAgICAgICAgY29uc3QgZSA9IFwiOiBcIiArIGkuZm9ybWF0dGVkVmFsdWU7XG4gICAgICAgICAgcmV0dXJuIHoodCkgPyAodCA9IHQuc2xpY2UoKSwgdFswXSArPSBlKSA6IHQgKz0gZSwgdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbmNsYXNzIGdlIGV4dGVuZHMgaXQge1xuICBpbml0aWFsaXplKCkge1xuICAgIHRoaXMuZW5hYmxlT3B0aW9uU2hhcmluZyA9ICEwLCB0aGlzLnN1cHBvcnRzRGVjaW1hdGlvbiA9ICEwLCBzdXBlci5pbml0aWFsaXplKCk7XG4gIH1cbiAgdXBkYXRlKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5fY2FjaGVkTWV0YSwgeyBkYXRhc2V0OiBzLCBkYXRhOiBuID0gW10sIF9kYXRhc2V0OiBvIH0gPSBlLCByID0gdGhpcy5jaGFydC5fYW5pbWF0aW9uc0Rpc2FibGVkO1xuICAgIGxldCB7IHN0YXJ0OiBhLCBjb3VudDogbCB9ID0gcG4oZSwgbiwgcik7XG4gICAgdGhpcy5fZHJhd1N0YXJ0ID0gYSwgdGhpcy5fZHJhd0NvdW50ID0gbCwgbW4oZSkgJiYgKGEgPSAwLCBsID0gbi5sZW5ndGgpLCBzLl9jaGFydCA9IHRoaXMuY2hhcnQsIHMuX2RhdGFzZXRJbmRleCA9IHRoaXMuaW5kZXgsIHMuX2RlY2ltYXRlZCA9ICEhby5fZGVjaW1hdGVkLCBzLnBvaW50cyA9IG47XG4gICAgY29uc3QgYyA9IHRoaXMucmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucyh0KTtcbiAgICB0aGlzLm9wdGlvbnMuc2hvd0xpbmUgfHwgKGMuYm9yZGVyV2lkdGggPSAwKSwgYy5zZWdtZW50ID0gdGhpcy5vcHRpb25zLnNlZ21lbnQsIHRoaXMudXBkYXRlRWxlbWVudChzLCB2b2lkIDAsIHtcbiAgICAgIGFuaW1hdGVkOiAhcixcbiAgICAgIG9wdGlvbnM6IGNcbiAgICB9LCB0KSwgdGhpcy51cGRhdGVFbGVtZW50cyhuLCBhLCBsLCB0KTtcbiAgfVxuICB1cGRhdGVFbGVtZW50cyh0LCBlLCBzLCBuKSB7XG4gICAgY29uc3QgbyA9IG4gPT09IFwicmVzZXRcIiwgeyBpU2NhbGU6IHIsIHZTY2FsZTogYSwgX3N0YWNrZWQ6IGwsIF9kYXRhc2V0OiBjIH0gPSB0aGlzLl9jYWNoZWRNZXRhLCB7IHNoYXJlZE9wdGlvbnM6IGgsIGluY2x1ZGVPcHRpb25zOiBkIH0gPSB0aGlzLl9nZXRTaGFyZWRPcHRpb25zKGUsIG4pLCB1ID0gci5heGlzLCBmID0gYS5heGlzLCB7IHNwYW5HYXBzOiBnLCBzZWdtZW50OiBwIH0gPSB0aGlzLm9wdGlvbnMsIG0gPSBCdChnKSA/IGcgOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIGIgPSB0aGlzLmNoYXJ0Ll9hbmltYXRpb25zRGlzYWJsZWQgfHwgbyB8fCBuID09PSBcIm5vbmVcIjtcbiAgICBsZXQgeCA9IGUgPiAwICYmIHRoaXMuZ2V0UGFyc2VkKGUgLSAxKTtcbiAgICBmb3IgKGxldCB2ID0gZTsgdiA8IGUgKyBzOyArK3YpIHtcbiAgICAgIGNvbnN0IHkgPSB0W3ZdLCBfID0gdGhpcy5nZXRQYXJzZWQodiksIE0gPSBiID8geSA6IHt9LCBrID0gVChfW2ZdKSwgUyA9IE1bdV0gPSByLmdldFBpeGVsRm9yVmFsdWUoX1t1XSwgdiksIHcgPSBNW2ZdID0gbyB8fCBrID8gYS5nZXRCYXNlUGl4ZWwoKSA6IGEuZ2V0UGl4ZWxGb3JWYWx1ZShsID8gdGhpcy5hcHBseVN0YWNrKGEsIF8sIGwpIDogX1tmXSwgdik7XG4gICAgICBNLnNraXAgPSBpc05hTihTKSB8fCBpc05hTih3KSB8fCBrLCBNLnN0b3AgPSB2ID4gMCAmJiBNYXRoLmFicyhfW3VdIC0geFt1XSkgPiBtLCBwICYmIChNLnBhcnNlZCA9IF8sIE0ucmF3ID0gYy5kYXRhW3ZdKSwgZCAmJiAoTS5vcHRpb25zID0gaCB8fCB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnModiwgeS5hY3RpdmUgPyBcImFjdGl2ZVwiIDogbikpLCBiIHx8IHRoaXMudXBkYXRlRWxlbWVudCh5LCB2LCBNLCBuKSwgeCA9IF87XG4gICAgfVxuICB9XG4gIGdldE1heE92ZXJmbG93KCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9jYWNoZWRNZXRhLCBlID0gdC5kYXRhc2V0LCBzID0gZS5vcHRpb25zICYmIGUub3B0aW9ucy5ib3JkZXJXaWR0aCB8fCAwLCBuID0gdC5kYXRhIHx8IFtdO1xuICAgIGlmICghbi5sZW5ndGgpXG4gICAgICByZXR1cm4gcztcbiAgICBjb25zdCBvID0gblswXS5zaXplKHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucygwKSksIHIgPSBuW24ubGVuZ3RoIC0gMV0uc2l6ZSh0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMobi5sZW5ndGggLSAxKSk7XG4gICAgcmV0dXJuIE1hdGgubWF4KHMsIG8sIHIpIC8gMjtcbiAgfVxuICBkcmF3KCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIHQuZGF0YXNldC51cGRhdGVDb250cm9sUG9pbnRzKHRoaXMuY2hhcnQuY2hhcnRBcmVhLCB0LmlTY2FsZS5heGlzKSwgc3VwZXIuZHJhdygpO1xuICB9XG59XG5nZS5pZCA9IFwibGluZVwiO1xuZ2UuZGVmYXVsdHMgPSB7XG4gIGRhdGFzZXRFbGVtZW50VHlwZTogXCJsaW5lXCIsXG4gIGRhdGFFbGVtZW50VHlwZTogXCJwb2ludFwiLFxuICBzaG93TGluZTogITAsXG4gIHNwYW5HYXBzOiAhMVxufTtcbmdlLm92ZXJyaWRlcyA9IHtcbiAgc2NhbGVzOiB7XG4gICAgX2luZGV4Xzoge1xuICAgICAgdHlwZTogXCJjYXRlZ29yeVwiXG4gICAgfSxcbiAgICBfdmFsdWVfOiB7XG4gICAgICB0eXBlOiBcImxpbmVhclwiXG4gICAgfVxuICB9XG59O1xuY2xhc3MgcGUgZXh0ZW5kcyBpdCB7XG4gIGNvbnN0cnVjdG9yKHQsIGUpIHtcbiAgICBzdXBlcih0LCBlKSwgdGhpcy5pbm5lclJhZGl1cyA9IHZvaWQgMCwgdGhpcy5vdXRlclJhZGl1cyA9IHZvaWQgMDtcbiAgfVxuICBnZXRMYWJlbEFuZFZhbHVlKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5fY2FjaGVkTWV0YSwgcyA9IHRoaXMuY2hhcnQsIG4gPSBzLmRhdGEubGFiZWxzIHx8IFtdLCBvID0gZGUoZS5fcGFyc2VkW3RdLnIsIHMub3B0aW9ucy5sb2NhbGUpO1xuICAgIHJldHVybiB7XG4gICAgICBsYWJlbDogblt0XSB8fCBcIlwiLFxuICAgICAgdmFsdWU6IG9cbiAgICB9O1xuICB9XG4gIHBhcnNlT2JqZWN0RGF0YSh0LCBlLCBzLCBuKSB7XG4gICAgcmV0dXJuIERuLmJpbmQodGhpcykodCwgZSwgcywgbik7XG4gIH1cbiAgdXBkYXRlKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhO1xuICAgIHRoaXMuX3VwZGF0ZVJhZGl1cygpLCB0aGlzLnVwZGF0ZUVsZW1lbnRzKGUsIDAsIGUubGVuZ3RoLCB0KTtcbiAgfVxuICBnZXRNaW5NYXgoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX2NhY2hlZE1ldGEsIGUgPSB7IG1pbjogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCBtYXg6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSB9O1xuICAgIHJldHVybiB0LmRhdGEuZm9yRWFjaCgocywgbikgPT4ge1xuICAgICAgY29uc3QgbyA9IHRoaXMuZ2V0UGFyc2VkKG4pLnI7XG4gICAgICAhaXNOYU4obykgJiYgdGhpcy5jaGFydC5nZXREYXRhVmlzaWJpbGl0eShuKSAmJiAobyA8IGUubWluICYmIChlLm1pbiA9IG8pLCBvID4gZS5tYXggJiYgKGUubWF4ID0gbykpO1xuICAgIH0pLCBlO1xuICB9XG4gIF91cGRhdGVSYWRpdXMoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuY2hhcnQsIGUgPSB0LmNoYXJ0QXJlYSwgcyA9IHQub3B0aW9ucywgbiA9IE1hdGgubWluKGUucmlnaHQgLSBlLmxlZnQsIGUuYm90dG9tIC0gZS50b3ApLCBvID0gTWF0aC5tYXgobiAvIDIsIDApLCByID0gTWF0aC5tYXgocy5jdXRvdXRQZXJjZW50YWdlID8gbyAvIDEwMCAqIHMuY3V0b3V0UGVyY2VudGFnZSA6IDEsIDApLCBhID0gKG8gLSByKSAvIHQuZ2V0VmlzaWJsZURhdGFzZXRDb3VudCgpO1xuICAgIHRoaXMub3V0ZXJSYWRpdXMgPSBvIC0gYSAqIHRoaXMuaW5kZXgsIHRoaXMuaW5uZXJSYWRpdXMgPSB0aGlzLm91dGVyUmFkaXVzIC0gYTtcbiAgfVxuICB1cGRhdGVFbGVtZW50cyh0LCBlLCBzLCBuKSB7XG4gICAgY29uc3QgbyA9IG4gPT09IFwicmVzZXRcIiwgciA9IHRoaXMuY2hhcnQsIGwgPSByLm9wdGlvbnMuYW5pbWF0aW9uLCBjID0gdGhpcy5fY2FjaGVkTWV0YS5yU2NhbGUsIGggPSBjLnhDZW50ZXIsIGQgPSBjLnlDZW50ZXIsIHUgPSBjLmdldEluZGV4QW5nbGUoMCkgLSAwLjUgKiBCO1xuICAgIGxldCBmID0gdSwgZztcbiAgICBjb25zdCBwID0gMzYwIC8gdGhpcy5jb3VudFZpc2libGVFbGVtZW50cygpO1xuICAgIGZvciAoZyA9IDA7IGcgPCBlOyArK2cpXG4gICAgICBmICs9IHRoaXMuX2NvbXB1dGVBbmdsZShnLCBuLCBwKTtcbiAgICBmb3IgKGcgPSBlOyBnIDwgZSArIHM7IGcrKykge1xuICAgICAgY29uc3QgbSA9IHRbZ107XG4gICAgICBsZXQgYiA9IGYsIHggPSBmICsgdGhpcy5fY29tcHV0ZUFuZ2xlKGcsIG4sIHApLCB2ID0gci5nZXREYXRhVmlzaWJpbGl0eShnKSA/IGMuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUodGhpcy5nZXRQYXJzZWQoZykucikgOiAwO1xuICAgICAgZiA9IHgsIG8gJiYgKGwuYW5pbWF0ZVNjYWxlICYmICh2ID0gMCksIGwuYW5pbWF0ZVJvdGF0ZSAmJiAoYiA9IHggPSB1KSk7XG4gICAgICBjb25zdCB5ID0ge1xuICAgICAgICB4OiBoLFxuICAgICAgICB5OiBkLFxuICAgICAgICBpbm5lclJhZGl1czogMCxcbiAgICAgICAgb3V0ZXJSYWRpdXM6IHYsXG4gICAgICAgIHN0YXJ0QW5nbGU6IGIsXG4gICAgICAgIGVuZEFuZ2xlOiB4LFxuICAgICAgICBvcHRpb25zOiB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoZywgbS5hY3RpdmUgPyBcImFjdGl2ZVwiIDogbilcbiAgICAgIH07XG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQobSwgZywgeSwgbik7XG4gICAgfVxuICB9XG4gIGNvdW50VmlzaWJsZUVsZW1lbnRzKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGxldCBlID0gMDtcbiAgICByZXR1cm4gdC5kYXRhLmZvckVhY2goKHMsIG4pID0+IHtcbiAgICAgICFpc05hTih0aGlzLmdldFBhcnNlZChuKS5yKSAmJiB0aGlzLmNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KG4pICYmIGUrKztcbiAgICB9KSwgZTtcbiAgfVxuICBfY29tcHV0ZUFuZ2xlKHQsIGUsIHMpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFydC5nZXREYXRhVmlzaWJpbGl0eSh0KSA/IG50KHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyh0LCBlKS5hbmdsZSB8fCBzKSA6IDA7XG4gIH1cbn1cbnBlLmlkID0gXCJwb2xhckFyZWFcIjtcbnBlLmRlZmF1bHRzID0ge1xuICBkYXRhRWxlbWVudFR5cGU6IFwiYXJjXCIsXG4gIGFuaW1hdGlvbjoge1xuICAgIGFuaW1hdGVSb3RhdGU6ICEwLFxuICAgIGFuaW1hdGVTY2FsZTogITBcbiAgfSxcbiAgYW5pbWF0aW9uczoge1xuICAgIG51bWJlcnM6IHtcbiAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICBwcm9wZXJ0aWVzOiBbXCJ4XCIsIFwieVwiLCBcInN0YXJ0QW5nbGVcIiwgXCJlbmRBbmdsZVwiLCBcImlubmVyUmFkaXVzXCIsIFwib3V0ZXJSYWRpdXNcIl1cbiAgICB9XG4gIH0sXG4gIGluZGV4QXhpczogXCJyXCIsXG4gIHN0YXJ0QW5nbGU6IDBcbn07XG5wZS5vdmVycmlkZXMgPSB7XG4gIGFzcGVjdFJhdGlvOiAxLFxuICBwbHVnaW5zOiB7XG4gICAgbGVnZW5kOiB7XG4gICAgICBsYWJlbHM6IHtcbiAgICAgICAgZ2VuZXJhdGVMYWJlbHMoaSkge1xuICAgICAgICAgIGNvbnN0IHQgPSBpLmRhdGE7XG4gICAgICAgICAgaWYgKHQubGFiZWxzLmxlbmd0aCAmJiB0LmRhdGFzZXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgeyBsYWJlbHM6IHsgcG9pbnRTdHlsZTogZSB9IH0gPSBpLmxlZ2VuZC5vcHRpb25zO1xuICAgICAgICAgICAgcmV0dXJuIHQubGFiZWxzLm1hcCgocywgbikgPT4ge1xuICAgICAgICAgICAgICBjb25zdCByID0gaS5nZXREYXRhc2V0TWV0YSgwKS5jb250cm9sbGVyLmdldFN0eWxlKG4pO1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRleHQ6IHMsXG4gICAgICAgICAgICAgICAgZmlsbFN0eWxlOiByLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICAgICAgICBzdHJva2VTdHlsZTogci5ib3JkZXJDb2xvcixcbiAgICAgICAgICAgICAgICBsaW5lV2lkdGg6IHIuYm9yZGVyV2lkdGgsXG4gICAgICAgICAgICAgICAgcG9pbnRTdHlsZTogZSxcbiAgICAgICAgICAgICAgICBoaWRkZW46ICFpLmdldERhdGFWaXNpYmlsaXR5KG4pLFxuICAgICAgICAgICAgICAgIGluZGV4OiBuXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25DbGljayhpLCB0LCBlKSB7XG4gICAgICAgIGUuY2hhcnQudG9nZ2xlRGF0YVZpc2liaWxpdHkodC5pbmRleCksIGUuY2hhcnQudXBkYXRlKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICB0b29sdGlwOiB7XG4gICAgICBjYWxsYmFja3M6IHtcbiAgICAgICAgdGl0bGUoKSB7XG4gICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIH0sXG4gICAgICAgIGxhYmVsKGkpIHtcbiAgICAgICAgICByZXR1cm4gaS5jaGFydC5kYXRhLmxhYmVsc1tpLmRhdGFJbmRleF0gKyBcIjogXCIgKyBpLmZvcm1hdHRlZFZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBzY2FsZXM6IHtcbiAgICByOiB7XG4gICAgICB0eXBlOiBcInJhZGlhbExpbmVhclwiLFxuICAgICAgYW5nbGVMaW5lczoge1xuICAgICAgICBkaXNwbGF5OiAhMVxuICAgICAgfSxcbiAgICAgIGJlZ2luQXRaZXJvOiAhMCxcbiAgICAgIGdyaWQ6IHtcbiAgICAgICAgY2lyY3VsYXI6ICEwXG4gICAgICB9LFxuICAgICAgcG9pbnRMYWJlbHM6IHtcbiAgICAgICAgZGlzcGxheTogITFcbiAgICAgIH0sXG4gICAgICBzdGFydEFuZ2xlOiAwXG4gICAgfVxuICB9XG59O1xuY2xhc3MgcWUgZXh0ZW5kcyBMdCB7XG59XG5xZS5pZCA9IFwicGllXCI7XG5xZS5kZWZhdWx0cyA9IHtcbiAgY3V0b3V0OiAwLFxuICByb3RhdGlvbjogMCxcbiAgY2lyY3VtZmVyZW5jZTogMzYwLFxuICByYWRpdXM6IFwiMTAwJVwiXG59O1xuY2xhc3MgbWUgZXh0ZW5kcyBpdCB7XG4gIGdldExhYmVsQW5kVmFsdWUodCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLl9jYWNoZWRNZXRhLnZTY2FsZSwgcyA9IHRoaXMuZ2V0UGFyc2VkKHQpO1xuICAgIHJldHVybiB7XG4gICAgICBsYWJlbDogZS5nZXRMYWJlbHMoKVt0XSxcbiAgICAgIHZhbHVlOiBcIlwiICsgZS5nZXRMYWJlbEZvclZhbHVlKHNbZS5heGlzXSlcbiAgICB9O1xuICB9XG4gIHBhcnNlT2JqZWN0RGF0YSh0LCBlLCBzLCBuKSB7XG4gICAgcmV0dXJuIERuLmJpbmQodGhpcykodCwgZSwgcywgbik7XG4gIH1cbiAgdXBkYXRlKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5fY2FjaGVkTWV0YSwgcyA9IGUuZGF0YXNldCwgbiA9IGUuZGF0YSB8fCBbXSwgbyA9IGUuaVNjYWxlLmdldExhYmVscygpO1xuICAgIGlmIChzLnBvaW50cyA9IG4sIHQgIT09IFwicmVzaXplXCIpIHtcbiAgICAgIGNvbnN0IHIgPSB0aGlzLnJlc29sdmVEYXRhc2V0RWxlbWVudE9wdGlvbnModCk7XG4gICAgICB0aGlzLm9wdGlvbnMuc2hvd0xpbmUgfHwgKHIuYm9yZGVyV2lkdGggPSAwKTtcbiAgICAgIGNvbnN0IGEgPSB7XG4gICAgICAgIF9sb29wOiAhMCxcbiAgICAgICAgX2Z1bGxMb29wOiBvLmxlbmd0aCA9PT0gbi5sZW5ndGgsXG4gICAgICAgIG9wdGlvbnM6IHJcbiAgICAgIH07XG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQocywgdm9pZCAwLCBhLCB0KTtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVFbGVtZW50cyhuLCAwLCBuLmxlbmd0aCwgdCk7XG4gIH1cbiAgdXBkYXRlRWxlbWVudHModCwgZSwgcywgbikge1xuICAgIGNvbnN0IG8gPSB0aGlzLl9jYWNoZWRNZXRhLnJTY2FsZSwgciA9IG4gPT09IFwicmVzZXRcIjtcbiAgICBmb3IgKGxldCBhID0gZTsgYSA8IGUgKyBzOyBhKyspIHtcbiAgICAgIGNvbnN0IGwgPSB0W2FdLCBjID0gdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGEsIGwuYWN0aXZlID8gXCJhY3RpdmVcIiA6IG4pLCBoID0gby5nZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUoYSwgdGhpcy5nZXRQYXJzZWQoYSkuciksIGQgPSByID8gby54Q2VudGVyIDogaC54LCB1ID0gciA/IG8ueUNlbnRlciA6IGgueSwgZiA9IHtcbiAgICAgICAgeDogZCxcbiAgICAgICAgeTogdSxcbiAgICAgICAgYW5nbGU6IGguYW5nbGUsXG4gICAgICAgIHNraXA6IGlzTmFOKGQpIHx8IGlzTmFOKHUpLFxuICAgICAgICBvcHRpb25zOiBjXG4gICAgICB9O1xuICAgICAgdGhpcy51cGRhdGVFbGVtZW50KGwsIGEsIGYsIG4pO1xuICAgIH1cbiAgfVxufVxubWUuaWQgPSBcInJhZGFyXCI7XG5tZS5kZWZhdWx0cyA9IHtcbiAgZGF0YXNldEVsZW1lbnRUeXBlOiBcImxpbmVcIixcbiAgZGF0YUVsZW1lbnRUeXBlOiBcInBvaW50XCIsXG4gIGluZGV4QXhpczogXCJyXCIsXG4gIHNob3dMaW5lOiAhMCxcbiAgZWxlbWVudHM6IHtcbiAgICBsaW5lOiB7XG4gICAgICBmaWxsOiBcInN0YXJ0XCJcbiAgICB9XG4gIH1cbn07XG5tZS5vdmVycmlkZXMgPSB7XG4gIGFzcGVjdFJhdGlvOiAxLFxuICBzY2FsZXM6IHtcbiAgICByOiB7XG4gICAgICB0eXBlOiBcInJhZGlhbExpbmVhclwiXG4gICAgfVxuICB9XG59O1xuY2xhc3Mgc3Qge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnggPSB2b2lkIDAsIHRoaXMueSA9IHZvaWQgMCwgdGhpcy5hY3RpdmUgPSAhMSwgdGhpcy5vcHRpb25zID0gdm9pZCAwLCB0aGlzLiRhbmltYXRpb25zID0gdm9pZCAwO1xuICB9XG4gIHRvb2x0aXBQb3NpdGlvbih0KSB7XG4gICAgY29uc3QgeyB4OiBlLCB5OiBzIH0gPSB0aGlzLmdldFByb3BzKFtcInhcIiwgXCJ5XCJdLCB0KTtcbiAgICByZXR1cm4geyB4OiBlLCB5OiBzIH07XG4gIH1cbiAgaGFzVmFsdWUoKSB7XG4gICAgcmV0dXJuIEJ0KHRoaXMueCkgJiYgQnQodGhpcy55KTtcbiAgfVxuICBnZXRQcm9wcyh0LCBlKSB7XG4gICAgY29uc3QgcyA9IHRoaXMuJGFuaW1hdGlvbnM7XG4gICAgaWYgKCFlIHx8ICFzKVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgY29uc3QgbiA9IHt9O1xuICAgIHJldHVybiB0LmZvckVhY2goKG8pID0+IHtcbiAgICAgIG5bb10gPSBzW29dICYmIHNbb10uYWN0aXZlKCkgPyBzW29dLl90byA6IHRoaXNbb107XG4gICAgfSksIG47XG4gIH1cbn1cbnN0LmRlZmF1bHRzID0ge307XG5zdC5kZWZhdWx0Um91dGVzID0gdm9pZCAwO1xuY29uc3QgVm4gPSB7XG4gIHZhbHVlcyhpKSB7XG4gICAgcmV0dXJuIHooaSkgPyBpIDogXCJcIiArIGk7XG4gIH0sXG4gIG51bWVyaWMoaSwgdCwgZSkge1xuICAgIGlmIChpID09PSAwKVxuICAgICAgcmV0dXJuIFwiMFwiO1xuICAgIGNvbnN0IHMgPSB0aGlzLmNoYXJ0Lm9wdGlvbnMubG9jYWxlO1xuICAgIGxldCBuLCBvID0gaTtcbiAgICBpZiAoZS5sZW5ndGggPiAxKSB7XG4gICAgICBjb25zdCBjID0gTWF0aC5tYXgoTWF0aC5hYnMoZVswXS52YWx1ZSksIE1hdGguYWJzKGVbZS5sZW5ndGggLSAxXS52YWx1ZSkpO1xuICAgICAgKGMgPCAxZS00IHx8IGMgPiAxZTE1KSAmJiAobiA9IFwic2NpZW50aWZpY1wiKSwgbyA9IHdhKGksIGUpO1xuICAgIH1cbiAgICBjb25zdCByID0gdHQoTWF0aC5hYnMobykpLCBhID0gTWF0aC5tYXgoTWF0aC5taW4oLTEgKiBNYXRoLmZsb29yKHIpLCAyMCksIDApLCBsID0geyBub3RhdGlvbjogbiwgbWluaW11bUZyYWN0aW9uRGlnaXRzOiBhLCBtYXhpbXVtRnJhY3Rpb25EaWdpdHM6IGEgfTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihsLCB0aGlzLm9wdGlvbnMudGlja3MuZm9ybWF0KSwgZGUoaSwgcywgbCk7XG4gIH0sXG4gIGxvZ2FyaXRobWljKGksIHQsIGUpIHtcbiAgICBpZiAoaSA9PT0gMClcbiAgICAgIHJldHVybiBcIjBcIjtcbiAgICBjb25zdCBzID0gaSAvIE1hdGgucG93KDEwLCBNYXRoLmZsb29yKHR0KGkpKSk7XG4gICAgcmV0dXJuIHMgPT09IDEgfHwgcyA9PT0gMiB8fCBzID09PSA1ID8gVm4ubnVtZXJpYy5jYWxsKHRoaXMsIGksIHQsIGUpIDogXCJcIjtcbiAgfVxufTtcbmZ1bmN0aW9uIHdhKGksIHQpIHtcbiAgbGV0IGUgPSB0Lmxlbmd0aCA+IDMgPyB0WzJdLnZhbHVlIC0gdFsxXS52YWx1ZSA6IHRbMV0udmFsdWUgLSB0WzBdLnZhbHVlO1xuICByZXR1cm4gTWF0aC5hYnMoZSkgPj0gMSAmJiBpICE9PSBNYXRoLmZsb29yKGkpICYmIChlID0gaSAtIE1hdGguZmxvb3IoaSkpLCBlO1xufVxudmFyIGJlID0geyBmb3JtYXR0ZXJzOiBWbiB9O1xuTy5zZXQoXCJzY2FsZVwiLCB7XG4gIGRpc3BsYXk6ICEwLFxuICBvZmZzZXQ6ICExLFxuICByZXZlcnNlOiAhMSxcbiAgYmVnaW5BdFplcm86ICExLFxuICBib3VuZHM6IFwidGlja3NcIixcbiAgZ3JhY2U6IDAsXG4gIGdyaWQ6IHtcbiAgICBkaXNwbGF5OiAhMCxcbiAgICBsaW5lV2lkdGg6IDEsXG4gICAgZHJhd0JvcmRlcjogITAsXG4gICAgZHJhd09uQ2hhcnRBcmVhOiAhMCxcbiAgICBkcmF3VGlja3M6ICEwLFxuICAgIHRpY2tMZW5ndGg6IDgsXG4gICAgdGlja1dpZHRoOiAoaSwgdCkgPT4gdC5saW5lV2lkdGgsXG4gICAgdGlja0NvbG9yOiAoaSwgdCkgPT4gdC5jb2xvcixcbiAgICBvZmZzZXQ6ICExLFxuICAgIGJvcmRlckRhc2g6IFtdLFxuICAgIGJvcmRlckRhc2hPZmZzZXQ6IDAsXG4gICAgYm9yZGVyV2lkdGg6IDFcbiAgfSxcbiAgdGl0bGU6IHtcbiAgICBkaXNwbGF5OiAhMSxcbiAgICB0ZXh0OiBcIlwiLFxuICAgIHBhZGRpbmc6IHtcbiAgICAgIHRvcDogNCxcbiAgICAgIGJvdHRvbTogNFxuICAgIH1cbiAgfSxcbiAgdGlja3M6IHtcbiAgICBtaW5Sb3RhdGlvbjogMCxcbiAgICBtYXhSb3RhdGlvbjogNTAsXG4gICAgbWlycm9yOiAhMSxcbiAgICB0ZXh0U3Ryb2tlV2lkdGg6IDAsXG4gICAgdGV4dFN0cm9rZUNvbG9yOiBcIlwiLFxuICAgIHBhZGRpbmc6IDMsXG4gICAgZGlzcGxheTogITAsXG4gICAgYXV0b1NraXA6ICEwLFxuICAgIGF1dG9Ta2lwUGFkZGluZzogMyxcbiAgICBsYWJlbE9mZnNldDogMCxcbiAgICBjYWxsYmFjazogYmUuZm9ybWF0dGVycy52YWx1ZXMsXG4gICAgbWlub3I6IHt9LFxuICAgIG1ham9yOiB7fSxcbiAgICBhbGlnbjogXCJjZW50ZXJcIixcbiAgICBjcm9zc0FsaWduOiBcIm5lYXJcIixcbiAgICBzaG93TGFiZWxCYWNrZHJvcDogITEsXG4gICAgYmFja2Ryb3BDb2xvcjogXCJyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNzUpXCIsXG4gICAgYmFja2Ryb3BQYWRkaW5nOiAyXG4gIH1cbn0pO1xuTy5yb3V0ZShcInNjYWxlLnRpY2tzXCIsIFwiY29sb3JcIiwgXCJcIiwgXCJjb2xvclwiKTtcbk8ucm91dGUoXCJzY2FsZS5ncmlkXCIsIFwiY29sb3JcIiwgXCJcIiwgXCJib3JkZXJDb2xvclwiKTtcbk8ucm91dGUoXCJzY2FsZS5ncmlkXCIsIFwiYm9yZGVyQ29sb3JcIiwgXCJcIiwgXCJib3JkZXJDb2xvclwiKTtcbk8ucm91dGUoXCJzY2FsZS50aXRsZVwiLCBcImNvbG9yXCIsIFwiXCIsIFwiY29sb3JcIik7XG5PLmRlc2NyaWJlKFwic2NhbGVcIiwge1xuICBfZmFsbGJhY2s6ICExLFxuICBfc2NyaXB0YWJsZTogKGkpID0+ICFpLnN0YXJ0c1dpdGgoXCJiZWZvcmVcIikgJiYgIWkuc3RhcnRzV2l0aChcImFmdGVyXCIpICYmIGkgIT09IFwiY2FsbGJhY2tcIiAmJiBpICE9PSBcInBhcnNlclwiLFxuICBfaW5kZXhhYmxlOiAoaSkgPT4gaSAhPT0gXCJib3JkZXJEYXNoXCIgJiYgaSAhPT0gXCJ0aWNrQm9yZGVyRGFzaFwiXG59KTtcbk8uZGVzY3JpYmUoXCJzY2FsZXNcIiwge1xuICBfZmFsbGJhY2s6IFwic2NhbGVcIlxufSk7XG5PLmRlc2NyaWJlKFwic2NhbGUudGlja3NcIiwge1xuICBfc2NyaXB0YWJsZTogKGkpID0+IGkgIT09IFwiYmFja2Ryb3BQYWRkaW5nXCIgJiYgaSAhPT0gXCJjYWxsYmFja1wiLFxuICBfaW5kZXhhYmxlOiAoaSkgPT4gaSAhPT0gXCJiYWNrZHJvcFBhZGRpbmdcIlxufSk7XG5mdW5jdGlvbiBTYShpLCB0KSB7XG4gIGNvbnN0IGUgPSBpLm9wdGlvbnMudGlja3MsIHMgPSBlLm1heFRpY2tzTGltaXQgfHwgUGEoaSksIG4gPSBlLm1ham9yLmVuYWJsZWQgPyBEYSh0KSA6IFtdLCBvID0gbi5sZW5ndGgsIHIgPSBuWzBdLCBhID0gbltvIC0gMV0sIGwgPSBbXTtcbiAgaWYgKG8gPiBzKVxuICAgIHJldHVybiBPYSh0LCBsLCBuLCBvIC8gcyksIGw7XG4gIGNvbnN0IGMgPSBDYShuLCB0LCBzKTtcbiAgaWYgKG8gPiAwKSB7XG4gICAgbGV0IGgsIGQ7XG4gICAgY29uc3QgdSA9IG8gPiAxID8gTWF0aC5yb3VuZCgoYSAtIHIpIC8gKG8gLSAxKSkgOiBudWxsO1xuICAgIGZvciAoT2UodCwgbCwgYywgVCh1KSA/IDAgOiByIC0gdSwgciksIGggPSAwLCBkID0gbyAtIDE7IGggPCBkOyBoKyspXG4gICAgICBPZSh0LCBsLCBjLCBuW2hdLCBuW2ggKyAxXSk7XG4gICAgcmV0dXJuIE9lKHQsIGwsIGMsIGEsIFQodSkgPyB0Lmxlbmd0aCA6IGEgKyB1KSwgbDtcbiAgfVxuICByZXR1cm4gT2UodCwgbCwgYyksIGw7XG59XG5mdW5jdGlvbiBQYShpKSB7XG4gIGNvbnN0IHQgPSBpLm9wdGlvbnMub2Zmc2V0LCBlID0gaS5fdGlja1NpemUoKSwgcyA9IGkuX2xlbmd0aCAvIGUgKyAodCA/IDAgOiAxKSwgbiA9IGkuX21heExlbmd0aCAvIGU7XG4gIHJldHVybiBNYXRoLmZsb29yKE1hdGgubWluKHMsIG4pKTtcbn1cbmZ1bmN0aW9uIENhKGksIHQsIGUpIHtcbiAgY29uc3QgcyA9IEFhKGkpLCBuID0gdC5sZW5ndGggLyBlO1xuICBpZiAoIXMpXG4gICAgcmV0dXJuIE1hdGgubWF4KG4sIDEpO1xuICBjb25zdCBvID0gRG8ocyk7XG4gIGZvciAobGV0IHIgPSAwLCBhID0gby5sZW5ndGggLSAxOyByIDwgYTsgcisrKSB7XG4gICAgY29uc3QgbCA9IG9bcl07XG4gICAgaWYgKGwgPiBuKVxuICAgICAgcmV0dXJuIGw7XG4gIH1cbiAgcmV0dXJuIE1hdGgubWF4KG4sIDEpO1xufVxuZnVuY3Rpb24gRGEoaSkge1xuICBjb25zdCB0ID0gW107XG4gIGxldCBlLCBzO1xuICBmb3IgKGUgPSAwLCBzID0gaS5sZW5ndGg7IGUgPCBzOyBlKyspXG4gICAgaVtlXS5tYWpvciAmJiB0LnB1c2goZSk7XG4gIHJldHVybiB0O1xufVxuZnVuY3Rpb24gT2EoaSwgdCwgZSwgcykge1xuICBsZXQgbiA9IDAsIG8gPSBlWzBdLCByO1xuICBmb3IgKHMgPSBNYXRoLmNlaWwocyksIHIgPSAwOyByIDwgaS5sZW5ndGg7IHIrKylcbiAgICByID09PSBvICYmICh0LnB1c2goaVtyXSksIG4rKywgbyA9IGVbbiAqIHNdKTtcbn1cbmZ1bmN0aW9uIE9lKGksIHQsIGUsIHMsIG4pIHtcbiAgY29uc3QgbyA9IEMocywgMCksIHIgPSBNYXRoLm1pbihDKG4sIGkubGVuZ3RoKSwgaS5sZW5ndGgpO1xuICBsZXQgYSA9IDAsIGwsIGMsIGg7XG4gIGZvciAoZSA9IE1hdGguY2VpbChlKSwgbiAmJiAobCA9IG4gLSBzLCBlID0gbCAvIE1hdGguZmxvb3IobCAvIGUpKSwgaCA9IG87IGggPCAwOyApXG4gICAgYSsrLCBoID0gTWF0aC5yb3VuZChvICsgYSAqIGUpO1xuICBmb3IgKGMgPSBNYXRoLm1heChvLCAwKTsgYyA8IHI7IGMrKylcbiAgICBjID09PSBoICYmICh0LnB1c2goaVtjXSksIGErKywgaCA9IE1hdGgucm91bmQobyArIGEgKiBlKSk7XG59XG5mdW5jdGlvbiBBYShpKSB7XG4gIGNvbnN0IHQgPSBpLmxlbmd0aDtcbiAgbGV0IGUsIHM7XG4gIGlmICh0IDwgMilcbiAgICByZXR1cm4gITE7XG4gIGZvciAocyA9IGlbMF0sIGUgPSAxOyBlIDwgdDsgKytlKVxuICAgIGlmIChpW2VdIC0gaVtlIC0gMV0gIT09IHMpXG4gICAgICByZXR1cm4gITE7XG4gIHJldHVybiBzO1xufVxuY29uc3QgVGEgPSAoaSkgPT4gaSA9PT0gXCJsZWZ0XCIgPyBcInJpZ2h0XCIgOiBpID09PSBcInJpZ2h0XCIgPyBcImxlZnRcIiA6IGksIHdzID0gKGksIHQsIGUpID0+IHQgPT09IFwidG9wXCIgfHwgdCA9PT0gXCJsZWZ0XCIgPyBpW3RdICsgZSA6IGlbdF0gLSBlO1xuZnVuY3Rpb24gU3MoaSwgdCkge1xuICBjb25zdCBlID0gW10sIHMgPSBpLmxlbmd0aCAvIHQsIG4gPSBpLmxlbmd0aDtcbiAgbGV0IG8gPSAwO1xuICBmb3IgKDsgbyA8IG47IG8gKz0gcylcbiAgICBlLnB1c2goaVtNYXRoLmZsb29yKG8pXSk7XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gTGEoaSwgdCwgZSkge1xuICBjb25zdCBzID0gaS50aWNrcy5sZW5ndGgsIG4gPSBNYXRoLm1pbih0LCBzIC0gMSksIG8gPSBpLl9zdGFydFBpeGVsLCByID0gaS5fZW5kUGl4ZWwsIGEgPSAxZS02O1xuICBsZXQgbCA9IGkuZ2V0UGl4ZWxGb3JUaWNrKG4pLCBjO1xuICBpZiAoIShlICYmIChzID09PSAxID8gYyA9IE1hdGgubWF4KGwgLSBvLCByIC0gbCkgOiB0ID09PSAwID8gYyA9IChpLmdldFBpeGVsRm9yVGljaygxKSAtIGwpIC8gMiA6IGMgPSAobCAtIGkuZ2V0UGl4ZWxGb3JUaWNrKG4gLSAxKSkgLyAyLCBsICs9IG4gPCB0ID8gYyA6IC1jLCBsIDwgbyAtIGEgfHwgbCA+IHIgKyBhKSkpXG4gICAgcmV0dXJuIGw7XG59XG5mdW5jdGlvbiBSYShpLCB0KSB7XG4gIEUoaSwgKGUpID0+IHtcbiAgICBjb25zdCBzID0gZS5nYywgbiA9IHMubGVuZ3RoIC8gMjtcbiAgICBsZXQgbztcbiAgICBpZiAobiA+IHQpIHtcbiAgICAgIGZvciAobyA9IDA7IG8gPCBuOyArK28pXG4gICAgICAgIGRlbGV0ZSBlLmRhdGFbc1tvXV07XG4gICAgICBzLnNwbGljZSgwLCBuKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gWHQoaSkge1xuICByZXR1cm4gaS5kcmF3VGlja3MgPyBpLnRpY2tMZW5ndGggOiAwO1xufVxuZnVuY3Rpb24gUHMoaSwgdCkge1xuICBpZiAoIWkuZGlzcGxheSlcbiAgICByZXR1cm4gMDtcbiAgY29uc3QgZSA9ICQoaS5mb250LCB0KSwgcyA9IEsoaS5wYWRkaW5nKTtcbiAgcmV0dXJuICh6KGkudGV4dCkgPyBpLnRleHQubGVuZ3RoIDogMSkgKiBlLmxpbmVIZWlnaHQgKyBzLmhlaWdodDtcbn1cbmZ1bmN0aW9uIEVhKGksIHQpIHtcbiAgcmV0dXJuIHZ0KGksIHtcbiAgICBzY2FsZTogdCxcbiAgICB0eXBlOiBcInNjYWxlXCJcbiAgfSk7XG59XG5mdW5jdGlvbiBGYShpLCB0LCBlKSB7XG4gIHJldHVybiB2dChpLCB7XG4gICAgdGljazogZSxcbiAgICBpbmRleDogdCxcbiAgICB0eXBlOiBcInRpY2tcIlxuICB9KTtcbn1cbmZ1bmN0aW9uIElhKGksIHQsIGUpIHtcbiAgbGV0IHMgPSBMaShpKTtcbiAgcmV0dXJuIChlICYmIHQgIT09IFwicmlnaHRcIiB8fCAhZSAmJiB0ID09PSBcInJpZ2h0XCIpICYmIChzID0gVGEocykpLCBzO1xufVxuZnVuY3Rpb24gemEoaSwgdCwgZSwgcykge1xuICBjb25zdCB7IHRvcDogbiwgbGVmdDogbywgYm90dG9tOiByLCByaWdodDogYSwgY2hhcnQ6IGwgfSA9IGksIHsgY2hhcnRBcmVhOiBjLCBzY2FsZXM6IGggfSA9IGw7XG4gIGxldCBkID0gMCwgdSwgZiwgZztcbiAgY29uc3QgcCA9IHIgLSBuLCBtID0gYSAtIG87XG4gIGlmIChpLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgaWYgKGYgPSBVKHMsIG8sIGEpLCBEKGUpKSB7XG4gICAgICBjb25zdCBiID0gT2JqZWN0LmtleXMoZSlbMF0sIHggPSBlW2JdO1xuICAgICAgZyA9IGhbYl0uZ2V0UGl4ZWxGb3JWYWx1ZSh4KSArIHAgLSB0O1xuICAgIH0gZWxzZVxuICAgICAgZSA9PT0gXCJjZW50ZXJcIiA/IGcgPSAoYy5ib3R0b20gKyBjLnRvcCkgLyAyICsgcCAtIHQgOiBnID0gd3MoaSwgZSwgdCk7XG4gICAgdSA9IGEgLSBvO1xuICB9IGVsc2Uge1xuICAgIGlmIChEKGUpKSB7XG4gICAgICBjb25zdCBiID0gT2JqZWN0LmtleXMoZSlbMF0sIHggPSBlW2JdO1xuICAgICAgZiA9IGhbYl0uZ2V0UGl4ZWxGb3JWYWx1ZSh4KSAtIG0gKyB0O1xuICAgIH0gZWxzZVxuICAgICAgZSA9PT0gXCJjZW50ZXJcIiA/IGYgPSAoYy5sZWZ0ICsgYy5yaWdodCkgLyAyIC0gbSArIHQgOiBmID0gd3MoaSwgZSwgdCk7XG4gICAgZyA9IFUocywgciwgbiksIGQgPSBlID09PSBcImxlZnRcIiA/IC1WIDogVjtcbiAgfVxuICByZXR1cm4geyB0aXRsZVg6IGYsIHRpdGxlWTogZywgbWF4V2lkdGg6IHUsIHJvdGF0aW9uOiBkIH07XG59XG5jbGFzcyBNdCBleHRlbmRzIHN0IHtcbiAgY29uc3RydWN0b3IodCkge1xuICAgIHN1cGVyKCksIHRoaXMuaWQgPSB0LmlkLCB0aGlzLnR5cGUgPSB0LnR5cGUsIHRoaXMub3B0aW9ucyA9IHZvaWQgMCwgdGhpcy5jdHggPSB0LmN0eCwgdGhpcy5jaGFydCA9IHQuY2hhcnQsIHRoaXMudG9wID0gdm9pZCAwLCB0aGlzLmJvdHRvbSA9IHZvaWQgMCwgdGhpcy5sZWZ0ID0gdm9pZCAwLCB0aGlzLnJpZ2h0ID0gdm9pZCAwLCB0aGlzLndpZHRoID0gdm9pZCAwLCB0aGlzLmhlaWdodCA9IHZvaWQgMCwgdGhpcy5fbWFyZ2lucyA9IHtcbiAgICAgIGxlZnQ6IDAsXG4gICAgICByaWdodDogMCxcbiAgICAgIHRvcDogMCxcbiAgICAgIGJvdHRvbTogMFxuICAgIH0sIHRoaXMubWF4V2lkdGggPSB2b2lkIDAsIHRoaXMubWF4SGVpZ2h0ID0gdm9pZCAwLCB0aGlzLnBhZGRpbmdUb3AgPSB2b2lkIDAsIHRoaXMucGFkZGluZ0JvdHRvbSA9IHZvaWQgMCwgdGhpcy5wYWRkaW5nTGVmdCA9IHZvaWQgMCwgdGhpcy5wYWRkaW5nUmlnaHQgPSB2b2lkIDAsIHRoaXMuYXhpcyA9IHZvaWQgMCwgdGhpcy5sYWJlbFJvdGF0aW9uID0gdm9pZCAwLCB0aGlzLm1pbiA9IHZvaWQgMCwgdGhpcy5tYXggPSB2b2lkIDAsIHRoaXMuX3JhbmdlID0gdm9pZCAwLCB0aGlzLnRpY2tzID0gW10sIHRoaXMuX2dyaWRMaW5lSXRlbXMgPSBudWxsLCB0aGlzLl9sYWJlbEl0ZW1zID0gbnVsbCwgdGhpcy5fbGFiZWxTaXplcyA9IG51bGwsIHRoaXMuX2xlbmd0aCA9IDAsIHRoaXMuX21heExlbmd0aCA9IDAsIHRoaXMuX2xvbmdlc3RUZXh0Q2FjaGUgPSB7fSwgdGhpcy5fc3RhcnRQaXhlbCA9IHZvaWQgMCwgdGhpcy5fZW5kUGl4ZWwgPSB2b2lkIDAsIHRoaXMuX3JldmVyc2VQaXhlbHMgPSAhMSwgdGhpcy5fdXNlck1heCA9IHZvaWQgMCwgdGhpcy5fdXNlck1pbiA9IHZvaWQgMCwgdGhpcy5fc3VnZ2VzdGVkTWF4ID0gdm9pZCAwLCB0aGlzLl9zdWdnZXN0ZWRNaW4gPSB2b2lkIDAsIHRoaXMuX3RpY2tzTGVuZ3RoID0gMCwgdGhpcy5fYm9yZGVyVmFsdWUgPSAwLCB0aGlzLl9jYWNoZSA9IHt9LCB0aGlzLl9kYXRhTGltaXRzQ2FjaGVkID0gITEsIHRoaXMuJGNvbnRleHQgPSB2b2lkIDA7XG4gIH1cbiAgaW5pdCh0KSB7XG4gICAgdGhpcy5vcHRpb25zID0gdC5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpKSwgdGhpcy5heGlzID0gdC5heGlzLCB0aGlzLl91c2VyTWluID0gdGhpcy5wYXJzZSh0Lm1pbiksIHRoaXMuX3VzZXJNYXggPSB0aGlzLnBhcnNlKHQubWF4KSwgdGhpcy5fc3VnZ2VzdGVkTWluID0gdGhpcy5wYXJzZSh0LnN1Z2dlc3RlZE1pbiksIHRoaXMuX3N1Z2dlc3RlZE1heCA9IHRoaXMucGFyc2UodC5zdWdnZXN0ZWRNYXgpO1xuICB9XG4gIHBhcnNlKHQsIGUpIHtcbiAgICByZXR1cm4gdDtcbiAgfVxuICBnZXRVc2VyQm91bmRzKCkge1xuICAgIGxldCB7IF91c2VyTWluOiB0LCBfdXNlck1heDogZSwgX3N1Z2dlc3RlZE1pbjogcywgX3N1Z2dlc3RlZE1heDogbiB9ID0gdGhpcztcbiAgICByZXR1cm4gdCA9IFEodCwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKSwgZSA9IFEoZSwgTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKSwgcyA9IFEocywgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKSwgbiA9IFEobiwgTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKSwge1xuICAgICAgbWluOiBRKHQsIHMpLFxuICAgICAgbWF4OiBRKGUsIG4pLFxuICAgICAgbWluRGVmaW5lZDogTih0KSxcbiAgICAgIG1heERlZmluZWQ6IE4oZSlcbiAgICB9O1xuICB9XG4gIGdldE1pbk1heCh0KSB7XG4gICAgbGV0IHsgbWluOiBlLCBtYXg6IHMsIG1pbkRlZmluZWQ6IG4sIG1heERlZmluZWQ6IG8gfSA9IHRoaXMuZ2V0VXNlckJvdW5kcygpLCByO1xuICAgIGlmIChuICYmIG8pXG4gICAgICByZXR1cm4geyBtaW46IGUsIG1heDogcyB9O1xuICAgIGNvbnN0IGEgPSB0aGlzLmdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKCk7XG4gICAgZm9yIChsZXQgbCA9IDAsIGMgPSBhLmxlbmd0aDsgbCA8IGM7ICsrbClcbiAgICAgIHIgPSBhW2xdLmNvbnRyb2xsZXIuZ2V0TWluTWF4KHRoaXMsIHQpLCBuIHx8IChlID0gTWF0aC5taW4oZSwgci5taW4pKSwgbyB8fCAocyA9IE1hdGgubWF4KHMsIHIubWF4KSk7XG4gICAgcmV0dXJuIGUgPSBvICYmIGUgPiBzID8gcyA6IGUsIHMgPSBuICYmIGUgPiBzID8gZSA6IHMsIHtcbiAgICAgIG1pbjogUShlLCBRKHMsIGUpKSxcbiAgICAgIG1heDogUShzLCBRKGUsIHMpKVxuICAgIH07XG4gIH1cbiAgZ2V0UGFkZGluZygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGVmdDogdGhpcy5wYWRkaW5nTGVmdCB8fCAwLFxuICAgICAgdG9wOiB0aGlzLnBhZGRpbmdUb3AgfHwgMCxcbiAgICAgIHJpZ2h0OiB0aGlzLnBhZGRpbmdSaWdodCB8fCAwLFxuICAgICAgYm90dG9tOiB0aGlzLnBhZGRpbmdCb3R0b20gfHwgMFxuICAgIH07XG4gIH1cbiAgZ2V0VGlja3MoKSB7XG4gICAgcmV0dXJuIHRoaXMudGlja3M7XG4gIH1cbiAgZ2V0TGFiZWxzKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmNoYXJ0LmRhdGE7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5sYWJlbHMgfHwgKHRoaXMuaXNIb3Jpem9udGFsKCkgPyB0LnhMYWJlbHMgOiB0LnlMYWJlbHMpIHx8IHQubGFiZWxzIHx8IFtdO1xuICB9XG4gIGJlZm9yZUxheW91dCgpIHtcbiAgICB0aGlzLl9jYWNoZSA9IHt9LCB0aGlzLl9kYXRhTGltaXRzQ2FjaGVkID0gITE7XG4gIH1cbiAgYmVmb3JlVXBkYXRlKCkge1xuICAgIEkodGhpcy5vcHRpb25zLmJlZm9yZVVwZGF0ZSwgW3RoaXNdKTtcbiAgfVxuICB1cGRhdGUodCwgZSwgcykge1xuICAgIGNvbnN0IHsgYmVnaW5BdFplcm86IG4sIGdyYWNlOiBvLCB0aWNrczogciB9ID0gdGhpcy5vcHRpb25zLCBhID0gci5zYW1wbGVTaXplO1xuICAgIHRoaXMuYmVmb3JlVXBkYXRlKCksIHRoaXMubWF4V2lkdGggPSB0LCB0aGlzLm1heEhlaWdodCA9IGUsIHRoaXMuX21hcmdpbnMgPSBzID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICBsZWZ0OiAwLFxuICAgICAgcmlnaHQ6IDAsXG4gICAgICB0b3A6IDAsXG4gICAgICBib3R0b206IDBcbiAgICB9LCBzKSwgdGhpcy50aWNrcyA9IG51bGwsIHRoaXMuX2xhYmVsU2l6ZXMgPSBudWxsLCB0aGlzLl9ncmlkTGluZUl0ZW1zID0gbnVsbCwgdGhpcy5fbGFiZWxJdGVtcyA9IG51bGwsIHRoaXMuYmVmb3JlU2V0RGltZW5zaW9ucygpLCB0aGlzLnNldERpbWVuc2lvbnMoKSwgdGhpcy5hZnRlclNldERpbWVuc2lvbnMoKSwgdGhpcy5fbWF4TGVuZ3RoID0gdGhpcy5pc0hvcml6b250YWwoKSA/IHRoaXMud2lkdGggKyBzLmxlZnQgKyBzLnJpZ2h0IDogdGhpcy5oZWlnaHQgKyBzLnRvcCArIHMuYm90dG9tLCB0aGlzLl9kYXRhTGltaXRzQ2FjaGVkIHx8ICh0aGlzLmJlZm9yZURhdGFMaW1pdHMoKSwgdGhpcy5kZXRlcm1pbmVEYXRhTGltaXRzKCksIHRoaXMuYWZ0ZXJEYXRhTGltaXRzKCksIHRoaXMuX3JhbmdlID0gbXIodGhpcywgbywgbiksIHRoaXMuX2RhdGFMaW1pdHNDYWNoZWQgPSAhMCksIHRoaXMuYmVmb3JlQnVpbGRUaWNrcygpLCB0aGlzLnRpY2tzID0gdGhpcy5idWlsZFRpY2tzKCkgfHwgW10sIHRoaXMuYWZ0ZXJCdWlsZFRpY2tzKCk7XG4gICAgY29uc3QgbCA9IGEgPCB0aGlzLnRpY2tzLmxlbmd0aDtcbiAgICB0aGlzLl9jb252ZXJ0VGlja3NUb0xhYmVscyhsID8gU3ModGhpcy50aWNrcywgYSkgOiB0aGlzLnRpY2tzKSwgdGhpcy5jb25maWd1cmUoKSwgdGhpcy5iZWZvcmVDYWxjdWxhdGVMYWJlbFJvdGF0aW9uKCksIHRoaXMuY2FsY3VsYXRlTGFiZWxSb3RhdGlvbigpLCB0aGlzLmFmdGVyQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbigpLCByLmRpc3BsYXkgJiYgKHIuYXV0b1NraXAgfHwgci5zb3VyY2UgPT09IFwiYXV0b1wiKSAmJiAodGhpcy50aWNrcyA9IFNhKHRoaXMsIHRoaXMudGlja3MpLCB0aGlzLl9sYWJlbFNpemVzID0gbnVsbCwgdGhpcy5hZnRlckF1dG9Ta2lwKCkpLCBsICYmIHRoaXMuX2NvbnZlcnRUaWNrc1RvTGFiZWxzKHRoaXMudGlja3MpLCB0aGlzLmJlZm9yZUZpdCgpLCB0aGlzLmZpdCgpLCB0aGlzLmFmdGVyRml0KCksIHRoaXMuYWZ0ZXJVcGRhdGUoKTtcbiAgfVxuICBjb25maWd1cmUoKSB7XG4gICAgbGV0IHQgPSB0aGlzLm9wdGlvbnMucmV2ZXJzZSwgZSwgcztcbiAgICB0aGlzLmlzSG9yaXpvbnRhbCgpID8gKGUgPSB0aGlzLmxlZnQsIHMgPSB0aGlzLnJpZ2h0KSA6IChlID0gdGhpcy50b3AsIHMgPSB0aGlzLmJvdHRvbSwgdCA9ICF0KSwgdGhpcy5fc3RhcnRQaXhlbCA9IGUsIHRoaXMuX2VuZFBpeGVsID0gcywgdGhpcy5fcmV2ZXJzZVBpeGVscyA9IHQsIHRoaXMuX2xlbmd0aCA9IHMgLSBlLCB0aGlzLl9hbGlnblRvUGl4ZWxzID0gdGhpcy5vcHRpb25zLmFsaWduVG9QaXhlbHM7XG4gIH1cbiAgYWZ0ZXJVcGRhdGUoKSB7XG4gICAgSSh0aGlzLm9wdGlvbnMuYWZ0ZXJVcGRhdGUsIFt0aGlzXSk7XG4gIH1cbiAgYmVmb3JlU2V0RGltZW5zaW9ucygpIHtcbiAgICBJKHRoaXMub3B0aW9ucy5iZWZvcmVTZXREaW1lbnNpb25zLCBbdGhpc10pO1xuICB9XG4gIHNldERpbWVuc2lvbnMoKSB7XG4gICAgdGhpcy5pc0hvcml6b250YWwoKSA/ICh0aGlzLndpZHRoID0gdGhpcy5tYXhXaWR0aCwgdGhpcy5sZWZ0ID0gMCwgdGhpcy5yaWdodCA9IHRoaXMud2lkdGgpIDogKHRoaXMuaGVpZ2h0ID0gdGhpcy5tYXhIZWlnaHQsIHRoaXMudG9wID0gMCwgdGhpcy5ib3R0b20gPSB0aGlzLmhlaWdodCksIHRoaXMucGFkZGluZ0xlZnQgPSAwLCB0aGlzLnBhZGRpbmdUb3AgPSAwLCB0aGlzLnBhZGRpbmdSaWdodCA9IDAsIHRoaXMucGFkZGluZ0JvdHRvbSA9IDA7XG4gIH1cbiAgYWZ0ZXJTZXREaW1lbnNpb25zKCkge1xuICAgIEkodGhpcy5vcHRpb25zLmFmdGVyU2V0RGltZW5zaW9ucywgW3RoaXNdKTtcbiAgfVxuICBfY2FsbEhvb2tzKHQpIHtcbiAgICB0aGlzLmNoYXJ0Lm5vdGlmeVBsdWdpbnModCwgdGhpcy5nZXRDb250ZXh0KCkpLCBJKHRoaXMub3B0aW9uc1t0XSwgW3RoaXNdKTtcbiAgfVxuICBiZWZvcmVEYXRhTGltaXRzKCkge1xuICAgIHRoaXMuX2NhbGxIb29rcyhcImJlZm9yZURhdGFMaW1pdHNcIik7XG4gIH1cbiAgZGV0ZXJtaW5lRGF0YUxpbWl0cygpIHtcbiAgfVxuICBhZnRlckRhdGFMaW1pdHMoKSB7XG4gICAgdGhpcy5fY2FsbEhvb2tzKFwiYWZ0ZXJEYXRhTGltaXRzXCIpO1xuICB9XG4gIGJlZm9yZUJ1aWxkVGlja3MoKSB7XG4gICAgdGhpcy5fY2FsbEhvb2tzKFwiYmVmb3JlQnVpbGRUaWNrc1wiKTtcbiAgfVxuICBidWlsZFRpY2tzKCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBhZnRlckJ1aWxkVGlja3MoKSB7XG4gICAgdGhpcy5fY2FsbEhvb2tzKFwiYWZ0ZXJCdWlsZFRpY2tzXCIpO1xuICB9XG4gIGJlZm9yZVRpY2tUb0xhYmVsQ29udmVyc2lvbigpIHtcbiAgICBJKHRoaXMub3B0aW9ucy5iZWZvcmVUaWNrVG9MYWJlbENvbnZlcnNpb24sIFt0aGlzXSk7XG4gIH1cbiAgZ2VuZXJhdGVUaWNrTGFiZWxzKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5vcHRpb25zLnRpY2tzO1xuICAgIGxldCBzLCBuLCBvO1xuICAgIGZvciAocyA9IDAsIG4gPSB0Lmxlbmd0aDsgcyA8IG47IHMrKylcbiAgICAgIG8gPSB0W3NdLCBvLmxhYmVsID0gSShlLmNhbGxiYWNrLCBbby52YWx1ZSwgcywgdF0sIHRoaXMpO1xuICB9XG4gIGFmdGVyVGlja1RvTGFiZWxDb252ZXJzaW9uKCkge1xuICAgIEkodGhpcy5vcHRpb25zLmFmdGVyVGlja1RvTGFiZWxDb252ZXJzaW9uLCBbdGhpc10pO1xuICB9XG4gIGJlZm9yZUNhbGN1bGF0ZUxhYmVsUm90YXRpb24oKSB7XG4gICAgSSh0aGlzLm9wdGlvbnMuYmVmb3JlQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbiwgW3RoaXNdKTtcbiAgfVxuICBjYWxjdWxhdGVMYWJlbFJvdGF0aW9uKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLm9wdGlvbnMsIGUgPSB0LnRpY2tzLCBzID0gdGhpcy50aWNrcy5sZW5ndGgsIG4gPSBlLm1pblJvdGF0aW9uIHx8IDAsIG8gPSBlLm1heFJvdGF0aW9uO1xuICAgIGxldCByID0gbiwgYSwgbCwgYztcbiAgICBpZiAoIXRoaXMuX2lzVmlzaWJsZSgpIHx8ICFlLmRpc3BsYXkgfHwgbiA+PSBvIHx8IHMgPD0gMSB8fCAhdGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgdGhpcy5sYWJlbFJvdGF0aW9uID0gbjtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaCA9IHRoaXMuX2dldExhYmVsU2l6ZXMoKSwgZCA9IGgud2lkZXN0LndpZHRoLCB1ID0gaC5oaWdoZXN0LmhlaWdodCwgZiA9IFkodGhpcy5jaGFydC53aWR0aCAtIGQsIDAsIHRoaXMubWF4V2lkdGgpO1xuICAgIGEgPSB0Lm9mZnNldCA/IHRoaXMubWF4V2lkdGggLyBzIDogZiAvIChzIC0gMSksIGQgKyA2ID4gYSAmJiAoYSA9IGYgLyAocyAtICh0Lm9mZnNldCA/IDAuNSA6IDEpKSwgbCA9IHRoaXMubWF4SGVpZ2h0IC0gWHQodC5ncmlkKSAtIGUucGFkZGluZyAtIFBzKHQudGl0bGUsIHRoaXMuY2hhcnQub3B0aW9ucy5mb250KSwgYyA9IE1hdGguc3FydChkICogZCArIHUgKiB1KSwgciA9IEFpKE1hdGgubWluKFxuICAgICAgTWF0aC5hc2luKFkoKGguaGlnaGVzdC5oZWlnaHQgKyA2KSAvIGEsIC0xLCAxKSksXG4gICAgICBNYXRoLmFzaW4oWShsIC8gYywgLTEsIDEpKSAtIE1hdGguYXNpbihZKHUgLyBjLCAtMSwgMSkpXG4gICAgKSksIHIgPSBNYXRoLm1heChuLCBNYXRoLm1pbihvLCByKSkpLCB0aGlzLmxhYmVsUm90YXRpb24gPSByO1xuICB9XG4gIGFmdGVyQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbigpIHtcbiAgICBJKHRoaXMub3B0aW9ucy5hZnRlckNhbGN1bGF0ZUxhYmVsUm90YXRpb24sIFt0aGlzXSk7XG4gIH1cbiAgYWZ0ZXJBdXRvU2tpcCgpIHtcbiAgfVxuICBiZWZvcmVGaXQoKSB7XG4gICAgSSh0aGlzLm9wdGlvbnMuYmVmb3JlRml0LCBbdGhpc10pO1xuICB9XG4gIGZpdCgpIHtcbiAgICBjb25zdCB0ID0ge1xuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDBcbiAgICB9LCB7IGNoYXJ0OiBlLCBvcHRpb25zOiB7IHRpY2tzOiBzLCB0aXRsZTogbiwgZ3JpZDogbyB9IH0gPSB0aGlzLCByID0gdGhpcy5faXNWaXNpYmxlKCksIGEgPSB0aGlzLmlzSG9yaXpvbnRhbCgpO1xuICAgIGlmIChyKSB7XG4gICAgICBjb25zdCBsID0gUHMobiwgZS5vcHRpb25zLmZvbnQpO1xuICAgICAgaWYgKGEgPyAodC53aWR0aCA9IHRoaXMubWF4V2lkdGgsIHQuaGVpZ2h0ID0gWHQobykgKyBsKSA6ICh0LmhlaWdodCA9IHRoaXMubWF4SGVpZ2h0LCB0LndpZHRoID0gWHQobykgKyBsKSwgcy5kaXNwbGF5ICYmIHRoaXMudGlja3MubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHsgZmlyc3Q6IGMsIGxhc3Q6IGgsIHdpZGVzdDogZCwgaGlnaGVzdDogdSB9ID0gdGhpcy5fZ2V0TGFiZWxTaXplcygpLCBmID0gcy5wYWRkaW5nICogMiwgZyA9IG50KHRoaXMubGFiZWxSb3RhdGlvbiksIHAgPSBNYXRoLmNvcyhnKSwgbSA9IE1hdGguc2luKGcpO1xuICAgICAgICBpZiAoYSkge1xuICAgICAgICAgIGNvbnN0IGIgPSBzLm1pcnJvciA/IDAgOiBtICogZC53aWR0aCArIHAgKiB1LmhlaWdodDtcbiAgICAgICAgICB0LmhlaWdodCA9IE1hdGgubWluKHRoaXMubWF4SGVpZ2h0LCB0LmhlaWdodCArIGIgKyBmKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBiID0gcy5taXJyb3IgPyAwIDogcCAqIGQud2lkdGggKyBtICogdS5oZWlnaHQ7XG4gICAgICAgICAgdC53aWR0aCA9IE1hdGgubWluKHRoaXMubWF4V2lkdGgsIHQud2lkdGggKyBiICsgZik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2FsY3VsYXRlUGFkZGluZyhjLCBoLCBtLCBwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5faGFuZGxlTWFyZ2lucygpLCBhID8gKHRoaXMud2lkdGggPSB0aGlzLl9sZW5ndGggPSBlLndpZHRoIC0gdGhpcy5fbWFyZ2lucy5sZWZ0IC0gdGhpcy5fbWFyZ2lucy5yaWdodCwgdGhpcy5oZWlnaHQgPSB0LmhlaWdodCkgOiAodGhpcy53aWR0aCA9IHQud2lkdGgsIHRoaXMuaGVpZ2h0ID0gdGhpcy5fbGVuZ3RoID0gZS5oZWlnaHQgLSB0aGlzLl9tYXJnaW5zLnRvcCAtIHRoaXMuX21hcmdpbnMuYm90dG9tKTtcbiAgfVxuICBfY2FsY3VsYXRlUGFkZGluZyh0LCBlLCBzLCBuKSB7XG4gICAgY29uc3QgeyB0aWNrczogeyBhbGlnbjogbywgcGFkZGluZzogciB9LCBwb3NpdGlvbjogYSB9ID0gdGhpcy5vcHRpb25zLCBsID0gdGhpcy5sYWJlbFJvdGF0aW9uICE9PSAwLCBjID0gYSAhPT0gXCJ0b3BcIiAmJiB0aGlzLmF4aXMgPT09IFwieFwiO1xuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICBjb25zdCBoID0gdGhpcy5nZXRQaXhlbEZvclRpY2soMCkgLSB0aGlzLmxlZnQsIGQgPSB0aGlzLnJpZ2h0IC0gdGhpcy5nZXRQaXhlbEZvclRpY2sodGhpcy50aWNrcy5sZW5ndGggLSAxKTtcbiAgICAgIGxldCB1ID0gMCwgZiA9IDA7XG4gICAgICBsID8gYyA/ICh1ID0gbiAqIHQud2lkdGgsIGYgPSBzICogZS5oZWlnaHQpIDogKHUgPSBzICogdC5oZWlnaHQsIGYgPSBuICogZS53aWR0aCkgOiBvID09PSBcInN0YXJ0XCIgPyBmID0gZS53aWR0aCA6IG8gPT09IFwiZW5kXCIgPyB1ID0gdC53aWR0aCA6IG8gIT09IFwiaW5uZXJcIiAmJiAodSA9IHQud2lkdGggLyAyLCBmID0gZS53aWR0aCAvIDIpLCB0aGlzLnBhZGRpbmdMZWZ0ID0gTWF0aC5tYXgoKHUgLSBoICsgcikgKiB0aGlzLndpZHRoIC8gKHRoaXMud2lkdGggLSBoKSwgMCksIHRoaXMucGFkZGluZ1JpZ2h0ID0gTWF0aC5tYXgoKGYgLSBkICsgcikgKiB0aGlzLndpZHRoIC8gKHRoaXMud2lkdGggLSBkKSwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBoID0gZS5oZWlnaHQgLyAyLCBkID0gdC5oZWlnaHQgLyAyO1xuICAgICAgbyA9PT0gXCJzdGFydFwiID8gKGggPSAwLCBkID0gdC5oZWlnaHQpIDogbyA9PT0gXCJlbmRcIiAmJiAoaCA9IGUuaGVpZ2h0LCBkID0gMCksIHRoaXMucGFkZGluZ1RvcCA9IGggKyByLCB0aGlzLnBhZGRpbmdCb3R0b20gPSBkICsgcjtcbiAgICB9XG4gIH1cbiAgX2hhbmRsZU1hcmdpbnMoKSB7XG4gICAgdGhpcy5fbWFyZ2lucyAmJiAodGhpcy5fbWFyZ2lucy5sZWZ0ID0gTWF0aC5tYXgodGhpcy5wYWRkaW5nTGVmdCwgdGhpcy5fbWFyZ2lucy5sZWZ0KSwgdGhpcy5fbWFyZ2lucy50b3AgPSBNYXRoLm1heCh0aGlzLnBhZGRpbmdUb3AsIHRoaXMuX21hcmdpbnMudG9wKSwgdGhpcy5fbWFyZ2lucy5yaWdodCA9IE1hdGgubWF4KHRoaXMucGFkZGluZ1JpZ2h0LCB0aGlzLl9tYXJnaW5zLnJpZ2h0KSwgdGhpcy5fbWFyZ2lucy5ib3R0b20gPSBNYXRoLm1heCh0aGlzLnBhZGRpbmdCb3R0b20sIHRoaXMuX21hcmdpbnMuYm90dG9tKSk7XG4gIH1cbiAgYWZ0ZXJGaXQoKSB7XG4gICAgSSh0aGlzLm9wdGlvbnMuYWZ0ZXJGaXQsIFt0aGlzXSk7XG4gIH1cbiAgaXNIb3Jpem9udGFsKCkge1xuICAgIGNvbnN0IHsgYXhpczogdCwgcG9zaXRpb246IGUgfSA9IHRoaXMub3B0aW9ucztcbiAgICByZXR1cm4gZSA9PT0gXCJ0b3BcIiB8fCBlID09PSBcImJvdHRvbVwiIHx8IHQgPT09IFwieFwiO1xuICB9XG4gIGlzRnVsbFNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5mdWxsU2l6ZTtcbiAgfVxuICBfY29udmVydFRpY2tzVG9MYWJlbHModCkge1xuICAgIHRoaXMuYmVmb3JlVGlja1RvTGFiZWxDb252ZXJzaW9uKCksIHRoaXMuZ2VuZXJhdGVUaWNrTGFiZWxzKHQpO1xuICAgIGxldCBlLCBzO1xuICAgIGZvciAoZSA9IDAsIHMgPSB0Lmxlbmd0aDsgZSA8IHM7IGUrKylcbiAgICAgIFQodFtlXS5sYWJlbCkgJiYgKHQuc3BsaWNlKGUsIDEpLCBzLS0sIGUtLSk7XG4gICAgdGhpcy5hZnRlclRpY2tUb0xhYmVsQ29udmVyc2lvbigpO1xuICB9XG4gIF9nZXRMYWJlbFNpemVzKCkge1xuICAgIGxldCB0ID0gdGhpcy5fbGFiZWxTaXplcztcbiAgICBpZiAoIXQpIHtcbiAgICAgIGNvbnN0IGUgPSB0aGlzLm9wdGlvbnMudGlja3Muc2FtcGxlU2l6ZTtcbiAgICAgIGxldCBzID0gdGhpcy50aWNrcztcbiAgICAgIGUgPCBzLmxlbmd0aCAmJiAocyA9IFNzKHMsIGUpKSwgdGhpcy5fbGFiZWxTaXplcyA9IHQgPSB0aGlzLl9jb21wdXRlTGFiZWxTaXplcyhzLCBzLmxlbmd0aCk7XG4gICAgfVxuICAgIHJldHVybiB0O1xuICB9XG4gIF9jb21wdXRlTGFiZWxTaXplcyh0LCBlKSB7XG4gICAgY29uc3QgeyBjdHg6IHMsIF9sb25nZXN0VGV4dENhY2hlOiBuIH0gPSB0aGlzLCBvID0gW10sIHIgPSBbXTtcbiAgICBsZXQgYSA9IDAsIGwgPSAwLCBjLCBoLCBkLCB1LCBmLCBnLCBwLCBtLCBiLCB4LCB2O1xuICAgIGZvciAoYyA9IDA7IGMgPCBlOyArK2MpIHtcbiAgICAgIGlmICh1ID0gdFtjXS5sYWJlbCwgZiA9IHRoaXMuX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMoYyksIHMuZm9udCA9IGcgPSBmLnN0cmluZywgcCA9IG5bZ10gPSBuW2ddIHx8IHsgZGF0YToge30sIGdjOiBbXSB9LCBtID0gZi5saW5lSGVpZ2h0LCBiID0geCA9IDAsICFUKHUpICYmICF6KHUpKVxuICAgICAgICBiID0gTmUocywgcC5kYXRhLCBwLmdjLCBiLCB1KSwgeCA9IG07XG4gICAgICBlbHNlIGlmICh6KHUpKVxuICAgICAgICBmb3IgKGggPSAwLCBkID0gdS5sZW5ndGg7IGggPCBkOyArK2gpXG4gICAgICAgICAgdiA9IHVbaF0sICFUKHYpICYmICF6KHYpICYmIChiID0gTmUocywgcC5kYXRhLCBwLmdjLCBiLCB2KSwgeCArPSBtKTtcbiAgICAgIG8ucHVzaChiKSwgci5wdXNoKHgpLCBhID0gTWF0aC5tYXgoYiwgYSksIGwgPSBNYXRoLm1heCh4LCBsKTtcbiAgICB9XG4gICAgUmEobiwgZSk7XG4gICAgY29uc3QgeSA9IG8uaW5kZXhPZihhKSwgXyA9IHIuaW5kZXhPZihsKSwgTSA9IChrKSA9PiAoeyB3aWR0aDogb1trXSB8fCAwLCBoZWlnaHQ6IHJba10gfHwgMCB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgZmlyc3Q6IE0oMCksXG4gICAgICBsYXN0OiBNKGUgLSAxKSxcbiAgICAgIHdpZGVzdDogTSh5KSxcbiAgICAgIGhpZ2hlc3Q6IE0oXyksXG4gICAgICB3aWR0aHM6IG8sXG4gICAgICBoZWlnaHRzOiByXG4gICAgfTtcbiAgfVxuICBnZXRMYWJlbEZvclZhbHVlKHQpIHtcbiAgICByZXR1cm4gdDtcbiAgfVxuICBnZXRQaXhlbEZvclZhbHVlKHQsIGUpIHtcbiAgICByZXR1cm4gTmFOO1xuICB9XG4gIGdldFZhbHVlRm9yUGl4ZWwodCkge1xuICB9XG4gIGdldFBpeGVsRm9yVGljayh0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMudGlja3M7XG4gICAgcmV0dXJuIHQgPCAwIHx8IHQgPiBlLmxlbmd0aCAtIDEgPyBudWxsIDogdGhpcy5nZXRQaXhlbEZvclZhbHVlKGVbdF0udmFsdWUpO1xuICB9XG4gIGdldFBpeGVsRm9yRGVjaW1hbCh0KSB7XG4gICAgdGhpcy5fcmV2ZXJzZVBpeGVscyAmJiAodCA9IDEgLSB0KTtcbiAgICBjb25zdCBlID0gdGhpcy5fc3RhcnRQaXhlbCArIHQgKiB0aGlzLl9sZW5ndGg7XG4gICAgcmV0dXJuIFRvKHRoaXMuX2FsaWduVG9QaXhlbHMgPyB3dCh0aGlzLmNoYXJ0LCBlLCAwKSA6IGUpO1xuICB9XG4gIGdldERlY2ltYWxGb3JQaXhlbCh0KSB7XG4gICAgY29uc3QgZSA9ICh0IC0gdGhpcy5fc3RhcnRQaXhlbCkgLyB0aGlzLl9sZW5ndGg7XG4gICAgcmV0dXJuIHRoaXMuX3JldmVyc2VQaXhlbHMgPyAxIC0gZSA6IGU7XG4gIH1cbiAgZ2V0QmFzZVBpeGVsKCkge1xuICAgIHJldHVybiB0aGlzLmdldFBpeGVsRm9yVmFsdWUodGhpcy5nZXRCYXNlVmFsdWUoKSk7XG4gIH1cbiAgZ2V0QmFzZVZhbHVlKCkge1xuICAgIGNvbnN0IHsgbWluOiB0LCBtYXg6IGUgfSA9IHRoaXM7XG4gICAgcmV0dXJuIHQgPCAwICYmIGUgPCAwID8gZSA6IHQgPiAwICYmIGUgPiAwID8gdCA6IDA7XG4gIH1cbiAgZ2V0Q29udGV4dCh0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMudGlja3MgfHwgW107XG4gICAgaWYgKHQgPj0gMCAmJiB0IDwgZS5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHMgPSBlW3RdO1xuICAgICAgcmV0dXJuIHMuJGNvbnRleHQgfHwgKHMuJGNvbnRleHQgPSBGYSh0aGlzLmdldENvbnRleHQoKSwgdCwgcykpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy4kY29udGV4dCB8fCAodGhpcy4kY29udGV4dCA9IEVhKHRoaXMuY2hhcnQuZ2V0Q29udGV4dCgpLCB0aGlzKSk7XG4gIH1cbiAgX3RpY2tTaXplKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLm9wdGlvbnMudGlja3MsIGUgPSBudCh0aGlzLmxhYmVsUm90YXRpb24pLCBzID0gTWF0aC5hYnMoTWF0aC5jb3MoZSkpLCBuID0gTWF0aC5hYnMoTWF0aC5zaW4oZSkpLCBvID0gdGhpcy5fZ2V0TGFiZWxTaXplcygpLCByID0gdC5hdXRvU2tpcFBhZGRpbmcgfHwgMCwgYSA9IG8gPyBvLndpZGVzdC53aWR0aCArIHIgOiAwLCBsID0gbyA/IG8uaGlnaGVzdC5oZWlnaHQgKyByIDogMDtcbiAgICByZXR1cm4gdGhpcy5pc0hvcml6b250YWwoKSA/IGwgKiBzID4gYSAqIG4gPyBhIC8gcyA6IGwgLyBuIDogbCAqIG4gPCBhICogcyA/IGwgLyBzIDogYSAvIG47XG4gIH1cbiAgX2lzVmlzaWJsZSgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5vcHRpb25zLmRpc3BsYXk7XG4gICAgcmV0dXJuIHQgIT09IFwiYXV0b1wiID8gISF0IDogdGhpcy5nZXRNYXRjaGluZ1Zpc2libGVNZXRhcygpLmxlbmd0aCA+IDA7XG4gIH1cbiAgX2NvbXB1dGVHcmlkTGluZUl0ZW1zKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5heGlzLCBzID0gdGhpcy5jaGFydCwgbiA9IHRoaXMub3B0aW9ucywgeyBncmlkOiBvLCBwb3NpdGlvbjogciB9ID0gbiwgYSA9IG8ub2Zmc2V0LCBsID0gdGhpcy5pc0hvcml6b250YWwoKSwgaCA9IHRoaXMudGlja3MubGVuZ3RoICsgKGEgPyAxIDogMCksIGQgPSBYdChvKSwgdSA9IFtdLCBmID0gby5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpKSwgZyA9IGYuZHJhd0JvcmRlciA/IGYuYm9yZGVyV2lkdGggOiAwLCBwID0gZyAvIDIsIG0gPSBmdW5jdGlvbihQKSB7XG4gICAgICByZXR1cm4gd3QocywgUCwgZyk7XG4gICAgfTtcbiAgICBsZXQgYiwgeCwgdiwgeSwgXywgTSwgaywgUywgdywgTCwgUiwgQTtcbiAgICBpZiAociA9PT0gXCJ0b3BcIilcbiAgICAgIGIgPSBtKHRoaXMuYm90dG9tKSwgTSA9IHRoaXMuYm90dG9tIC0gZCwgUyA9IGIgLSBwLCBMID0gbSh0LnRvcCkgKyBwLCBBID0gdC5ib3R0b207XG4gICAgZWxzZSBpZiAociA9PT0gXCJib3R0b21cIilcbiAgICAgIGIgPSBtKHRoaXMudG9wKSwgTCA9IHQudG9wLCBBID0gbSh0LmJvdHRvbSkgLSBwLCBNID0gYiArIHAsIFMgPSB0aGlzLnRvcCArIGQ7XG4gICAgZWxzZSBpZiAociA9PT0gXCJsZWZ0XCIpXG4gICAgICBiID0gbSh0aGlzLnJpZ2h0KSwgXyA9IHRoaXMucmlnaHQgLSBkLCBrID0gYiAtIHAsIHcgPSBtKHQubGVmdCkgKyBwLCBSID0gdC5yaWdodDtcbiAgICBlbHNlIGlmIChyID09PSBcInJpZ2h0XCIpXG4gICAgICBiID0gbSh0aGlzLmxlZnQpLCB3ID0gdC5sZWZ0LCBSID0gbSh0LnJpZ2h0KSAtIHAsIF8gPSBiICsgcCwgayA9IHRoaXMubGVmdCArIGQ7XG4gICAgZWxzZSBpZiAoZSA9PT0gXCJ4XCIpIHtcbiAgICAgIGlmIChyID09PSBcImNlbnRlclwiKVxuICAgICAgICBiID0gbSgodC50b3AgKyB0LmJvdHRvbSkgLyAyICsgMC41KTtcbiAgICAgIGVsc2UgaWYgKEQocikpIHtcbiAgICAgICAgY29uc3QgUCA9IE9iamVjdC5rZXlzKHIpWzBdLCBqID0gcltQXTtcbiAgICAgICAgYiA9IG0odGhpcy5jaGFydC5zY2FsZXNbUF0uZ2V0UGl4ZWxGb3JWYWx1ZShqKSk7XG4gICAgICB9XG4gICAgICBMID0gdC50b3AsIEEgPSB0LmJvdHRvbSwgTSA9IGIgKyBwLCBTID0gTSArIGQ7XG4gICAgfSBlbHNlIGlmIChlID09PSBcInlcIikge1xuICAgICAgaWYgKHIgPT09IFwiY2VudGVyXCIpXG4gICAgICAgIGIgPSBtKCh0LmxlZnQgKyB0LnJpZ2h0KSAvIDIpO1xuICAgICAgZWxzZSBpZiAoRChyKSkge1xuICAgICAgICBjb25zdCBQID0gT2JqZWN0LmtleXMocilbMF0sIGogPSByW1BdO1xuICAgICAgICBiID0gbSh0aGlzLmNoYXJ0LnNjYWxlc1tQXS5nZXRQaXhlbEZvclZhbHVlKGopKTtcbiAgICAgIH1cbiAgICAgIF8gPSBiIC0gcCwgayA9IF8gLSBkLCB3ID0gdC5sZWZ0LCBSID0gdC5yaWdodDtcbiAgICB9XG4gICAgY29uc3QgSCA9IEMobi50aWNrcy5tYXhUaWNrc0xpbWl0LCBoKSwgcSA9IE1hdGgubWF4KDEsIE1hdGguY2VpbChoIC8gSCkpO1xuICAgIGZvciAoeCA9IDA7IHggPCBoOyB4ICs9IHEpIHtcbiAgICAgIGNvbnN0IFAgPSBvLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KHgpKSwgaiA9IFAubGluZVdpZHRoLCBXID0gUC5jb2xvciwga3QgPSBQLmJvcmRlckRhc2ggfHwgW10sIHRpID0gUC5ib3JkZXJEYXNoT2Zmc2V0LCBSdCA9IFAudGlja1dpZHRoLCBrZSA9IFAudGlja0NvbG9yLCBFdCA9IFAudGlja0JvcmRlckRhc2ggfHwgW10sIGp0ID0gUC50aWNrQm9yZGVyRGFzaE9mZnNldDtcbiAgICAgIHYgPSBMYSh0aGlzLCB4LCBhKSwgdiAhPT0gdm9pZCAwICYmICh5ID0gd3QocywgdiwgaiksIGwgPyBfID0gayA9IHcgPSBSID0geSA6IE0gPSBTID0gTCA9IEEgPSB5LCB1LnB1c2goe1xuICAgICAgICB0eDE6IF8sXG4gICAgICAgIHR5MTogTSxcbiAgICAgICAgdHgyOiBrLFxuICAgICAgICB0eTI6IFMsXG4gICAgICAgIHgxOiB3LFxuICAgICAgICB5MTogTCxcbiAgICAgICAgeDI6IFIsXG4gICAgICAgIHkyOiBBLFxuICAgICAgICB3aWR0aDogaixcbiAgICAgICAgY29sb3I6IFcsXG4gICAgICAgIGJvcmRlckRhc2g6IGt0LFxuICAgICAgICBib3JkZXJEYXNoT2Zmc2V0OiB0aSxcbiAgICAgICAgdGlja1dpZHRoOiBSdCxcbiAgICAgICAgdGlja0NvbG9yOiBrZSxcbiAgICAgICAgdGlja0JvcmRlckRhc2g6IEV0LFxuICAgICAgICB0aWNrQm9yZGVyRGFzaE9mZnNldDoganRcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3RpY2tzTGVuZ3RoID0gaCwgdGhpcy5fYm9yZGVyVmFsdWUgPSBiLCB1O1xuICB9XG4gIF9jb21wdXRlTGFiZWxJdGVtcyh0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuYXhpcywgcyA9IHRoaXMub3B0aW9ucywgeyBwb3NpdGlvbjogbiwgdGlja3M6IG8gfSA9IHMsIHIgPSB0aGlzLmlzSG9yaXpvbnRhbCgpLCBhID0gdGhpcy50aWNrcywgeyBhbGlnbjogbCwgY3Jvc3NBbGlnbjogYywgcGFkZGluZzogaCwgbWlycm9yOiBkIH0gPSBvLCB1ID0gWHQocy5ncmlkKSwgZiA9IHUgKyBoLCBnID0gZCA/IC1oIDogZiwgcCA9IC1udCh0aGlzLmxhYmVsUm90YXRpb24pLCBtID0gW107XG4gICAgbGV0IGIsIHgsIHYsIHksIF8sIE0sIGssIFMsIHcsIEwsIFIsIEEsIEggPSBcIm1pZGRsZVwiO1xuICAgIGlmIChuID09PSBcInRvcFwiKVxuICAgICAgTSA9IHRoaXMuYm90dG9tIC0gZywgayA9IHRoaXMuX2dldFhBeGlzTGFiZWxBbGlnbm1lbnQoKTtcbiAgICBlbHNlIGlmIChuID09PSBcImJvdHRvbVwiKVxuICAgICAgTSA9IHRoaXMudG9wICsgZywgayA9IHRoaXMuX2dldFhBeGlzTGFiZWxBbGlnbm1lbnQoKTtcbiAgICBlbHNlIGlmIChuID09PSBcImxlZnRcIikge1xuICAgICAgY29uc3QgUCA9IHRoaXMuX2dldFlBeGlzTGFiZWxBbGlnbm1lbnQodSk7XG4gICAgICBrID0gUC50ZXh0QWxpZ24sIF8gPSBQLng7XG4gICAgfSBlbHNlIGlmIChuID09PSBcInJpZ2h0XCIpIHtcbiAgICAgIGNvbnN0IFAgPSB0aGlzLl9nZXRZQXhpc0xhYmVsQWxpZ25tZW50KHUpO1xuICAgICAgayA9IFAudGV4dEFsaWduLCBfID0gUC54O1xuICAgIH0gZWxzZSBpZiAoZSA9PT0gXCJ4XCIpIHtcbiAgICAgIGlmIChuID09PSBcImNlbnRlclwiKVxuICAgICAgICBNID0gKHQudG9wICsgdC5ib3R0b20pIC8gMiArIGY7XG4gICAgICBlbHNlIGlmIChEKG4pKSB7XG4gICAgICAgIGNvbnN0IFAgPSBPYmplY3Qua2V5cyhuKVswXSwgaiA9IG5bUF07XG4gICAgICAgIE0gPSB0aGlzLmNoYXJ0LnNjYWxlc1tQXS5nZXRQaXhlbEZvclZhbHVlKGopICsgZjtcbiAgICAgIH1cbiAgICAgIGsgPSB0aGlzLl9nZXRYQXhpc0xhYmVsQWxpZ25tZW50KCk7XG4gICAgfSBlbHNlIGlmIChlID09PSBcInlcIikge1xuICAgICAgaWYgKG4gPT09IFwiY2VudGVyXCIpXG4gICAgICAgIF8gPSAodC5sZWZ0ICsgdC5yaWdodCkgLyAyIC0gZjtcbiAgICAgIGVsc2UgaWYgKEQobikpIHtcbiAgICAgICAgY29uc3QgUCA9IE9iamVjdC5rZXlzKG4pWzBdLCBqID0gbltQXTtcbiAgICAgICAgXyA9IHRoaXMuY2hhcnQuc2NhbGVzW1BdLmdldFBpeGVsRm9yVmFsdWUoaik7XG4gICAgICB9XG4gICAgICBrID0gdGhpcy5fZ2V0WUF4aXNMYWJlbEFsaWdubWVudCh1KS50ZXh0QWxpZ247XG4gICAgfVxuICAgIGUgPT09IFwieVwiICYmIChsID09PSBcInN0YXJ0XCIgPyBIID0gXCJ0b3BcIiA6IGwgPT09IFwiZW5kXCIgJiYgKEggPSBcImJvdHRvbVwiKSk7XG4gICAgY29uc3QgcSA9IHRoaXMuX2dldExhYmVsU2l6ZXMoKTtcbiAgICBmb3IgKGIgPSAwLCB4ID0gYS5sZW5ndGg7IGIgPCB4OyArK2IpIHtcbiAgICAgIHYgPSBhW2JdLCB5ID0gdi5sYWJlbDtcbiAgICAgIGNvbnN0IFAgPSBvLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KGIpKTtcbiAgICAgIFMgPSB0aGlzLmdldFBpeGVsRm9yVGljayhiKSArIG8ubGFiZWxPZmZzZXQsIHcgPSB0aGlzLl9yZXNvbHZlVGlja0ZvbnRPcHRpb25zKGIpLCBMID0gdy5saW5lSGVpZ2h0LCBSID0geih5KSA/IHkubGVuZ3RoIDogMTtcbiAgICAgIGNvbnN0IGogPSBSIC8gMiwgVyA9IFAuY29sb3IsIGt0ID0gUC50ZXh0U3Ryb2tlQ29sb3IsIHRpID0gUC50ZXh0U3Ryb2tlV2lkdGg7XG4gICAgICBsZXQgUnQgPSBrO1xuICAgICAgciA/IChfID0gUywgayA9PT0gXCJpbm5lclwiICYmIChiID09PSB4IC0gMSA/IFJ0ID0gdGhpcy5vcHRpb25zLnJldmVyc2UgPyBcImxlZnRcIiA6IFwicmlnaHRcIiA6IGIgPT09IDAgPyBSdCA9IHRoaXMub3B0aW9ucy5yZXZlcnNlID8gXCJyaWdodFwiIDogXCJsZWZ0XCIgOiBSdCA9IFwiY2VudGVyXCIpLCBuID09PSBcInRvcFwiID8gYyA9PT0gXCJuZWFyXCIgfHwgcCAhPT0gMCA/IEEgPSAtUiAqIEwgKyBMIC8gMiA6IGMgPT09IFwiY2VudGVyXCIgPyBBID0gLXEuaGlnaGVzdC5oZWlnaHQgLyAyIC0gaiAqIEwgKyBMIDogQSA9IC1xLmhpZ2hlc3QuaGVpZ2h0ICsgTCAvIDIgOiBjID09PSBcIm5lYXJcIiB8fCBwICE9PSAwID8gQSA9IEwgLyAyIDogYyA9PT0gXCJjZW50ZXJcIiA/IEEgPSBxLmhpZ2hlc3QuaGVpZ2h0IC8gMiAtIGogKiBMIDogQSA9IHEuaGlnaGVzdC5oZWlnaHQgLSBSICogTCwgZCAmJiAoQSAqPSAtMSkpIDogKE0gPSBTLCBBID0gKDEgLSBSKSAqIEwgLyAyKTtcbiAgICAgIGxldCBrZTtcbiAgICAgIGlmIChQLnNob3dMYWJlbEJhY2tkcm9wKSB7XG4gICAgICAgIGNvbnN0IEV0ID0gSyhQLmJhY2tkcm9wUGFkZGluZyksIGp0ID0gcS5oZWlnaHRzW2JdLCBlaSA9IHEud2lkdGhzW2JdO1xuICAgICAgICBsZXQgaWkgPSBNICsgQSAtIEV0LnRvcCwgc2kgPSBfIC0gRXQubGVmdDtcbiAgICAgICAgc3dpdGNoIChIKSB7XG4gICAgICAgICAgY2FzZSBcIm1pZGRsZVwiOlxuICAgICAgICAgICAgaWkgLT0ganQgLyAyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImJvdHRvbVwiOlxuICAgICAgICAgICAgaWkgLT0ganQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGspIHtcbiAgICAgICAgICBjYXNlIFwiY2VudGVyXCI6XG4gICAgICAgICAgICBzaSAtPSBlaSAvIDI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwicmlnaHRcIjpcbiAgICAgICAgICAgIHNpIC09IGVpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAga2UgPSB7XG4gICAgICAgICAgbGVmdDogc2ksXG4gICAgICAgICAgdG9wOiBpaSxcbiAgICAgICAgICB3aWR0aDogZWkgKyBFdC53aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGp0ICsgRXQuaGVpZ2h0LFxuICAgICAgICAgIGNvbG9yOiBQLmJhY2tkcm9wQ29sb3JcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIG0ucHVzaCh7XG4gICAgICAgIHJvdGF0aW9uOiBwLFxuICAgICAgICBsYWJlbDogeSxcbiAgICAgICAgZm9udDogdyxcbiAgICAgICAgY29sb3I6IFcsXG4gICAgICAgIHN0cm9rZUNvbG9yOiBrdCxcbiAgICAgICAgc3Ryb2tlV2lkdGg6IHRpLFxuICAgICAgICB0ZXh0T2Zmc2V0OiBBLFxuICAgICAgICB0ZXh0QWxpZ246IFJ0LFxuICAgICAgICB0ZXh0QmFzZWxpbmU6IEgsXG4gICAgICAgIHRyYW5zbGF0aW9uOiBbXywgTV0sXG4gICAgICAgIGJhY2tkcm9wOiBrZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBtO1xuICB9XG4gIF9nZXRYQXhpc0xhYmVsQWxpZ25tZW50KCkge1xuICAgIGNvbnN0IHsgcG9zaXRpb246IHQsIHRpY2tzOiBlIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgaWYgKC1udCh0aGlzLmxhYmVsUm90YXRpb24pKVxuICAgICAgcmV0dXJuIHQgPT09IFwidG9wXCIgPyBcImxlZnRcIiA6IFwicmlnaHRcIjtcbiAgICBsZXQgbiA9IFwiY2VudGVyXCI7XG4gICAgcmV0dXJuIGUuYWxpZ24gPT09IFwic3RhcnRcIiA/IG4gPSBcImxlZnRcIiA6IGUuYWxpZ24gPT09IFwiZW5kXCIgPyBuID0gXCJyaWdodFwiIDogZS5hbGlnbiA9PT0gXCJpbm5lclwiICYmIChuID0gXCJpbm5lclwiKSwgbjtcbiAgfVxuICBfZ2V0WUF4aXNMYWJlbEFsaWdubWVudCh0KSB7XG4gICAgY29uc3QgeyBwb3NpdGlvbjogZSwgdGlja3M6IHsgY3Jvc3NBbGlnbjogcywgbWlycm9yOiBuLCBwYWRkaW5nOiBvIH0gfSA9IHRoaXMub3B0aW9ucywgciA9IHRoaXMuX2dldExhYmVsU2l6ZXMoKSwgYSA9IHQgKyBvLCBsID0gci53aWRlc3Qud2lkdGg7XG4gICAgbGV0IGMsIGg7XG4gICAgcmV0dXJuIGUgPT09IFwibGVmdFwiID8gbiA/IChoID0gdGhpcy5yaWdodCArIG8sIHMgPT09IFwibmVhclwiID8gYyA9IFwibGVmdFwiIDogcyA9PT0gXCJjZW50ZXJcIiA/IChjID0gXCJjZW50ZXJcIiwgaCArPSBsIC8gMikgOiAoYyA9IFwicmlnaHRcIiwgaCArPSBsKSkgOiAoaCA9IHRoaXMucmlnaHQgLSBhLCBzID09PSBcIm5lYXJcIiA/IGMgPSBcInJpZ2h0XCIgOiBzID09PSBcImNlbnRlclwiID8gKGMgPSBcImNlbnRlclwiLCBoIC09IGwgLyAyKSA6IChjID0gXCJsZWZ0XCIsIGggPSB0aGlzLmxlZnQpKSA6IGUgPT09IFwicmlnaHRcIiA/IG4gPyAoaCA9IHRoaXMubGVmdCArIG8sIHMgPT09IFwibmVhclwiID8gYyA9IFwicmlnaHRcIiA6IHMgPT09IFwiY2VudGVyXCIgPyAoYyA9IFwiY2VudGVyXCIsIGggLT0gbCAvIDIpIDogKGMgPSBcImxlZnRcIiwgaCAtPSBsKSkgOiAoaCA9IHRoaXMubGVmdCArIGEsIHMgPT09IFwibmVhclwiID8gYyA9IFwibGVmdFwiIDogcyA9PT0gXCJjZW50ZXJcIiA/IChjID0gXCJjZW50ZXJcIiwgaCArPSBsIC8gMikgOiAoYyA9IFwicmlnaHRcIiwgaCA9IHRoaXMucmlnaHQpKSA6IGMgPSBcInJpZ2h0XCIsIHsgdGV4dEFsaWduOiBjLCB4OiBoIH07XG4gIH1cbiAgX2NvbXB1dGVMYWJlbEFyZWEoKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy50aWNrcy5taXJyb3IpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdCA9IHRoaXMuY2hhcnQsIGUgPSB0aGlzLm9wdGlvbnMucG9zaXRpb247XG4gICAgaWYgKGUgPT09IFwibGVmdFwiIHx8IGUgPT09IFwicmlnaHRcIilcbiAgICAgIHJldHVybiB7IHRvcDogMCwgbGVmdDogdGhpcy5sZWZ0LCBib3R0b206IHQuaGVpZ2h0LCByaWdodDogdGhpcy5yaWdodCB9O1xuICAgIGlmIChlID09PSBcInRvcFwiIHx8IGUgPT09IFwiYm90dG9tXCIpXG4gICAgICByZXR1cm4geyB0b3A6IHRoaXMudG9wLCBsZWZ0OiAwLCBib3R0b206IHRoaXMuYm90dG9tLCByaWdodDogdC53aWR0aCB9O1xuICB9XG4gIGRyYXdCYWNrZ3JvdW5kKCkge1xuICAgIGNvbnN0IHsgY3R4OiB0LCBvcHRpb25zOiB7IGJhY2tncm91bmRDb2xvcjogZSB9LCBsZWZ0OiBzLCB0b3A6IG4sIHdpZHRoOiBvLCBoZWlnaHQ6IHIgfSA9IHRoaXM7XG4gICAgZSAmJiAodC5zYXZlKCksIHQuZmlsbFN0eWxlID0gZSwgdC5maWxsUmVjdChzLCBuLCBvLCByKSwgdC5yZXN0b3JlKCkpO1xuICB9XG4gIGdldExpbmVXaWR0aEZvclZhbHVlKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5vcHRpb25zLmdyaWQ7XG4gICAgaWYgKCF0aGlzLl9pc1Zpc2libGUoKSB8fCAhZS5kaXNwbGF5KVxuICAgICAgcmV0dXJuIDA7XG4gICAgY29uc3QgbiA9IHRoaXMudGlja3MuZmluZEluZGV4KChvKSA9PiBvLnZhbHVlID09PSB0KTtcbiAgICByZXR1cm4gbiA+PSAwID8gZS5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dChuKSkubGluZVdpZHRoIDogMDtcbiAgfVxuICBkcmF3R3JpZCh0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMub3B0aW9ucy5ncmlkLCBzID0gdGhpcy5jdHgsIG4gPSB0aGlzLl9ncmlkTGluZUl0ZW1zIHx8ICh0aGlzLl9ncmlkTGluZUl0ZW1zID0gdGhpcy5fY29tcHV0ZUdyaWRMaW5lSXRlbXModCkpO1xuICAgIGxldCBvLCByO1xuICAgIGNvbnN0IGEgPSAobCwgYywgaCkgPT4ge1xuICAgICAgIWgud2lkdGggfHwgIWguY29sb3IgfHwgKHMuc2F2ZSgpLCBzLmxpbmVXaWR0aCA9IGgud2lkdGgsIHMuc3Ryb2tlU3R5bGUgPSBoLmNvbG9yLCBzLnNldExpbmVEYXNoKGguYm9yZGVyRGFzaCB8fCBbXSksIHMubGluZURhc2hPZmZzZXQgPSBoLmJvcmRlckRhc2hPZmZzZXQsIHMuYmVnaW5QYXRoKCksIHMubW92ZVRvKGwueCwgbC55KSwgcy5saW5lVG8oYy54LCBjLnkpLCBzLnN0cm9rZSgpLCBzLnJlc3RvcmUoKSk7XG4gICAgfTtcbiAgICBpZiAoZS5kaXNwbGF5KVxuICAgICAgZm9yIChvID0gMCwgciA9IG4ubGVuZ3RoOyBvIDwgcjsgKytvKSB7XG4gICAgICAgIGNvbnN0IGwgPSBuW29dO1xuICAgICAgICBlLmRyYXdPbkNoYXJ0QXJlYSAmJiBhKFxuICAgICAgICAgIHsgeDogbC54MSwgeTogbC55MSB9LFxuICAgICAgICAgIHsgeDogbC54MiwgeTogbC55MiB9LFxuICAgICAgICAgIGxcbiAgICAgICAgKSwgZS5kcmF3VGlja3MgJiYgYShcbiAgICAgICAgICB7IHg6IGwudHgxLCB5OiBsLnR5MSB9LFxuICAgICAgICAgIHsgeDogbC50eDIsIHk6IGwudHkyIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgY29sb3I6IGwudGlja0NvbG9yLFxuICAgICAgICAgICAgd2lkdGg6IGwudGlja1dpZHRoLFxuICAgICAgICAgICAgYm9yZGVyRGFzaDogbC50aWNrQm9yZGVyRGFzaCxcbiAgICAgICAgICAgIGJvcmRlckRhc2hPZmZzZXQ6IGwudGlja0JvcmRlckRhc2hPZmZzZXRcbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICB9XG4gIH1cbiAgZHJhd0JvcmRlcigpIHtcbiAgICBjb25zdCB7IGNoYXJ0OiB0LCBjdHg6IGUsIG9wdGlvbnM6IHsgZ3JpZDogcyB9IH0gPSB0aGlzLCBuID0gcy5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpKSwgbyA9IHMuZHJhd0JvcmRlciA/IG4uYm9yZGVyV2lkdGggOiAwO1xuICAgIGlmICghbylcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCByID0gcy5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgwKSkubGluZVdpZHRoLCBhID0gdGhpcy5fYm9yZGVyVmFsdWU7XG4gICAgbGV0IGwsIGMsIGgsIGQ7XG4gICAgdGhpcy5pc0hvcml6b250YWwoKSA/IChsID0gd3QodCwgdGhpcy5sZWZ0LCBvKSAtIG8gLyAyLCBjID0gd3QodCwgdGhpcy5yaWdodCwgcikgKyByIC8gMiwgaCA9IGQgPSBhKSA6IChoID0gd3QodCwgdGhpcy50b3AsIG8pIC0gbyAvIDIsIGQgPSB3dCh0LCB0aGlzLmJvdHRvbSwgcikgKyByIC8gMiwgbCA9IGMgPSBhKSwgZS5zYXZlKCksIGUubGluZVdpZHRoID0gbi5ib3JkZXJXaWR0aCwgZS5zdHJva2VTdHlsZSA9IG4uYm9yZGVyQ29sb3IsIGUuYmVnaW5QYXRoKCksIGUubW92ZVRvKGwsIGgpLCBlLmxpbmVUbyhjLCBkKSwgZS5zdHJva2UoKSwgZS5yZXN0b3JlKCk7XG4gIH1cbiAgZHJhd0xhYmVscyh0KSB7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMudGlja3MuZGlzcGxheSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBzID0gdGhpcy5jdHgsIG4gPSB0aGlzLl9jb21wdXRlTGFiZWxBcmVhKCk7XG4gICAgbiAmJiBYZShzLCBuKTtcbiAgICBjb25zdCBvID0gdGhpcy5fbGFiZWxJdGVtcyB8fCAodGhpcy5fbGFiZWxJdGVtcyA9IHRoaXMuX2NvbXB1dGVMYWJlbEl0ZW1zKHQpKTtcbiAgICBsZXQgciwgYTtcbiAgICBmb3IgKHIgPSAwLCBhID0gby5sZW5ndGg7IHIgPCBhOyArK3IpIHtcbiAgICAgIGNvbnN0IGwgPSBvW3JdLCBjID0gbC5mb250LCBoID0gbC5sYWJlbDtcbiAgICAgIGwuYmFja2Ryb3AgJiYgKHMuZmlsbFN0eWxlID0gbC5iYWNrZHJvcC5jb2xvciwgcy5maWxsUmVjdChsLmJhY2tkcm9wLmxlZnQsIGwuYmFja2Ryb3AudG9wLCBsLmJhY2tkcm9wLndpZHRoLCBsLmJhY2tkcm9wLmhlaWdodCkpO1xuICAgICAgbGV0IGQgPSBsLnRleHRPZmZzZXQ7XG4gICAgICBUdChzLCBoLCAwLCBkLCBjLCBsKTtcbiAgICB9XG4gICAgbiAmJiBVZShzKTtcbiAgfVxuICBkcmF3VGl0bGUoKSB7XG4gICAgY29uc3QgeyBjdHg6IHQsIG9wdGlvbnM6IHsgcG9zaXRpb246IGUsIHRpdGxlOiBzLCByZXZlcnNlOiBuIH0gfSA9IHRoaXM7XG4gICAgaWYgKCFzLmRpc3BsYXkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgbyA9ICQocy5mb250KSwgciA9IEsocy5wYWRkaW5nKSwgYSA9IHMuYWxpZ247XG4gICAgbGV0IGwgPSBvLmxpbmVIZWlnaHQgLyAyO1xuICAgIGUgPT09IFwiYm90dG9tXCIgfHwgZSA9PT0gXCJjZW50ZXJcIiB8fCBEKGUpID8gKGwgKz0gci5ib3R0b20sIHoocy50ZXh0KSAmJiAobCArPSBvLmxpbmVIZWlnaHQgKiAocy50ZXh0Lmxlbmd0aCAtIDEpKSkgOiBsICs9IHIudG9wO1xuICAgIGNvbnN0IHsgdGl0bGVYOiBjLCB0aXRsZVk6IGgsIG1heFdpZHRoOiBkLCByb3RhdGlvbjogdSB9ID0gemEodGhpcywgbCwgZSwgYSk7XG4gICAgVHQodCwgcy50ZXh0LCAwLCAwLCBvLCB7XG4gICAgICBjb2xvcjogcy5jb2xvcixcbiAgICAgIG1heFdpZHRoOiBkLFxuICAgICAgcm90YXRpb246IHUsXG4gICAgICB0ZXh0QWxpZ246IElhKGEsIGUsIG4pLFxuICAgICAgdGV4dEJhc2VsaW5lOiBcIm1pZGRsZVwiLFxuICAgICAgdHJhbnNsYXRpb246IFtjLCBoXVxuICAgIH0pO1xuICB9XG4gIGRyYXcodCkge1xuICAgIHRoaXMuX2lzVmlzaWJsZSgpICYmICh0aGlzLmRyYXdCYWNrZ3JvdW5kKCksIHRoaXMuZHJhd0dyaWQodCksIHRoaXMuZHJhd0JvcmRlcigpLCB0aGlzLmRyYXdUaXRsZSgpLCB0aGlzLmRyYXdMYWJlbHModCkpO1xuICB9XG4gIF9sYXllcnMoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMub3B0aW9ucywgZSA9IHQudGlja3MgJiYgdC50aWNrcy56IHx8IDAsIHMgPSBDKHQuZ3JpZCAmJiB0LmdyaWQueiwgLTEpO1xuICAgIHJldHVybiAhdGhpcy5faXNWaXNpYmxlKCkgfHwgdGhpcy5kcmF3ICE9PSBNdC5wcm90b3R5cGUuZHJhdyA/IFt7XG4gICAgICB6OiBlLFxuICAgICAgZHJhdzogKG4pID0+IHtcbiAgICAgICAgdGhpcy5kcmF3KG4pO1xuICAgICAgfVxuICAgIH1dIDogW3tcbiAgICAgIHo6IHMsXG4gICAgICBkcmF3OiAobikgPT4ge1xuICAgICAgICB0aGlzLmRyYXdCYWNrZ3JvdW5kKCksIHRoaXMuZHJhd0dyaWQobiksIHRoaXMuZHJhd1RpdGxlKCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgejogcyArIDEsXG4gICAgICBkcmF3OiAoKSA9PiB7XG4gICAgICAgIHRoaXMuZHJhd0JvcmRlcigpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIHo6IGUsXG4gICAgICBkcmF3OiAobikgPT4ge1xuICAgICAgICB0aGlzLmRyYXdMYWJlbHMobik7XG4gICAgICB9XG4gICAgfV07XG4gIH1cbiAgZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXModCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLmNoYXJ0LmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKSwgcyA9IHRoaXMuYXhpcyArIFwiQXhpc0lEXCIsIG4gPSBbXTtcbiAgICBsZXQgbywgcjtcbiAgICBmb3IgKG8gPSAwLCByID0gZS5sZW5ndGg7IG8gPCByOyArK28pIHtcbiAgICAgIGNvbnN0IGEgPSBlW29dO1xuICAgICAgYVtzXSA9PT0gdGhpcy5pZCAmJiAoIXQgfHwgYS50eXBlID09PSB0KSAmJiBuLnB1c2goYSk7XG4gICAgfVxuICAgIHJldHVybiBuO1xuICB9XG4gIF9yZXNvbHZlVGlja0ZvbnRPcHRpb25zKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5vcHRpb25zLnRpY2tzLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KHQpKTtcbiAgICByZXR1cm4gJChlLmZvbnQpO1xuICB9XG4gIF9tYXhEaWdpdHMoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMoMCkubGluZUhlaWdodDtcbiAgICByZXR1cm4gKHRoaXMuaXNIb3Jpem9udGFsKCkgPyB0aGlzLndpZHRoIDogdGhpcy5oZWlnaHQpIC8gdDtcbiAgfVxufVxuY2xhc3MgQWUge1xuICBjb25zdHJ1Y3Rvcih0LCBlLCBzKSB7XG4gICAgdGhpcy50eXBlID0gdCwgdGhpcy5zY29wZSA9IGUsIHRoaXMub3ZlcnJpZGUgPSBzLCB0aGlzLml0ZW1zID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cbiAgaXNGb3JUeXBlKHQpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mLmNhbGwodGhpcy50eXBlLnByb3RvdHlwZSwgdC5wcm90b3R5cGUpO1xuICB9XG4gIHJlZ2lzdGVyKHQpIHtcbiAgICBjb25zdCBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHQpO1xuICAgIGxldCBzO1xuICAgIFdhKGUpICYmIChzID0gdGhpcy5yZWdpc3RlcihlKSk7XG4gICAgY29uc3QgbiA9IHRoaXMuaXRlbXMsIG8gPSB0LmlkLCByID0gdGhpcy5zY29wZSArIFwiLlwiICsgbztcbiAgICBpZiAoIW8pXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjbGFzcyBkb2VzIG5vdCBoYXZlIGlkOiBcIiArIHQpO1xuICAgIHJldHVybiBvIGluIG4gfHwgKG5bb10gPSB0LCBCYSh0LCByLCBzKSwgdGhpcy5vdmVycmlkZSAmJiBPLm92ZXJyaWRlKHQuaWQsIHQub3ZlcnJpZGVzKSksIHI7XG4gIH1cbiAgZ2V0KHQpIHtcbiAgICByZXR1cm4gdGhpcy5pdGVtc1t0XTtcbiAgfVxuICB1bnJlZ2lzdGVyKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5pdGVtcywgcyA9IHQuaWQsIG4gPSB0aGlzLnNjb3BlO1xuICAgIHMgaW4gZSAmJiBkZWxldGUgZVtzXSwgbiAmJiBzIGluIE9bbl0gJiYgKGRlbGV0ZSBPW25dW3NdLCB0aGlzLm92ZXJyaWRlICYmIGRlbGV0ZSBBdFtzXSk7XG4gIH1cbn1cbmZ1bmN0aW9uIEJhKGksIHQsIGUpIHtcbiAgY29uc3QgcyA9IG5lKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpLCBbXG4gICAgZSA/IE8uZ2V0KGUpIDoge30sXG4gICAgTy5nZXQodCksXG4gICAgaS5kZWZhdWx0c1xuICBdKTtcbiAgTy5zZXQodCwgcyksIGkuZGVmYXVsdFJvdXRlcyAmJiBWYSh0LCBpLmRlZmF1bHRSb3V0ZXMpLCBpLmRlc2NyaXB0b3JzICYmIE8uZGVzY3JpYmUodCwgaS5kZXNjcmlwdG9ycyk7XG59XG5mdW5jdGlvbiBWYShpLCB0KSB7XG4gIE9iamVjdC5rZXlzKHQpLmZvckVhY2goKGUpID0+IHtcbiAgICBjb25zdCBzID0gZS5zcGxpdChcIi5cIiksIG4gPSBzLnBvcCgpLCBvID0gW2ldLmNvbmNhdChzKS5qb2luKFwiLlwiKSwgciA9IHRbZV0uc3BsaXQoXCIuXCIpLCBhID0gci5wb3AoKSwgbCA9IHIuam9pbihcIi5cIik7XG4gICAgTy5yb3V0ZShvLCBuLCBsLCBhKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBXYShpKSB7XG4gIHJldHVybiBcImlkXCIgaW4gaSAmJiBcImRlZmF1bHRzXCIgaW4gaTtcbn1cbmNsYXNzIE5hIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5jb250cm9sbGVycyA9IG5ldyBBZShpdCwgXCJkYXRhc2V0c1wiLCAhMCksIHRoaXMuZWxlbWVudHMgPSBuZXcgQWUoc3QsIFwiZWxlbWVudHNcIiksIHRoaXMucGx1Z2lucyA9IG5ldyBBZShPYmplY3QsIFwicGx1Z2luc1wiKSwgdGhpcy5zY2FsZXMgPSBuZXcgQWUoTXQsIFwic2NhbGVzXCIpLCB0aGlzLl90eXBlZFJlZ2lzdHJpZXMgPSBbdGhpcy5jb250cm9sbGVycywgdGhpcy5zY2FsZXMsIHRoaXMuZWxlbWVudHNdO1xuICB9XG4gIGFkZCguLi50KSB7XG4gICAgdGhpcy5fZWFjaChcInJlZ2lzdGVyXCIsIHQpO1xuICB9XG4gIHJlbW92ZSguLi50KSB7XG4gICAgdGhpcy5fZWFjaChcInVucmVnaXN0ZXJcIiwgdCk7XG4gIH1cbiAgYWRkQ29udHJvbGxlcnMoLi4udCkge1xuICAgIHRoaXMuX2VhY2goXCJyZWdpc3RlclwiLCB0LCB0aGlzLmNvbnRyb2xsZXJzKTtcbiAgfVxuICBhZGRFbGVtZW50cyguLi50KSB7XG4gICAgdGhpcy5fZWFjaChcInJlZ2lzdGVyXCIsIHQsIHRoaXMuZWxlbWVudHMpO1xuICB9XG4gIGFkZFBsdWdpbnMoLi4udCkge1xuICAgIHRoaXMuX2VhY2goXCJyZWdpc3RlclwiLCB0LCB0aGlzLnBsdWdpbnMpO1xuICB9XG4gIGFkZFNjYWxlcyguLi50KSB7XG4gICAgdGhpcy5fZWFjaChcInJlZ2lzdGVyXCIsIHQsIHRoaXMuc2NhbGVzKTtcbiAgfVxuICBnZXRDb250cm9sbGVyKHQpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0KHQsIHRoaXMuY29udHJvbGxlcnMsIFwiY29udHJvbGxlclwiKTtcbiAgfVxuICBnZXRFbGVtZW50KHQpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0KHQsIHRoaXMuZWxlbWVudHMsIFwiZWxlbWVudFwiKTtcbiAgfVxuICBnZXRQbHVnaW4odCkge1xuICAgIHJldHVybiB0aGlzLl9nZXQodCwgdGhpcy5wbHVnaW5zLCBcInBsdWdpblwiKTtcbiAgfVxuICBnZXRTY2FsZSh0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldCh0LCB0aGlzLnNjYWxlcywgXCJzY2FsZVwiKTtcbiAgfVxuICByZW1vdmVDb250cm9sbGVycyguLi50KSB7XG4gICAgdGhpcy5fZWFjaChcInVucmVnaXN0ZXJcIiwgdCwgdGhpcy5jb250cm9sbGVycyk7XG4gIH1cbiAgcmVtb3ZlRWxlbWVudHMoLi4udCkge1xuICAgIHRoaXMuX2VhY2goXCJ1bnJlZ2lzdGVyXCIsIHQsIHRoaXMuZWxlbWVudHMpO1xuICB9XG4gIHJlbW92ZVBsdWdpbnMoLi4udCkge1xuICAgIHRoaXMuX2VhY2goXCJ1bnJlZ2lzdGVyXCIsIHQsIHRoaXMucGx1Z2lucyk7XG4gIH1cbiAgcmVtb3ZlU2NhbGVzKC4uLnQpIHtcbiAgICB0aGlzLl9lYWNoKFwidW5yZWdpc3RlclwiLCB0LCB0aGlzLnNjYWxlcyk7XG4gIH1cbiAgX2VhY2godCwgZSwgcykge1xuICAgIFsuLi5lXS5mb3JFYWNoKChuKSA9PiB7XG4gICAgICBjb25zdCBvID0gcyB8fCB0aGlzLl9nZXRSZWdpc3RyeUZvclR5cGUobik7XG4gICAgICBzIHx8IG8uaXNGb3JUeXBlKG4pIHx8IG8gPT09IHRoaXMucGx1Z2lucyAmJiBuLmlkID8gdGhpcy5fZXhlYyh0LCBvLCBuKSA6IEUobiwgKHIpID0+IHtcbiAgICAgICAgY29uc3QgYSA9IHMgfHwgdGhpcy5fZ2V0UmVnaXN0cnlGb3JUeXBlKHIpO1xuICAgICAgICB0aGlzLl9leGVjKHQsIGEsIHIpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgX2V4ZWModCwgZSwgcykge1xuICAgIGNvbnN0IG4gPSBPaSh0KTtcbiAgICBJKHNbXCJiZWZvcmVcIiArIG5dLCBbXSwgcyksIGVbdF0ocyksIEkoc1tcImFmdGVyXCIgKyBuXSwgW10sIHMpO1xuICB9XG4gIF9nZXRSZWdpc3RyeUZvclR5cGUodCkge1xuICAgIGZvciAobGV0IGUgPSAwOyBlIDwgdGhpcy5fdHlwZWRSZWdpc3RyaWVzLmxlbmd0aDsgZSsrKSB7XG4gICAgICBjb25zdCBzID0gdGhpcy5fdHlwZWRSZWdpc3RyaWVzW2VdO1xuICAgICAgaWYgKHMuaXNGb3JUeXBlKHQpKVxuICAgICAgICByZXR1cm4gcztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucGx1Z2lucztcbiAgfVxuICBfZ2V0KHQsIGUsIHMpIHtcbiAgICBjb25zdCBuID0gZS5nZXQodCk7XG4gICAgaWYgKG4gPT09IHZvaWQgMClcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCInICsgdCArICdcIiBpcyBub3QgYSByZWdpc3RlcmVkICcgKyBzICsgXCIuXCIpO1xuICAgIHJldHVybiBuO1xuICB9XG59XG52YXIgb3QgPSBuZXcgTmEoKTtcbmNsYXNzIHhlIGV4dGVuZHMgaXQge1xuICB1cGRhdGUodCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLl9jYWNoZWRNZXRhLCB7IGRhdGE6IHMgPSBbXSB9ID0gZSwgbiA9IHRoaXMuY2hhcnQuX2FuaW1hdGlvbnNEaXNhYmxlZDtcbiAgICBsZXQgeyBzdGFydDogbywgY291bnQ6IHIgfSA9IHBuKGUsIHMsIG4pO1xuICAgIGlmICh0aGlzLl9kcmF3U3RhcnQgPSBvLCB0aGlzLl9kcmF3Q291bnQgPSByLCBtbihlKSAmJiAobyA9IDAsIHIgPSBzLmxlbmd0aCksIHRoaXMub3B0aW9ucy5zaG93TGluZSkge1xuICAgICAgY29uc3QgeyBkYXRhc2V0OiBhLCBfZGF0YXNldDogbCB9ID0gZTtcbiAgICAgIGEuX2NoYXJ0ID0gdGhpcy5jaGFydCwgYS5fZGF0YXNldEluZGV4ID0gdGhpcy5pbmRleCwgYS5fZGVjaW1hdGVkID0gISFsLl9kZWNpbWF0ZWQsIGEucG9pbnRzID0gcztcbiAgICAgIGNvbnN0IGMgPSB0aGlzLnJlc29sdmVEYXRhc2V0RWxlbWVudE9wdGlvbnModCk7XG4gICAgICBjLnNlZ21lbnQgPSB0aGlzLm9wdGlvbnMuc2VnbWVudCwgdGhpcy51cGRhdGVFbGVtZW50KGEsIHZvaWQgMCwge1xuICAgICAgICBhbmltYXRlZDogIW4sXG4gICAgICAgIG9wdGlvbnM6IGNcbiAgICAgIH0sIHQpO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKHMsIG8sIHIsIHQpO1xuICB9XG4gIGFkZEVsZW1lbnRzKCkge1xuICAgIGNvbnN0IHsgc2hvd0xpbmU6IHQgfSA9IHRoaXMub3B0aW9ucztcbiAgICAhdGhpcy5kYXRhc2V0RWxlbWVudFR5cGUgJiYgdCAmJiAodGhpcy5kYXRhc2V0RWxlbWVudFR5cGUgPSBvdC5nZXRFbGVtZW50KFwibGluZVwiKSksIHN1cGVyLmFkZEVsZW1lbnRzKCk7XG4gIH1cbiAgdXBkYXRlRWxlbWVudHModCwgZSwgcywgbikge1xuICAgIGNvbnN0IG8gPSBuID09PSBcInJlc2V0XCIsIHsgaVNjYWxlOiByLCB2U2NhbGU6IGEsIF9zdGFja2VkOiBsLCBfZGF0YXNldDogYyB9ID0gdGhpcy5fY2FjaGVkTWV0YSwgaCA9IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhlLCBuKSwgZCA9IHRoaXMuZ2V0U2hhcmVkT3B0aW9ucyhoKSwgdSA9IHRoaXMuaW5jbHVkZU9wdGlvbnMobiwgZCksIGYgPSByLmF4aXMsIGcgPSBhLmF4aXMsIHsgc3BhbkdhcHM6IHAsIHNlZ21lbnQ6IG0gfSA9IHRoaXMub3B0aW9ucywgYiA9IEJ0KHApID8gcCA6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgeCA9IHRoaXMuY2hhcnQuX2FuaW1hdGlvbnNEaXNhYmxlZCB8fCBvIHx8IG4gPT09IFwibm9uZVwiO1xuICAgIGxldCB2ID0gZSA+IDAgJiYgdGhpcy5nZXRQYXJzZWQoZSAtIDEpO1xuICAgIGZvciAobGV0IHkgPSBlOyB5IDwgZSArIHM7ICsreSkge1xuICAgICAgY29uc3QgXyA9IHRbeV0sIE0gPSB0aGlzLmdldFBhcnNlZCh5KSwgayA9IHggPyBfIDoge30sIFMgPSBUKE1bZ10pLCB3ID0ga1tmXSA9IHIuZ2V0UGl4ZWxGb3JWYWx1ZShNW2ZdLCB5KSwgTCA9IGtbZ10gPSBvIHx8IFMgPyBhLmdldEJhc2VQaXhlbCgpIDogYS5nZXRQaXhlbEZvclZhbHVlKGwgPyB0aGlzLmFwcGx5U3RhY2soYSwgTSwgbCkgOiBNW2ddLCB5KTtcbiAgICAgIGsuc2tpcCA9IGlzTmFOKHcpIHx8IGlzTmFOKEwpIHx8IFMsIGsuc3RvcCA9IHkgPiAwICYmIE1hdGguYWJzKE1bZl0gLSB2W2ZdKSA+IGIsIG0gJiYgKGsucGFyc2VkID0gTSwgay5yYXcgPSBjLmRhdGFbeV0pLCB1ICYmIChrLm9wdGlvbnMgPSBkIHx8IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyh5LCBfLmFjdGl2ZSA/IFwiYWN0aXZlXCIgOiBuKSksIHggfHwgdGhpcy51cGRhdGVFbGVtZW50KF8sIHksIGssIG4pLCB2ID0gTTtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVTaGFyZWRPcHRpb25zKGQsIG4sIGgpO1xuICB9XG4gIGdldE1heE92ZXJmbG93KCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9jYWNoZWRNZXRhLCBlID0gdC5kYXRhIHx8IFtdO1xuICAgIGlmICghdGhpcy5vcHRpb25zLnNob3dMaW5lKSB7XG4gICAgICBsZXQgYSA9IDA7XG4gICAgICBmb3IgKGxldCBsID0gZS5sZW5ndGggLSAxOyBsID49IDA7IC0tbClcbiAgICAgICAgYSA9IE1hdGgubWF4KGEsIGVbbF0uc2l6ZSh0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMobCkpIC8gMik7XG4gICAgICByZXR1cm4gYSA+IDAgJiYgYTtcbiAgICB9XG4gICAgY29uc3QgcyA9IHQuZGF0YXNldCwgbiA9IHMub3B0aW9ucyAmJiBzLm9wdGlvbnMuYm9yZGVyV2lkdGggfHwgMDtcbiAgICBpZiAoIWUubGVuZ3RoKVxuICAgICAgcmV0dXJuIG47XG4gICAgY29uc3QgbyA9IGVbMF0uc2l6ZSh0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoMCkpLCByID0gZVtlLmxlbmd0aCAtIDFdLnNpemUodGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGUubGVuZ3RoIC0gMSkpO1xuICAgIHJldHVybiBNYXRoLm1heChuLCBvLCByKSAvIDI7XG4gIH1cbn1cbnhlLmlkID0gXCJzY2F0dGVyXCI7XG54ZS5kZWZhdWx0cyA9IHtcbiAgZGF0YXNldEVsZW1lbnRUeXBlOiAhMSxcbiAgZGF0YUVsZW1lbnRUeXBlOiBcInBvaW50XCIsXG4gIHNob3dMaW5lOiAhMSxcbiAgZmlsbDogITFcbn07XG54ZS5vdmVycmlkZXMgPSB7XG4gIGludGVyYWN0aW9uOiB7XG4gICAgbW9kZTogXCJwb2ludFwiXG4gIH0sXG4gIHBsdWdpbnM6IHtcbiAgICB0b29sdGlwOiB7XG4gICAgICBjYWxsYmFja3M6IHtcbiAgICAgICAgdGl0bGUoKSB7XG4gICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIH0sXG4gICAgICAgIGxhYmVsKGkpIHtcbiAgICAgICAgICByZXR1cm4gXCIoXCIgKyBpLmxhYmVsICsgXCIsIFwiICsgaS5mb3JtYXR0ZWRWYWx1ZSArIFwiKVwiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBzY2FsZXM6IHtcbiAgICB4OiB7XG4gICAgICB0eXBlOiBcImxpbmVhclwiXG4gICAgfSxcbiAgICB5OiB7XG4gICAgICB0eXBlOiBcImxpbmVhclwiXG4gICAgfVxuICB9XG59O1xudmFyIFduID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIEJhckNvbnRyb2xsZXI6IHVlLFxuICBCdWJibGVDb250cm9sbGVyOiBmZSxcbiAgRG91Z2hudXRDb250cm9sbGVyOiBMdCxcbiAgTGluZUNvbnRyb2xsZXI6IGdlLFxuICBQb2xhckFyZWFDb250cm9sbGVyOiBwZSxcbiAgUGllQ29udHJvbGxlcjogcWUsXG4gIFJhZGFyQ29udHJvbGxlcjogbWUsXG4gIFNjYXR0ZXJDb250cm9sbGVyOiB4ZVxufSk7XG5mdW5jdGlvbiBTdCgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBtZXRob2QgaXMgbm90IGltcGxlbWVudGVkOiBDaGVjayB0aGF0IGEgY29tcGxldGUgZGF0ZSBhZGFwdGVyIGlzIHByb3ZpZGVkLlwiKTtcbn1cbmNsYXNzIHZpIHtcbiAgY29uc3RydWN0b3IodCkge1xuICAgIHRoaXMub3B0aW9ucyA9IHQgfHwge307XG4gIH1cbiAgaW5pdCh0KSB7XG4gIH1cbiAgZm9ybWF0cygpIHtcbiAgICByZXR1cm4gU3QoKTtcbiAgfVxuICBwYXJzZSh0LCBlKSB7XG4gICAgcmV0dXJuIFN0KCk7XG4gIH1cbiAgZm9ybWF0KHQsIGUpIHtcbiAgICByZXR1cm4gU3QoKTtcbiAgfVxuICBhZGQodCwgZSwgcykge1xuICAgIHJldHVybiBTdCgpO1xuICB9XG4gIGRpZmYodCwgZSwgcykge1xuICAgIHJldHVybiBTdCgpO1xuICB9XG4gIHN0YXJ0T2YodCwgZSwgcykge1xuICAgIHJldHVybiBTdCgpO1xuICB9XG4gIGVuZE9mKHQsIGUpIHtcbiAgICByZXR1cm4gU3QoKTtcbiAgfVxufVxudmkub3ZlcnJpZGUgPSBmdW5jdGlvbihpKSB7XG4gIE9iamVjdC5hc3NpZ24odmkucHJvdG90eXBlLCBpKTtcbn07XG52YXIgTm4gPSB7XG4gIF9kYXRlOiB2aVxufTtcbmZ1bmN0aW9uIEhhKGksIHQsIGUsIHMpIHtcbiAgY29uc3QgeyBjb250cm9sbGVyOiBuLCBkYXRhOiBvLCBfc29ydGVkOiByIH0gPSBpLCBhID0gbi5fY2FjaGVkTWV0YS5pU2NhbGU7XG4gIGlmIChhICYmIHQgPT09IGEuYXhpcyAmJiB0ICE9PSBcInJcIiAmJiByICYmIG8ubGVuZ3RoKSB7XG4gICAgY29uc3QgbCA9IGEuX3JldmVyc2VQaXhlbHMgPyBMbyA6IGZ0O1xuICAgIGlmIChzKSB7XG4gICAgICBpZiAobi5fc2hhcmVkT3B0aW9ucykge1xuICAgICAgICBjb25zdCBjID0gb1swXSwgaCA9IHR5cGVvZiBjLmdldFJhbmdlID09IFwiZnVuY3Rpb25cIiAmJiBjLmdldFJhbmdlKHQpO1xuICAgICAgICBpZiAoaCkge1xuICAgICAgICAgIGNvbnN0IGQgPSBsKG8sIHQsIGUgLSBoKSwgdSA9IGwobywgdCwgZSArIGgpO1xuICAgICAgICAgIHJldHVybiB7IGxvOiBkLmxvLCBoaTogdS5oaSB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlXG4gICAgICByZXR1cm4gbChvLCB0LCBlKTtcbiAgfVxuICByZXR1cm4geyBsbzogMCwgaGk6IG8ubGVuZ3RoIC0gMSB9O1xufVxuZnVuY3Rpb24gX2UoaSwgdCwgZSwgcywgbikge1xuICBjb25zdCBvID0gaS5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCksIHIgPSBlW3RdO1xuICBmb3IgKGxldCBhID0gMCwgbCA9IG8ubGVuZ3RoOyBhIDwgbDsgKythKSB7XG4gICAgY29uc3QgeyBpbmRleDogYywgZGF0YTogaCB9ID0gb1thXSwgeyBsbzogZCwgaGk6IHUgfSA9IEhhKG9bYV0sIHQsIHIsIG4pO1xuICAgIGZvciAobGV0IGYgPSBkOyBmIDw9IHU7ICsrZikge1xuICAgICAgY29uc3QgZyA9IGhbZl07XG4gICAgICBnLnNraXAgfHwgcyhnLCBjLCBmKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGphKGkpIHtcbiAgY29uc3QgdCA9IGkuaW5kZXhPZihcInhcIikgIT09IC0xLCBlID0gaS5pbmRleE9mKFwieVwiKSAhPT0gLTE7XG4gIHJldHVybiBmdW5jdGlvbihzLCBuKSB7XG4gICAgY29uc3QgbyA9IHQgPyBNYXRoLmFicyhzLnggLSBuLngpIDogMCwgciA9IGUgPyBNYXRoLmFicyhzLnkgLSBuLnkpIDogMDtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KG8sIDIpICsgTWF0aC5wb3cociwgMikpO1xuICB9O1xufVxuZnVuY3Rpb24gZGkoaSwgdCwgZSwgcywgbikge1xuICBjb25zdCBvID0gW107XG4gIHJldHVybiAhbiAmJiAhaS5pc1BvaW50SW5BcmVhKHQpIHx8IF9lKGksIGUsIHQsIGZ1bmN0aW9uKGEsIGwsIGMpIHtcbiAgICAhbiAmJiAhcmUoYSwgaS5jaGFydEFyZWEsIDApIHx8IGEuaW5SYW5nZSh0LngsIHQueSwgcykgJiYgby5wdXNoKHsgZWxlbWVudDogYSwgZGF0YXNldEluZGV4OiBsLCBpbmRleDogYyB9KTtcbiAgfSwgITApLCBvO1xufVxuZnVuY3Rpb24gJGEoaSwgdCwgZSwgcykge1xuICBsZXQgbiA9IFtdO1xuICBmdW5jdGlvbiBvKHIsIGEsIGwpIHtcbiAgICBjb25zdCB7IHN0YXJ0QW5nbGU6IGMsIGVuZEFuZ2xlOiBoIH0gPSByLmdldFByb3BzKFtcInN0YXJ0QW5nbGVcIiwgXCJlbmRBbmdsZVwiXSwgcyksIHsgYW5nbGU6IGQgfSA9IGhuKHIsIHsgeDogdC54LCB5OiB0LnkgfSk7XG4gICAgb2UoZCwgYywgaCkgJiYgbi5wdXNoKHsgZWxlbWVudDogciwgZGF0YXNldEluZGV4OiBhLCBpbmRleDogbCB9KTtcbiAgfVxuICByZXR1cm4gX2UoaSwgZSwgdCwgbyksIG47XG59XG5mdW5jdGlvbiBZYShpLCB0LCBlLCBzLCBuLCBvKSB7XG4gIGxldCByID0gW107XG4gIGNvbnN0IGEgPSBqYShlKTtcbiAgbGV0IGwgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gIGZ1bmN0aW9uIGMoaCwgZCwgdSkge1xuICAgIGNvbnN0IGYgPSBoLmluUmFuZ2UodC54LCB0LnksIG4pO1xuICAgIGlmIChzICYmICFmKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGcgPSBoLmdldENlbnRlclBvaW50KG4pO1xuICAgIGlmICghKCEhbyB8fCBpLmlzUG9pbnRJbkFyZWEoZykpICYmICFmKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG0gPSBhKHQsIGcpO1xuICAgIG0gPCBsID8gKHIgPSBbeyBlbGVtZW50OiBoLCBkYXRhc2V0SW5kZXg6IGQsIGluZGV4OiB1IH1dLCBsID0gbSkgOiBtID09PSBsICYmIHIucHVzaCh7IGVsZW1lbnQ6IGgsIGRhdGFzZXRJbmRleDogZCwgaW5kZXg6IHUgfSk7XG4gIH1cbiAgcmV0dXJuIF9lKGksIGUsIHQsIGMpLCByO1xufVxuZnVuY3Rpb24gdWkoaSwgdCwgZSwgcywgbiwgbykge1xuICByZXR1cm4gIW8gJiYgIWkuaXNQb2ludEluQXJlYSh0KSA/IFtdIDogZSA9PT0gXCJyXCIgJiYgIXMgPyAkYShpLCB0LCBlLCBuKSA6IFlhKGksIHQsIGUsIHMsIG4sIG8pO1xufVxuZnVuY3Rpb24gQ3MoaSwgdCwgZSwgcywgbikge1xuICBjb25zdCBvID0gW10sIHIgPSBlID09PSBcInhcIiA/IFwiaW5YUmFuZ2VcIiA6IFwiaW5ZUmFuZ2VcIjtcbiAgbGV0IGEgPSAhMTtcbiAgcmV0dXJuIF9lKGksIGUsIHQsIChsLCBjLCBoKSA9PiB7XG4gICAgbFtyXSh0W2VdLCBuKSAmJiAoby5wdXNoKHsgZWxlbWVudDogbCwgZGF0YXNldEluZGV4OiBjLCBpbmRleDogaCB9KSwgYSA9IGEgfHwgbC5pblJhbmdlKHQueCwgdC55LCBuKSk7XG4gIH0pLCBzICYmICFhID8gW10gOiBvO1xufVxudmFyIEhuID0ge1xuICBldmFsdWF0ZUludGVyYWN0aW9uSXRlbXM6IF9lLFxuICBtb2Rlczoge1xuICAgIGluZGV4KGksIHQsIGUsIHMpIHtcbiAgICAgIGNvbnN0IG4gPSBQdCh0LCBpKSwgbyA9IGUuYXhpcyB8fCBcInhcIiwgciA9IGUuaW5jbHVkZUludmlzaWJsZSB8fCAhMSwgYSA9IGUuaW50ZXJzZWN0ID8gZGkoaSwgbiwgbywgcywgcikgOiB1aShpLCBuLCBvLCAhMSwgcywgciksIGwgPSBbXTtcbiAgICAgIHJldHVybiBhLmxlbmd0aCA/IChpLmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKS5mb3JFYWNoKChjKSA9PiB7XG4gICAgICAgIGNvbnN0IGggPSBhWzBdLmluZGV4LCBkID0gYy5kYXRhW2hdO1xuICAgICAgICBkICYmICFkLnNraXAgJiYgbC5wdXNoKHsgZWxlbWVudDogZCwgZGF0YXNldEluZGV4OiBjLmluZGV4LCBpbmRleDogaCB9KTtcbiAgICAgIH0pLCBsKSA6IFtdO1xuICAgIH0sXG4gICAgZGF0YXNldChpLCB0LCBlLCBzKSB7XG4gICAgICBjb25zdCBuID0gUHQodCwgaSksIG8gPSBlLmF4aXMgfHwgXCJ4eVwiLCByID0gZS5pbmNsdWRlSW52aXNpYmxlIHx8ICExO1xuICAgICAgbGV0IGEgPSBlLmludGVyc2VjdCA/IGRpKGksIG4sIG8sIHMsIHIpIDogdWkoaSwgbiwgbywgITEsIHMsIHIpO1xuICAgICAgaWYgKGEubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBsID0gYVswXS5kYXRhc2V0SW5kZXgsIGMgPSBpLmdldERhdGFzZXRNZXRhKGwpLmRhdGE7XG4gICAgICAgIGEgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaCA9IDA7IGggPCBjLmxlbmd0aDsgKytoKVxuICAgICAgICAgIGEucHVzaCh7IGVsZW1lbnQ6IGNbaF0sIGRhdGFzZXRJbmRleDogbCwgaW5kZXg6IGggfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYTtcbiAgICB9LFxuICAgIHBvaW50KGksIHQsIGUsIHMpIHtcbiAgICAgIGNvbnN0IG4gPSBQdCh0LCBpKSwgbyA9IGUuYXhpcyB8fCBcInh5XCIsIHIgPSBlLmluY2x1ZGVJbnZpc2libGUgfHwgITE7XG4gICAgICByZXR1cm4gZGkoaSwgbiwgbywgcywgcik7XG4gICAgfSxcbiAgICBuZWFyZXN0KGksIHQsIGUsIHMpIHtcbiAgICAgIGNvbnN0IG4gPSBQdCh0LCBpKSwgbyA9IGUuYXhpcyB8fCBcInh5XCIsIHIgPSBlLmluY2x1ZGVJbnZpc2libGUgfHwgITE7XG4gICAgICByZXR1cm4gdWkoaSwgbiwgbywgZS5pbnRlcnNlY3QsIHMsIHIpO1xuICAgIH0sXG4gICAgeChpLCB0LCBlLCBzKSB7XG4gICAgICBjb25zdCBuID0gUHQodCwgaSk7XG4gICAgICByZXR1cm4gQ3MoaSwgbiwgXCJ4XCIsIGUuaW50ZXJzZWN0LCBzKTtcbiAgICB9LFxuICAgIHkoaSwgdCwgZSwgcykge1xuICAgICAgY29uc3QgbiA9IFB0KHQsIGkpO1xuICAgICAgcmV0dXJuIENzKGksIG4sIFwieVwiLCBlLmludGVyc2VjdCwgcyk7XG4gICAgfVxuICB9XG59O1xuY29uc3Qgam4gPSBbXCJsZWZ0XCIsIFwidG9wXCIsIFwicmlnaHRcIiwgXCJib3R0b21cIl07XG5mdW5jdGlvbiBVdChpLCB0KSB7XG4gIHJldHVybiBpLmZpbHRlcigoZSkgPT4gZS5wb3MgPT09IHQpO1xufVxuZnVuY3Rpb24gRHMoaSwgdCkge1xuICByZXR1cm4gaS5maWx0ZXIoKGUpID0+IGpuLmluZGV4T2YoZS5wb3MpID09PSAtMSAmJiBlLmJveC5heGlzID09PSB0KTtcbn1cbmZ1bmN0aW9uIEt0KGksIHQpIHtcbiAgcmV0dXJuIGkuc29ydCgoZSwgcykgPT4ge1xuICAgIGNvbnN0IG4gPSB0ID8gcyA6IGUsIG8gPSB0ID8gZSA6IHM7XG4gICAgcmV0dXJuIG4ud2VpZ2h0ID09PSBvLndlaWdodCA/IG4uaW5kZXggLSBvLmluZGV4IDogbi53ZWlnaHQgLSBvLndlaWdodDtcbiAgfSk7XG59XG5mdW5jdGlvbiBYYShpKSB7XG4gIGNvbnN0IHQgPSBbXTtcbiAgbGV0IGUsIHMsIG4sIG8sIHIsIGE7XG4gIGZvciAoZSA9IDAsIHMgPSAoaSB8fCBbXSkubGVuZ3RoOyBlIDwgczsgKytlKVxuICAgIG4gPSBpW2VdLCB7IHBvc2l0aW9uOiBvLCBvcHRpb25zOiB7IHN0YWNrOiByLCBzdGFja1dlaWdodDogYSA9IDEgfSB9ID0gbiwgdC5wdXNoKHtcbiAgICAgIGluZGV4OiBlLFxuICAgICAgYm94OiBuLFxuICAgICAgcG9zOiBvLFxuICAgICAgaG9yaXpvbnRhbDogbi5pc0hvcml6b250YWwoKSxcbiAgICAgIHdlaWdodDogbi53ZWlnaHQsXG4gICAgICBzdGFjazogciAmJiBvICsgcixcbiAgICAgIHN0YWNrV2VpZ2h0OiBhXG4gICAgfSk7XG4gIHJldHVybiB0O1xufVxuZnVuY3Rpb24gVWEoaSkge1xuICBjb25zdCB0ID0ge307XG4gIGZvciAoY29uc3QgZSBvZiBpKSB7XG4gICAgY29uc3QgeyBzdGFjazogcywgcG9zOiBuLCBzdGFja1dlaWdodDogbyB9ID0gZTtcbiAgICBpZiAoIXMgfHwgIWpuLmluY2x1ZGVzKG4pKVxuICAgICAgY29udGludWU7XG4gICAgY29uc3QgciA9IHRbc10gfHwgKHRbc10gPSB7IGNvdW50OiAwLCBwbGFjZWQ6IDAsIHdlaWdodDogMCwgc2l6ZTogMCB9KTtcbiAgICByLmNvdW50KyssIHIud2VpZ2h0ICs9IG87XG4gIH1cbiAgcmV0dXJuIHQ7XG59XG5mdW5jdGlvbiBLYShpLCB0KSB7XG4gIGNvbnN0IGUgPSBVYShpKSwgeyB2Qm94TWF4V2lkdGg6IHMsIGhCb3hNYXhIZWlnaHQ6IG4gfSA9IHQ7XG4gIGxldCBvLCByLCBhO1xuICBmb3IgKG8gPSAwLCByID0gaS5sZW5ndGg7IG8gPCByOyArK28pIHtcbiAgICBhID0gaVtvXTtcbiAgICBjb25zdCB7IGZ1bGxTaXplOiBsIH0gPSBhLmJveCwgYyA9IGVbYS5zdGFja10sIGggPSBjICYmIGEuc3RhY2tXZWlnaHQgLyBjLndlaWdodDtcbiAgICBhLmhvcml6b250YWwgPyAoYS53aWR0aCA9IGggPyBoICogcyA6IGwgJiYgdC5hdmFpbGFibGVXaWR0aCwgYS5oZWlnaHQgPSBuKSA6IChhLndpZHRoID0gcywgYS5oZWlnaHQgPSBoID8gaCAqIG4gOiBsICYmIHQuYXZhaWxhYmxlSGVpZ2h0KTtcbiAgfVxuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIHFhKGkpIHtcbiAgY29uc3QgdCA9IFhhKGkpLCBlID0gS3QodC5maWx0ZXIoKGMpID0+IGMuYm94LmZ1bGxTaXplKSwgITApLCBzID0gS3QoVXQodCwgXCJsZWZ0XCIpLCAhMCksIG4gPSBLdChVdCh0LCBcInJpZ2h0XCIpKSwgbyA9IEt0KFV0KHQsIFwidG9wXCIpLCAhMCksIHIgPSBLdChVdCh0LCBcImJvdHRvbVwiKSksIGEgPSBEcyh0LCBcInhcIiksIGwgPSBEcyh0LCBcInlcIik7XG4gIHJldHVybiB7XG4gICAgZnVsbFNpemU6IGUsXG4gICAgbGVmdEFuZFRvcDogcy5jb25jYXQobyksXG4gICAgcmlnaHRBbmRCb3R0b206IG4uY29uY2F0KGwpLmNvbmNhdChyKS5jb25jYXQoYSksXG4gICAgY2hhcnRBcmVhOiBVdCh0LCBcImNoYXJ0QXJlYVwiKSxcbiAgICB2ZXJ0aWNhbDogcy5jb25jYXQobikuY29uY2F0KGwpLFxuICAgIGhvcml6b250YWw6IG8uY29uY2F0KHIpLmNvbmNhdChhKVxuICB9O1xufVxuZnVuY3Rpb24gT3MoaSwgdCwgZSwgcykge1xuICByZXR1cm4gTWF0aC5tYXgoaVtlXSwgdFtlXSkgKyBNYXRoLm1heChpW3NdLCB0W3NdKTtcbn1cbmZ1bmN0aW9uICRuKGksIHQpIHtcbiAgaS50b3AgPSBNYXRoLm1heChpLnRvcCwgdC50b3ApLCBpLmxlZnQgPSBNYXRoLm1heChpLmxlZnQsIHQubGVmdCksIGkuYm90dG9tID0gTWF0aC5tYXgoaS5ib3R0b20sIHQuYm90dG9tKSwgaS5yaWdodCA9IE1hdGgubWF4KGkucmlnaHQsIHQucmlnaHQpO1xufVxuZnVuY3Rpb24gR2EoaSwgdCwgZSwgcykge1xuICBjb25zdCB7IHBvczogbiwgYm94OiBvIH0gPSBlLCByID0gaS5tYXhQYWRkaW5nO1xuICBpZiAoIUQobikpIHtcbiAgICBlLnNpemUgJiYgKGlbbl0gLT0gZS5zaXplKTtcbiAgICBjb25zdCBkID0gc1tlLnN0YWNrXSB8fCB7IHNpemU6IDAsIGNvdW50OiAxIH07XG4gICAgZC5zaXplID0gTWF0aC5tYXgoZC5zaXplLCBlLmhvcml6b250YWwgPyBvLmhlaWdodCA6IG8ud2lkdGgpLCBlLnNpemUgPSBkLnNpemUgLyBkLmNvdW50LCBpW25dICs9IGUuc2l6ZTtcbiAgfVxuICBvLmdldFBhZGRpbmcgJiYgJG4ociwgby5nZXRQYWRkaW5nKCkpO1xuICBjb25zdCBhID0gTWF0aC5tYXgoMCwgdC5vdXRlcldpZHRoIC0gT3MociwgaSwgXCJsZWZ0XCIsIFwicmlnaHRcIikpLCBsID0gTWF0aC5tYXgoMCwgdC5vdXRlckhlaWdodCAtIE9zKHIsIGksIFwidG9wXCIsIFwiYm90dG9tXCIpKSwgYyA9IGEgIT09IGkudywgaCA9IGwgIT09IGkuaDtcbiAgcmV0dXJuIGkudyA9IGEsIGkuaCA9IGwsIGUuaG9yaXpvbnRhbCA/IHsgc2FtZTogYywgb3RoZXI6IGggfSA6IHsgc2FtZTogaCwgb3RoZXI6IGMgfTtcbn1cbmZ1bmN0aW9uIFphKGkpIHtcbiAgY29uc3QgdCA9IGkubWF4UGFkZGluZztcbiAgZnVuY3Rpb24gZShzKSB7XG4gICAgY29uc3QgbiA9IE1hdGgubWF4KHRbc10gLSBpW3NdLCAwKTtcbiAgICByZXR1cm4gaVtzXSArPSBuLCBuO1xuICB9XG4gIGkueSArPSBlKFwidG9wXCIpLCBpLnggKz0gZShcImxlZnRcIiksIGUoXCJyaWdodFwiKSwgZShcImJvdHRvbVwiKTtcbn1cbmZ1bmN0aW9uIEphKGksIHQpIHtcbiAgY29uc3QgZSA9IHQubWF4UGFkZGluZztcbiAgZnVuY3Rpb24gcyhuKSB7XG4gICAgY29uc3QgbyA9IHsgbGVmdDogMCwgdG9wOiAwLCByaWdodDogMCwgYm90dG9tOiAwIH07XG4gICAgcmV0dXJuIG4uZm9yRWFjaCgocikgPT4ge1xuICAgICAgb1tyXSA9IE1hdGgubWF4KHRbcl0sIGVbcl0pO1xuICAgIH0pLCBvO1xuICB9XG4gIHJldHVybiBzKGkgPyBbXCJsZWZ0XCIsIFwicmlnaHRcIl0gOiBbXCJ0b3BcIiwgXCJib3R0b21cIl0pO1xufVxuZnVuY3Rpb24gSnQoaSwgdCwgZSwgcykge1xuICBjb25zdCBuID0gW107XG4gIGxldCBvLCByLCBhLCBsLCBjLCBoO1xuICBmb3IgKG8gPSAwLCByID0gaS5sZW5ndGgsIGMgPSAwOyBvIDwgcjsgKytvKSB7XG4gICAgYSA9IGlbb10sIGwgPSBhLmJveCwgbC51cGRhdGUoXG4gICAgICBhLndpZHRoIHx8IHQudyxcbiAgICAgIGEuaGVpZ2h0IHx8IHQuaCxcbiAgICAgIEphKGEuaG9yaXpvbnRhbCwgdClcbiAgICApO1xuICAgIGNvbnN0IHsgc2FtZTogZCwgb3RoZXI6IHUgfSA9IEdhKHQsIGUsIGEsIHMpO1xuICAgIGMgfD0gZCAmJiBuLmxlbmd0aCwgaCA9IGggfHwgdSwgbC5mdWxsU2l6ZSB8fCBuLnB1c2goYSk7XG4gIH1cbiAgcmV0dXJuIGMgJiYgSnQobiwgdCwgZSwgcykgfHwgaDtcbn1cbmZ1bmN0aW9uIFRlKGksIHQsIGUsIHMsIG4pIHtcbiAgaS50b3AgPSBlLCBpLmxlZnQgPSB0LCBpLnJpZ2h0ID0gdCArIHMsIGkuYm90dG9tID0gZSArIG4sIGkud2lkdGggPSBzLCBpLmhlaWdodCA9IG47XG59XG5mdW5jdGlvbiBBcyhpLCB0LCBlLCBzKSB7XG4gIGNvbnN0IG4gPSBlLnBhZGRpbmc7XG4gIGxldCB7IHg6IG8sIHk6IHIgfSA9IHQ7XG4gIGZvciAoY29uc3QgYSBvZiBpKSB7XG4gICAgY29uc3QgbCA9IGEuYm94LCBjID0gc1thLnN0YWNrXSB8fCB7IGNvdW50OiAxLCBwbGFjZWQ6IDAsIHdlaWdodDogMSB9LCBoID0gYS5zdGFja1dlaWdodCAvIGMud2VpZ2h0IHx8IDE7XG4gICAgaWYgKGEuaG9yaXpvbnRhbCkge1xuICAgICAgY29uc3QgZCA9IHQudyAqIGgsIHUgPSBjLnNpemUgfHwgbC5oZWlnaHQ7XG4gICAgICBldChjLnN0YXJ0KSAmJiAociA9IGMuc3RhcnQpLCBsLmZ1bGxTaXplID8gVGUobCwgbi5sZWZ0LCByLCBlLm91dGVyV2lkdGggLSBuLnJpZ2h0IC0gbi5sZWZ0LCB1KSA6IFRlKGwsIHQubGVmdCArIGMucGxhY2VkLCByLCBkLCB1KSwgYy5zdGFydCA9IHIsIGMucGxhY2VkICs9IGQsIHIgPSBsLmJvdHRvbTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZCA9IHQuaCAqIGgsIHUgPSBjLnNpemUgfHwgbC53aWR0aDtcbiAgICAgIGV0KGMuc3RhcnQpICYmIChvID0gYy5zdGFydCksIGwuZnVsbFNpemUgPyBUZShsLCBvLCBuLnRvcCwgdSwgZS5vdXRlckhlaWdodCAtIG4uYm90dG9tIC0gbi50b3ApIDogVGUobCwgbywgdC50b3AgKyBjLnBsYWNlZCwgdSwgZCksIGMuc3RhcnQgPSBvLCBjLnBsYWNlZCArPSBkLCBvID0gbC5yaWdodDtcbiAgICB9XG4gIH1cbiAgdC54ID0gbywgdC55ID0gcjtcbn1cbk8uc2V0KFwibGF5b3V0XCIsIHtcbiAgYXV0b1BhZGRpbmc6ICEwLFxuICBwYWRkaW5nOiB7XG4gICAgdG9wOiAwLFxuICAgIHJpZ2h0OiAwLFxuICAgIGJvdHRvbTogMCxcbiAgICBsZWZ0OiAwXG4gIH1cbn0pO1xudmFyIFggPSB7XG4gIGFkZEJveChpLCB0KSB7XG4gICAgaS5ib3hlcyB8fCAoaS5ib3hlcyA9IFtdKSwgdC5mdWxsU2l6ZSA9IHQuZnVsbFNpemUgfHwgITEsIHQucG9zaXRpb24gPSB0LnBvc2l0aW9uIHx8IFwidG9wXCIsIHQud2VpZ2h0ID0gdC53ZWlnaHQgfHwgMCwgdC5fbGF5ZXJzID0gdC5fbGF5ZXJzIHx8IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFt7XG4gICAgICAgIHo6IDAsXG4gICAgICAgIGRyYXcoZSkge1xuICAgICAgICAgIHQuZHJhdyhlKTtcbiAgICAgICAgfVxuICAgICAgfV07XG4gICAgfSwgaS5ib3hlcy5wdXNoKHQpO1xuICB9LFxuICByZW1vdmVCb3goaSwgdCkge1xuICAgIGNvbnN0IGUgPSBpLmJveGVzID8gaS5ib3hlcy5pbmRleE9mKHQpIDogLTE7XG4gICAgZSAhPT0gLTEgJiYgaS5ib3hlcy5zcGxpY2UoZSwgMSk7XG4gIH0sXG4gIGNvbmZpZ3VyZShpLCB0LCBlKSB7XG4gICAgdC5mdWxsU2l6ZSA9IGUuZnVsbFNpemUsIHQucG9zaXRpb24gPSBlLnBvc2l0aW9uLCB0LndlaWdodCA9IGUud2VpZ2h0O1xuICB9LFxuICB1cGRhdGUoaSwgdCwgZSwgcykge1xuICAgIGlmICghaSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBuID0gSyhpLm9wdGlvbnMubGF5b3V0LnBhZGRpbmcpLCBvID0gTWF0aC5tYXgodCAtIG4ud2lkdGgsIDApLCByID0gTWF0aC5tYXgoZSAtIG4uaGVpZ2h0LCAwKSwgYSA9IHFhKGkuYm94ZXMpLCBsID0gYS52ZXJ0aWNhbCwgYyA9IGEuaG9yaXpvbnRhbDtcbiAgICBFKGkuYm94ZXMsIChwKSA9PiB7XG4gICAgICB0eXBlb2YgcC5iZWZvcmVMYXlvdXQgPT0gXCJmdW5jdGlvblwiICYmIHAuYmVmb3JlTGF5b3V0KCk7XG4gICAgfSk7XG4gICAgY29uc3QgaCA9IGwucmVkdWNlKChwLCBtKSA9PiBtLmJveC5vcHRpb25zICYmIG0uYm94Lm9wdGlvbnMuZGlzcGxheSA9PT0gITEgPyBwIDogcCArIDEsIDApIHx8IDEsIGQgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgIG91dGVyV2lkdGg6IHQsXG4gICAgICBvdXRlckhlaWdodDogZSxcbiAgICAgIHBhZGRpbmc6IG4sXG4gICAgICBhdmFpbGFibGVXaWR0aDogbyxcbiAgICAgIGF2YWlsYWJsZUhlaWdodDogcixcbiAgICAgIHZCb3hNYXhXaWR0aDogbyAvIDIgLyBoLFxuICAgICAgaEJveE1heEhlaWdodDogciAvIDJcbiAgICB9KSwgdSA9IE9iamVjdC5hc3NpZ24oe30sIG4pO1xuICAgICRuKHUsIEsocykpO1xuICAgIGNvbnN0IGYgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIG1heFBhZGRpbmc6IHUsXG4gICAgICB3OiBvLFxuICAgICAgaDogcixcbiAgICAgIHg6IG4ubGVmdCxcbiAgICAgIHk6IG4udG9wXG4gICAgfSwgbiksIGcgPSBLYShsLmNvbmNhdChjKSwgZCk7XG4gICAgSnQoYS5mdWxsU2l6ZSwgZiwgZCwgZyksIEp0KGwsIGYsIGQsIGcpLCBKdChjLCBmLCBkLCBnKSAmJiBKdChsLCBmLCBkLCBnKSwgWmEoZiksIEFzKGEubGVmdEFuZFRvcCwgZiwgZCwgZyksIGYueCArPSBmLncsIGYueSArPSBmLmgsIEFzKGEucmlnaHRBbmRCb3R0b20sIGYsIGQsIGcpLCBpLmNoYXJ0QXJlYSA9IHtcbiAgICAgIGxlZnQ6IGYubGVmdCxcbiAgICAgIHRvcDogZi50b3AsXG4gICAgICByaWdodDogZi5sZWZ0ICsgZi53LFxuICAgICAgYm90dG9tOiBmLnRvcCArIGYuaCxcbiAgICAgIGhlaWdodDogZi5oLFxuICAgICAgd2lkdGg6IGYud1xuICAgIH0sIEUoYS5jaGFydEFyZWEsIChwKSA9PiB7XG4gICAgICBjb25zdCBtID0gcC5ib3g7XG4gICAgICBPYmplY3QuYXNzaWduKG0sIGkuY2hhcnRBcmVhKSwgbS51cGRhdGUoZi53LCBmLmgsIHsgbGVmdDogMCwgdG9wOiAwLCByaWdodDogMCwgYm90dG9tOiAwIH0pO1xuICAgIH0pO1xuICB9XG59O1xuY2xhc3MgSGkge1xuICBhY3F1aXJlQ29udGV4dCh0LCBlKSB7XG4gIH1cbiAgcmVsZWFzZUNvbnRleHQodCkge1xuICAgIHJldHVybiAhMTtcbiAgfVxuICBhZGRFdmVudExpc3RlbmVyKHQsIGUsIHMpIHtcbiAgfVxuICByZW1vdmVFdmVudExpc3RlbmVyKHQsIGUsIHMpIHtcbiAgfVxuICBnZXREZXZpY2VQaXhlbFJhdGlvKCkge1xuICAgIHJldHVybiAxO1xuICB9XG4gIGdldE1heGltdW1TaXplKHQsIGUsIHMsIG4pIHtcbiAgICByZXR1cm4gZSA9IE1hdGgubWF4KDAsIGUgfHwgdC53aWR0aCksIHMgPSBzIHx8IHQuaGVpZ2h0LCB7XG4gICAgICB3aWR0aDogZSxcbiAgICAgIGhlaWdodDogTWF0aC5tYXgoMCwgbiA/IE1hdGguZmxvb3IoZSAvIG4pIDogcylcbiAgICB9O1xuICB9XG4gIGlzQXR0YWNoZWQodCkge1xuICAgIHJldHVybiAhMDtcbiAgfVxuICB1cGRhdGVDb25maWcodCkge1xuICB9XG59XG5jbGFzcyBZbiBleHRlbmRzIEhpIHtcbiAgYWNxdWlyZUNvbnRleHQodCkge1xuICAgIHJldHVybiB0ICYmIHQuZ2V0Q29udGV4dCAmJiB0LmdldENvbnRleHQoXCIyZFwiKSB8fCBudWxsO1xuICB9XG4gIHVwZGF0ZUNvbmZpZyh0KSB7XG4gICAgdC5vcHRpb25zLmFuaW1hdGlvbiA9ICExO1xuICB9XG59XG5jb25zdCBJZSA9IFwiJGNoYXJ0anNcIiwgUWEgPSB7XG4gIHRvdWNoc3RhcnQ6IFwibW91c2Vkb3duXCIsXG4gIHRvdWNobW92ZTogXCJtb3VzZW1vdmVcIixcbiAgdG91Y2hlbmQ6IFwibW91c2V1cFwiLFxuICBwb2ludGVyZW50ZXI6IFwibW91c2VlbnRlclwiLFxuICBwb2ludGVyZG93bjogXCJtb3VzZWRvd25cIixcbiAgcG9pbnRlcm1vdmU6IFwibW91c2Vtb3ZlXCIsXG4gIHBvaW50ZXJ1cDogXCJtb3VzZXVwXCIsXG4gIHBvaW50ZXJsZWF2ZTogXCJtb3VzZW91dFwiLFxuICBwb2ludGVyb3V0OiBcIm1vdXNlb3V0XCJcbn0sIFRzID0gKGkpID0+IGkgPT09IG51bGwgfHwgaSA9PT0gXCJcIjtcbmZ1bmN0aW9uIHRsKGksIHQpIHtcbiAgY29uc3QgZSA9IGkuc3R5bGUsIHMgPSBpLmdldEF0dHJpYnV0ZShcImhlaWdodFwiKSwgbiA9IGkuZ2V0QXR0cmlidXRlKFwid2lkdGhcIik7XG4gIGlmIChpW0llXSA9IHtcbiAgICBpbml0aWFsOiB7XG4gICAgICBoZWlnaHQ6IHMsXG4gICAgICB3aWR0aDogbixcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGRpc3BsYXk6IGUuZGlzcGxheSxcbiAgICAgICAgaGVpZ2h0OiBlLmhlaWdodCxcbiAgICAgICAgd2lkdGg6IGUud2lkdGhcbiAgICAgIH1cbiAgICB9XG4gIH0sIGUuZGlzcGxheSA9IGUuZGlzcGxheSB8fCBcImJsb2NrXCIsIGUuYm94U2l6aW5nID0gZS5ib3hTaXppbmcgfHwgXCJib3JkZXItYm94XCIsIFRzKG4pKSB7XG4gICAgY29uc3QgbyA9IGNzKGksIFwid2lkdGhcIik7XG4gICAgbyAhPT0gdm9pZCAwICYmIChpLndpZHRoID0gbyk7XG4gIH1cbiAgaWYgKFRzKHMpKVxuICAgIGlmIChpLnN0eWxlLmhlaWdodCA9PT0gXCJcIilcbiAgICAgIGkuaGVpZ2h0ID0gaS53aWR0aCAvICh0IHx8IDIpO1xuICAgIGVsc2Uge1xuICAgICAgY29uc3QgbyA9IGNzKGksIFwiaGVpZ2h0XCIpO1xuICAgICAgbyAhPT0gdm9pZCAwICYmIChpLmhlaWdodCA9IG8pO1xuICAgIH1cbiAgcmV0dXJuIGk7XG59XG5jb25zdCBYbiA9IFZyID8geyBwYXNzaXZlOiAhMCB9IDogITE7XG5mdW5jdGlvbiBlbChpLCB0LCBlKSB7XG4gIGkuYWRkRXZlbnRMaXN0ZW5lcih0LCBlLCBYbik7XG59XG5mdW5jdGlvbiBpbChpLCB0LCBlKSB7XG4gIGkuY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIodCwgZSwgWG4pO1xufVxuZnVuY3Rpb24gc2woaSwgdCkge1xuICBjb25zdCBlID0gUWFbaS50eXBlXSB8fCBpLnR5cGUsIHsgeDogcywgeTogbiB9ID0gUHQoaSwgdCk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogZSxcbiAgICBjaGFydDogdCxcbiAgICBuYXRpdmU6IGksXG4gICAgeDogcyAhPT0gdm9pZCAwID8gcyA6IG51bGwsXG4gICAgeTogbiAhPT0gdm9pZCAwID8gbiA6IG51bGxcbiAgfTtcbn1cbmZ1bmN0aW9uIGplKGksIHQpIHtcbiAgZm9yIChjb25zdCBlIG9mIGkpXG4gICAgaWYgKGUgPT09IHQgfHwgZS5jb250YWlucyh0KSlcbiAgICAgIHJldHVybiAhMDtcbn1cbmZ1bmN0aW9uIG5sKGksIHQsIGUpIHtcbiAgY29uc3QgcyA9IGkuY2FudmFzLCBuID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKG8pID0+IHtcbiAgICBsZXQgciA9ICExO1xuICAgIGZvciAoY29uc3QgYSBvZiBvKVxuICAgICAgciA9IHIgfHwgamUoYS5hZGRlZE5vZGVzLCBzKSwgciA9IHIgJiYgIWplKGEucmVtb3ZlZE5vZGVzLCBzKTtcbiAgICByICYmIGUoKTtcbiAgfSk7XG4gIHJldHVybiBuLm9ic2VydmUoZG9jdW1lbnQsIHsgY2hpbGRMaXN0OiAhMCwgc3VidHJlZTogITAgfSksIG47XG59XG5mdW5jdGlvbiBvbChpLCB0LCBlKSB7XG4gIGNvbnN0IHMgPSBpLmNhbnZhcywgbiA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKChvKSA9PiB7XG4gICAgbGV0IHIgPSAhMTtcbiAgICBmb3IgKGNvbnN0IGEgb2YgbylcbiAgICAgIHIgPSByIHx8IGplKGEucmVtb3ZlZE5vZGVzLCBzKSwgciA9IHIgJiYgIWplKGEuYWRkZWROb2Rlcywgcyk7XG4gICAgciAmJiBlKCk7XG4gIH0pO1xuICByZXR1cm4gbi5vYnNlcnZlKGRvY3VtZW50LCB7IGNoaWxkTGlzdDogITAsIHN1YnRyZWU6ICEwIH0pLCBuO1xufVxuY29uc3QgbGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xubGV0IExzID0gMDtcbmZ1bmN0aW9uIFVuKCkge1xuICBjb25zdCBpID0gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gIGkgIT09IExzICYmIChMcyA9IGksIGxlLmZvckVhY2goKHQsIGUpID0+IHtcbiAgICBlLmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvICE9PSBpICYmIHQoKTtcbiAgfSkpO1xufVxuZnVuY3Rpb24gcmwoaSwgdCkge1xuICBsZS5zaXplIHx8IHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIFVuKSwgbGUuc2V0KGksIHQpO1xufVxuZnVuY3Rpb24gYWwoaSkge1xuICBsZS5kZWxldGUoaSksIGxlLnNpemUgfHwgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgVW4pO1xufVxuZnVuY3Rpb24gbGwoaSwgdCwgZSkge1xuICBjb25zdCBzID0gaS5jYW52YXMsIG4gPSBzICYmIFdpKHMpO1xuICBpZiAoIW4pXG4gICAgcmV0dXJuO1xuICBjb25zdCBvID0gZ24oKGEsIGwpID0+IHtcbiAgICBjb25zdCBjID0gbi5jbGllbnRXaWR0aDtcbiAgICBlKGEsIGwpLCBjIDwgbi5jbGllbnRXaWR0aCAmJiBlKCk7XG4gIH0sIHdpbmRvdyksIHIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoKGEpID0+IHtcbiAgICBjb25zdCBsID0gYVswXSwgYyA9IGwuY29udGVudFJlY3Qud2lkdGgsIGggPSBsLmNvbnRlbnRSZWN0LmhlaWdodDtcbiAgICBjID09PSAwICYmIGggPT09IDAgfHwgbyhjLCBoKTtcbiAgfSk7XG4gIHJldHVybiByLm9ic2VydmUobiksIHJsKGksIG8pLCByO1xufVxuZnVuY3Rpb24gZmkoaSwgdCwgZSkge1xuICBlICYmIGUuZGlzY29ubmVjdCgpLCB0ID09PSBcInJlc2l6ZVwiICYmIGFsKGkpO1xufVxuZnVuY3Rpb24gY2woaSwgdCwgZSkge1xuICBjb25zdCBzID0gaS5jYW52YXMsIG4gPSBnbigobykgPT4ge1xuICAgIGkuY3R4ICE9PSBudWxsICYmIGUoc2wobywgaSkpO1xuICB9LCBpLCAobykgPT4ge1xuICAgIGNvbnN0IHIgPSBvWzBdO1xuICAgIHJldHVybiBbciwgci5vZmZzZXRYLCByLm9mZnNldFldO1xuICB9KTtcbiAgcmV0dXJuIGVsKHMsIHQsIG4pLCBuO1xufVxuY2xhc3MgS24gZXh0ZW5kcyBIaSB7XG4gIGFjcXVpcmVDb250ZXh0KHQsIGUpIHtcbiAgICBjb25zdCBzID0gdCAmJiB0LmdldENvbnRleHQgJiYgdC5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgcmV0dXJuIHMgJiYgcy5jYW52YXMgPT09IHQgPyAodGwodCwgZSksIHMpIDogbnVsbDtcbiAgfVxuICByZWxlYXNlQ29udGV4dCh0KSB7XG4gICAgY29uc3QgZSA9IHQuY2FudmFzO1xuICAgIGlmICghZVtJZV0pXG4gICAgICByZXR1cm4gITE7XG4gICAgY29uc3QgcyA9IGVbSWVdLmluaXRpYWw7XG4gICAgW1wiaGVpZ2h0XCIsIFwid2lkdGhcIl0uZm9yRWFjaCgobykgPT4ge1xuICAgICAgY29uc3QgciA9IHNbb107XG4gICAgICBUKHIpID8gZS5yZW1vdmVBdHRyaWJ1dGUobykgOiBlLnNldEF0dHJpYnV0ZShvLCByKTtcbiAgICB9KTtcbiAgICBjb25zdCBuID0gcy5zdHlsZSB8fCB7fTtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMobikuZm9yRWFjaCgobykgPT4ge1xuICAgICAgZS5zdHlsZVtvXSA9IG5bb107XG4gICAgfSksIGUud2lkdGggPSBlLndpZHRoLCBkZWxldGUgZVtJZV0sICEwO1xuICB9XG4gIGFkZEV2ZW50TGlzdGVuZXIodCwgZSwgcykge1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcih0LCBlKTtcbiAgICBjb25zdCBuID0gdC4kcHJveGllcyB8fCAodC4kcHJveGllcyA9IHt9KSwgciA9IHtcbiAgICAgIGF0dGFjaDogbmwsXG4gICAgICBkZXRhY2g6IG9sLFxuICAgICAgcmVzaXplOiBsbFxuICAgIH1bZV0gfHwgY2w7XG4gICAgbltlXSA9IHIodCwgZSwgcyk7XG4gIH1cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcih0LCBlKSB7XG4gICAgY29uc3QgcyA9IHQuJHByb3hpZXMgfHwgKHQuJHByb3hpZXMgPSB7fSksIG4gPSBzW2VdO1xuICAgIGlmICghbilcbiAgICAgIHJldHVybjtcbiAgICAoe1xuICAgICAgYXR0YWNoOiBmaSxcbiAgICAgIGRldGFjaDogZmksXG4gICAgICByZXNpemU6IGZpXG4gICAgfVtlXSB8fCBpbCkodCwgZSwgbiksIHNbZV0gPSB2b2lkIDA7XG4gIH1cbiAgZ2V0RGV2aWNlUGl4ZWxSYXRpbygpIHtcbiAgICByZXR1cm4gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gIH1cbiAgZ2V0TWF4aW11bVNpemUodCwgZSwgcywgbikge1xuICAgIHJldHVybiBCcih0LCBlLCBzLCBuKTtcbiAgfVxuICBpc0F0dGFjaGVkKHQpIHtcbiAgICBjb25zdCBlID0gV2kodCk7XG4gICAgcmV0dXJuICEhKGUgJiYgZS5pc0Nvbm5lY3RlZCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHFuKGkpIHtcbiAgcmV0dXJuICFBbigpIHx8IHR5cGVvZiBPZmZzY3JlZW5DYW52YXMgPCBcInVcIiAmJiBpIGluc3RhbmNlb2YgT2Zmc2NyZWVuQ2FudmFzID8gWW4gOiBLbjtcbn1cbmNsYXNzIGhsIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5faW5pdCA9IFtdO1xuICB9XG4gIG5vdGlmeSh0LCBlLCBzLCBuKSB7XG4gICAgZSA9PT0gXCJiZWZvcmVJbml0XCIgJiYgKHRoaXMuX2luaXQgPSB0aGlzLl9jcmVhdGVEZXNjcmlwdG9ycyh0LCAhMCksIHRoaXMuX25vdGlmeSh0aGlzLl9pbml0LCB0LCBcImluc3RhbGxcIikpO1xuICAgIGNvbnN0IG8gPSBuID8gdGhpcy5fZGVzY3JpcHRvcnModCkuZmlsdGVyKG4pIDogdGhpcy5fZGVzY3JpcHRvcnModCksIHIgPSB0aGlzLl9ub3RpZnkobywgdCwgZSwgcyk7XG4gICAgcmV0dXJuIGUgPT09IFwiYWZ0ZXJEZXN0cm95XCIgJiYgKHRoaXMuX25vdGlmeShvLCB0LCBcInN0b3BcIiksIHRoaXMuX25vdGlmeSh0aGlzLl9pbml0LCB0LCBcInVuaW5zdGFsbFwiKSksIHI7XG4gIH1cbiAgX25vdGlmeSh0LCBlLCBzLCBuKSB7XG4gICAgbiA9IG4gfHwge307XG4gICAgZm9yIChjb25zdCBvIG9mIHQpIHtcbiAgICAgIGNvbnN0IHIgPSBvLnBsdWdpbiwgYSA9IHJbc10sIGwgPSBbZSwgbiwgby5vcHRpb25zXTtcbiAgICAgIGlmIChJKGEsIGwsIHIpID09PSAhMSAmJiBuLmNhbmNlbGFibGUpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICB9XG4gICAgcmV0dXJuICEwO1xuICB9XG4gIGludmFsaWRhdGUoKSB7XG4gICAgVCh0aGlzLl9jYWNoZSkgfHwgKHRoaXMuX29sZENhY2hlID0gdGhpcy5fY2FjaGUsIHRoaXMuX2NhY2hlID0gdm9pZCAwKTtcbiAgfVxuICBfZGVzY3JpcHRvcnModCkge1xuICAgIGlmICh0aGlzLl9jYWNoZSlcbiAgICAgIHJldHVybiB0aGlzLl9jYWNoZTtcbiAgICBjb25zdCBlID0gdGhpcy5fY2FjaGUgPSB0aGlzLl9jcmVhdGVEZXNjcmlwdG9ycyh0KTtcbiAgICByZXR1cm4gdGhpcy5fbm90aWZ5U3RhdGVDaGFuZ2VzKHQpLCBlO1xuICB9XG4gIF9jcmVhdGVEZXNjcmlwdG9ycyh0LCBlKSB7XG4gICAgY29uc3QgcyA9IHQgJiYgdC5jb25maWcsIG4gPSBDKHMub3B0aW9ucyAmJiBzLm9wdGlvbnMucGx1Z2lucywge30pLCBvID0gZGwocyk7XG4gICAgcmV0dXJuIG4gPT09ICExICYmICFlID8gW10gOiBmbCh0LCBvLCBuLCBlKTtcbiAgfVxuICBfbm90aWZ5U3RhdGVDaGFuZ2VzKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5fb2xkQ2FjaGUgfHwgW10sIHMgPSB0aGlzLl9jYWNoZSwgbiA9IChvLCByKSA9PiBvLmZpbHRlcigoYSkgPT4gIXIuc29tZSgobCkgPT4gYS5wbHVnaW4uaWQgPT09IGwucGx1Z2luLmlkKSk7XG4gICAgdGhpcy5fbm90aWZ5KG4oZSwgcyksIHQsIFwic3RvcFwiKSwgdGhpcy5fbm90aWZ5KG4ocywgZSksIHQsIFwic3RhcnRcIik7XG4gIH1cbn1cbmZ1bmN0aW9uIGRsKGkpIHtcbiAgY29uc3QgdCA9IHt9LCBlID0gW10sIHMgPSBPYmplY3Qua2V5cyhvdC5wbHVnaW5zLml0ZW1zKTtcbiAgZm9yIChsZXQgbyA9IDA7IG8gPCBzLmxlbmd0aDsgbysrKVxuICAgIGUucHVzaChvdC5nZXRQbHVnaW4oc1tvXSkpO1xuICBjb25zdCBuID0gaS5wbHVnaW5zIHx8IFtdO1xuICBmb3IgKGxldCBvID0gMDsgbyA8IG4ubGVuZ3RoOyBvKyspIHtcbiAgICBjb25zdCByID0gbltvXTtcbiAgICBlLmluZGV4T2YocikgPT09IC0xICYmIChlLnB1c2gociksIHRbci5pZF0gPSAhMCk7XG4gIH1cbiAgcmV0dXJuIHsgcGx1Z2luczogZSwgbG9jYWxJZHM6IHQgfTtcbn1cbmZ1bmN0aW9uIHVsKGksIHQpIHtcbiAgcmV0dXJuICF0ICYmIGkgPT09ICExID8gbnVsbCA6IGkgPT09ICEwID8ge30gOiBpO1xufVxuZnVuY3Rpb24gZmwoaSwgeyBwbHVnaW5zOiB0LCBsb2NhbElkczogZSB9LCBzLCBuKSB7XG4gIGNvbnN0IG8gPSBbXSwgciA9IGkuZ2V0Q29udGV4dCgpO1xuICBmb3IgKGNvbnN0IGEgb2YgdCkge1xuICAgIGNvbnN0IGwgPSBhLmlkLCBjID0gdWwoc1tsXSwgbik7XG4gICAgYyAhPT0gbnVsbCAmJiBvLnB1c2goe1xuICAgICAgcGx1Z2luOiBhLFxuICAgICAgb3B0aW9uczogZ2woaS5jb25maWcsIHsgcGx1Z2luOiBhLCBsb2NhbDogZVtsXSB9LCBjLCByKVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBvO1xufVxuZnVuY3Rpb24gZ2woaSwgeyBwbHVnaW46IHQsIGxvY2FsOiBlIH0sIHMsIG4pIHtcbiAgY29uc3QgbyA9IGkucGx1Z2luU2NvcGVLZXlzKHQpLCByID0gaS5nZXRPcHRpb25TY29wZXMocywgbyk7XG4gIHJldHVybiBlICYmIHQuZGVmYXVsdHMgJiYgci5wdXNoKHQuZGVmYXVsdHMpLCBpLmNyZWF0ZVJlc29sdmVyKHIsIG4sIFtcIlwiXSwge1xuICAgIHNjcmlwdGFibGU6ICExLFxuICAgIGluZGV4YWJsZTogITEsXG4gICAgYWxsS2V5czogITBcbiAgfSk7XG59XG5mdW5jdGlvbiBNaShpLCB0KSB7XG4gIGNvbnN0IGUgPSBPLmRhdGFzZXRzW2ldIHx8IHt9O1xuICByZXR1cm4gKCh0LmRhdGFzZXRzIHx8IHt9KVtpXSB8fCB7fSkuaW5kZXhBeGlzIHx8IHQuaW5kZXhBeGlzIHx8IGUuaW5kZXhBeGlzIHx8IFwieFwiO1xufVxuZnVuY3Rpb24gcGwoaSwgdCkge1xuICBsZXQgZSA9IGk7XG4gIHJldHVybiBpID09PSBcIl9pbmRleF9cIiA/IGUgPSB0IDogaSA9PT0gXCJfdmFsdWVfXCIgJiYgKGUgPSB0ID09PSBcInhcIiA/IFwieVwiIDogXCJ4XCIpLCBlO1xufVxuZnVuY3Rpb24gbWwoaSwgdCkge1xuICByZXR1cm4gaSA9PT0gdCA/IFwiX2luZGV4X1wiIDogXCJfdmFsdWVfXCI7XG59XG5mdW5jdGlvbiBibChpKSB7XG4gIGlmIChpID09PSBcInRvcFwiIHx8IGkgPT09IFwiYm90dG9tXCIpXG4gICAgcmV0dXJuIFwieFwiO1xuICBpZiAoaSA9PT0gXCJsZWZ0XCIgfHwgaSA9PT0gXCJyaWdodFwiKVxuICAgIHJldHVybiBcInlcIjtcbn1cbmZ1bmN0aW9uIGtpKGksIHQpIHtcbiAgcmV0dXJuIGkgPT09IFwieFwiIHx8IGkgPT09IFwieVwiID8gaSA6IHQuYXhpcyB8fCBibCh0LnBvc2l0aW9uKSB8fCBpLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpO1xufVxuZnVuY3Rpb24geGwoaSwgdCkge1xuICBjb25zdCBlID0gQXRbaS50eXBlXSB8fCB7IHNjYWxlczoge30gfSwgcyA9IHQuc2NhbGVzIHx8IHt9LCBuID0gTWkoaS50eXBlLCB0KSwgbyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpLCByID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHJldHVybiBPYmplY3Qua2V5cyhzKS5mb3JFYWNoKChhKSA9PiB7XG4gICAgY29uc3QgbCA9IHNbYV07XG4gICAgaWYgKCFEKGwpKVxuICAgICAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoYEludmFsaWQgc2NhbGUgY29uZmlndXJhdGlvbiBmb3Igc2NhbGU6ICR7YX1gKTtcbiAgICBpZiAobC5fcHJveHkpXG4gICAgICByZXR1cm4gY29uc29sZS53YXJuKGBJZ25vcmluZyByZXNvbHZlciBwYXNzZWQgYXMgb3B0aW9ucyBmb3Igc2NhbGU6ICR7YX1gKTtcbiAgICBjb25zdCBjID0ga2koYSwgbCksIGggPSBtbChjLCBuKSwgZCA9IGUuc2NhbGVzIHx8IHt9O1xuICAgIG9bY10gPSBvW2NdIHx8IGEsIHJbYV0gPSBRdCgvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSwgW3sgYXhpczogYyB9LCBsLCBkW2NdLCBkW2hdXSk7XG4gIH0pLCBpLmRhdGEuZGF0YXNldHMuZm9yRWFjaCgoYSkgPT4ge1xuICAgIGNvbnN0IGwgPSBhLnR5cGUgfHwgaS50eXBlLCBjID0gYS5pbmRleEF4aXMgfHwgTWkobCwgdCksIGQgPSAoQXRbbF0gfHwge30pLnNjYWxlcyB8fCB7fTtcbiAgICBPYmplY3Qua2V5cyhkKS5mb3JFYWNoKCh1KSA9PiB7XG4gICAgICBjb25zdCBmID0gcGwodSwgYyksIGcgPSBhW2YgKyBcIkF4aXNJRFwiXSB8fCBvW2ZdIHx8IGY7XG4gICAgICByW2ddID0gcltnXSB8fCAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSwgUXQocltnXSwgW3sgYXhpczogZiB9LCBzW2ddLCBkW3VdXSk7XG4gICAgfSk7XG4gIH0pLCBPYmplY3Qua2V5cyhyKS5mb3JFYWNoKChhKSA9PiB7XG4gICAgY29uc3QgbCA9IHJbYV07XG4gICAgUXQobCwgW08uc2NhbGVzW2wudHlwZV0sIE8uc2NhbGVdKTtcbiAgfSksIHI7XG59XG5mdW5jdGlvbiBHbihpKSB7XG4gIGNvbnN0IHQgPSBpLm9wdGlvbnMgfHwgKGkub3B0aW9ucyA9IHt9KTtcbiAgdC5wbHVnaW5zID0gQyh0LnBsdWdpbnMsIHt9KSwgdC5zY2FsZXMgPSB4bChpLCB0KTtcbn1cbmZ1bmN0aW9uIFpuKGkpIHtcbiAgcmV0dXJuIGkgPSBpIHx8IHt9LCBpLmRhdGFzZXRzID0gaS5kYXRhc2V0cyB8fCBbXSwgaS5sYWJlbHMgPSBpLmxhYmVscyB8fCBbXSwgaTtcbn1cbmZ1bmN0aW9uIF9sKGkpIHtcbiAgcmV0dXJuIGkgPSBpIHx8IHt9LCBpLmRhdGEgPSBabihpLmRhdGEpLCBHbihpKSwgaTtcbn1cbmNvbnN0IFJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgSm4gPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuZnVuY3Rpb24gTGUoaSwgdCkge1xuICBsZXQgZSA9IFJzLmdldChpKTtcbiAgcmV0dXJuIGUgfHwgKGUgPSB0KCksIFJzLnNldChpLCBlKSwgSm4uYWRkKGUpKSwgZTtcbn1cbmNvbnN0IHF0ID0gKGksIHQsIGUpID0+IHtcbiAgY29uc3QgcyA9IF90KHQsIGUpO1xuICBzICE9PSB2b2lkIDAgJiYgaS5hZGQocyk7XG59O1xuY2xhc3MgeWwge1xuICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgdGhpcy5fY29uZmlnID0gX2wodCksIHRoaXMuX3Njb3BlQ2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLCB0aGlzLl9yZXNvbHZlckNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxuICBnZXQgcGxhdGZvcm0oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbmZpZy5wbGF0Zm9ybTtcbiAgfVxuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29uZmlnLnR5cGU7XG4gIH1cbiAgc2V0IHR5cGUodCkge1xuICAgIHRoaXMuX2NvbmZpZy50eXBlID0gdDtcbiAgfVxuICBnZXQgZGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29uZmlnLmRhdGE7XG4gIH1cbiAgc2V0IGRhdGEodCkge1xuICAgIHRoaXMuX2NvbmZpZy5kYXRhID0gWm4odCk7XG4gIH1cbiAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbmZpZy5vcHRpb25zO1xuICB9XG4gIHNldCBvcHRpb25zKHQpIHtcbiAgICB0aGlzLl9jb25maWcub3B0aW9ucyA9IHQ7XG4gIH1cbiAgZ2V0IHBsdWdpbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbmZpZy5wbHVnaW5zO1xuICB9XG4gIHVwZGF0ZSgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fY29uZmlnO1xuICAgIHRoaXMuY2xlYXJDYWNoZSgpLCBHbih0KTtcbiAgfVxuICBjbGVhckNhY2hlKCkge1xuICAgIHRoaXMuX3Njb3BlQ2FjaGUuY2xlYXIoKSwgdGhpcy5fcmVzb2x2ZXJDYWNoZS5jbGVhcigpO1xuICB9XG4gIGRhdGFzZXRTY29wZUtleXModCkge1xuICAgIHJldHVybiBMZShcbiAgICAgIHQsXG4gICAgICAoKSA9PiBbW1xuICAgICAgICBgZGF0YXNldHMuJHt0fWAsXG4gICAgICAgIFwiXCJcbiAgICAgIF1dXG4gICAgKTtcbiAgfVxuICBkYXRhc2V0QW5pbWF0aW9uU2NvcGVLZXlzKHQsIGUpIHtcbiAgICByZXR1cm4gTGUoXG4gICAgICBgJHt0fS50cmFuc2l0aW9uLiR7ZX1gLFxuICAgICAgKCkgPT4gW1xuICAgICAgICBbXG4gICAgICAgICAgYGRhdGFzZXRzLiR7dH0udHJhbnNpdGlvbnMuJHtlfWAsXG4gICAgICAgICAgYHRyYW5zaXRpb25zLiR7ZX1gXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICBgZGF0YXNldHMuJHt0fWAsXG4gICAgICAgICAgXCJcIlxuICAgICAgICBdXG4gICAgICBdXG4gICAgKTtcbiAgfVxuICBkYXRhc2V0RWxlbWVudFNjb3BlS2V5cyh0LCBlKSB7XG4gICAgcmV0dXJuIExlKFxuICAgICAgYCR7dH0tJHtlfWAsXG4gICAgICAoKSA9PiBbW1xuICAgICAgICBgZGF0YXNldHMuJHt0fS5lbGVtZW50cy4ke2V9YCxcbiAgICAgICAgYGRhdGFzZXRzLiR7dH1gLFxuICAgICAgICBgZWxlbWVudHMuJHtlfWAsXG4gICAgICAgIFwiXCJcbiAgICAgIF1dXG4gICAgKTtcbiAgfVxuICBwbHVnaW5TY29wZUtleXModCkge1xuICAgIGNvbnN0IGUgPSB0LmlkLCBzID0gdGhpcy50eXBlO1xuICAgIHJldHVybiBMZShcbiAgICAgIGAke3N9LXBsdWdpbi0ke2V9YCxcbiAgICAgICgpID0+IFtbXG4gICAgICAgIGBwbHVnaW5zLiR7ZX1gLFxuICAgICAgICAuLi50LmFkZGl0aW9uYWxPcHRpb25TY29wZXMgfHwgW11cbiAgICAgIF1dXG4gICAgKTtcbiAgfVxuICBfY2FjaGVkU2NvcGVzKHQsIGUpIHtcbiAgICBjb25zdCBzID0gdGhpcy5fc2NvcGVDYWNoZTtcbiAgICBsZXQgbiA9IHMuZ2V0KHQpO1xuICAgIHJldHVybiAoIW4gfHwgZSkgJiYgKG4gPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLCBzLnNldCh0LCBuKSksIG47XG4gIH1cbiAgZ2V0T3B0aW9uU2NvcGVzKHQsIGUsIHMpIHtcbiAgICBjb25zdCB7IG9wdGlvbnM6IG4sIHR5cGU6IG8gfSA9IHRoaXMsIHIgPSB0aGlzLl9jYWNoZWRTY29wZXModCwgcyksIGEgPSByLmdldChlKTtcbiAgICBpZiAoYSlcbiAgICAgIHJldHVybiBhO1xuICAgIGNvbnN0IGwgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGUuZm9yRWFjaCgoaCkgPT4ge1xuICAgICAgdCAmJiAobC5hZGQodCksIGguZm9yRWFjaCgoZCkgPT4gcXQobCwgdCwgZCkpKSwgaC5mb3JFYWNoKChkKSA9PiBxdChsLCBuLCBkKSksIGguZm9yRWFjaCgoZCkgPT4gcXQobCwgQXRbb10gfHwge30sIGQpKSwgaC5mb3JFYWNoKChkKSA9PiBxdChsLCBPLCBkKSksIGguZm9yRWFjaCgoZCkgPT4gcXQobCwgX2ksIGQpKTtcbiAgICB9KTtcbiAgICBjb25zdCBjID0gQXJyYXkuZnJvbShsKTtcbiAgICByZXR1cm4gYy5sZW5ndGggPT09IDAgJiYgYy5wdXNoKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpKSwgSm4uaGFzKGUpICYmIHIuc2V0KGUsIGMpLCBjO1xuICB9XG4gIGNoYXJ0T3B0aW9uU2NvcGVzKCkge1xuICAgIGNvbnN0IHsgb3B0aW9uczogdCwgdHlwZTogZSB9ID0gdGhpcztcbiAgICByZXR1cm4gW1xuICAgICAgdCxcbiAgICAgIEF0W2VdIHx8IHt9LFxuICAgICAgTy5kYXRhc2V0c1tlXSB8fCB7fSxcbiAgICAgIHsgdHlwZTogZSB9LFxuICAgICAgTyxcbiAgICAgIF9pXG4gICAgXTtcbiAgfVxuICByZXNvbHZlTmFtZWRPcHRpb25zKHQsIGUsIHMsIG4gPSBbXCJcIl0pIHtcbiAgICBjb25zdCBvID0geyAkc2hhcmVkOiAhMCB9LCB7IHJlc29sdmVyOiByLCBzdWJQcmVmaXhlczogYSB9ID0gRXModGhpcy5fcmVzb2x2ZXJDYWNoZSwgdCwgbik7XG4gICAgbGV0IGwgPSByO1xuICAgIGlmIChNbChyLCBlKSkge1xuICAgICAgby4kc2hhcmVkID0gITEsIHMgPSB5dChzKSA/IHMoKSA6IHM7XG4gICAgICBjb25zdCBjID0gdGhpcy5jcmVhdGVSZXNvbHZlcih0LCBzLCBhKTtcbiAgICAgIGwgPSBWdChyLCBzLCBjKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBjIG9mIGUpXG4gICAgICBvW2NdID0gbFtjXTtcbiAgICByZXR1cm4gbztcbiAgfVxuICBjcmVhdGVSZXNvbHZlcih0LCBlLCBzID0gW1wiXCJdLCBuKSB7XG4gICAgY29uc3QgeyByZXNvbHZlcjogbyB9ID0gRXModGhpcy5fcmVzb2x2ZXJDYWNoZSwgdCwgcyk7XG4gICAgcmV0dXJuIEQoZSkgPyBWdChvLCBlLCB2b2lkIDAsIG4pIDogbztcbiAgfVxufVxuZnVuY3Rpb24gRXMoaSwgdCwgZSkge1xuICBsZXQgcyA9IGkuZ2V0KHQpO1xuICBzIHx8IChzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgaS5zZXQodCwgcykpO1xuICBjb25zdCBuID0gZS5qb2luKCk7XG4gIGxldCBvID0gcy5nZXQobik7XG4gIHJldHVybiBvIHx8IChvID0ge1xuICAgIHJlc29sdmVyOiB6aSh0LCBlKSxcbiAgICBzdWJQcmVmaXhlczogZS5maWx0ZXIoKGEpID0+ICFhLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoXCJob3ZlclwiKSlcbiAgfSwgcy5zZXQobiwgbykpLCBvO1xufVxuY29uc3QgdmwgPSAoaSkgPT4gRChpKSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhpKS5yZWR1Y2UoKHQsIGUpID0+IHQgfHwgeXQoaVtlXSksICExKTtcbmZ1bmN0aW9uIE1sKGksIHQpIHtcbiAgY29uc3QgeyBpc1NjcmlwdGFibGU6IGUsIGlzSW5kZXhhYmxlOiBzIH0gPSB3bihpKTtcbiAgZm9yIChjb25zdCBuIG9mIHQpIHtcbiAgICBjb25zdCBvID0gZShuKSwgciA9IHMobiksIGEgPSAociB8fCBvKSAmJiBpW25dO1xuICAgIGlmIChvICYmICh5dChhKSB8fCB2bChhKSkgfHwgciAmJiB6KGEpKVxuICAgICAgcmV0dXJuICEwO1xuICB9XG4gIHJldHVybiAhMTtcbn1cbnZhciBrbCA9IFwiMy45LjFcIjtcbmNvbnN0IHdsID0gW1widG9wXCIsIFwiYm90dG9tXCIsIFwibGVmdFwiLCBcInJpZ2h0XCIsIFwiY2hhcnRBcmVhXCJdO1xuZnVuY3Rpb24gRnMoaSwgdCkge1xuICByZXR1cm4gaSA9PT0gXCJ0b3BcIiB8fCBpID09PSBcImJvdHRvbVwiIHx8IHdsLmluZGV4T2YoaSkgPT09IC0xICYmIHQgPT09IFwieFwiO1xufVxuZnVuY3Rpb24gSXMoaSwgdCkge1xuICByZXR1cm4gZnVuY3Rpb24oZSwgcykge1xuICAgIHJldHVybiBlW2ldID09PSBzW2ldID8gZVt0XSAtIHNbdF0gOiBlW2ldIC0gc1tpXTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHpzKGkpIHtcbiAgY29uc3QgdCA9IGkuY2hhcnQsIGUgPSB0Lm9wdGlvbnMuYW5pbWF0aW9uO1xuICB0Lm5vdGlmeVBsdWdpbnMoXCJhZnRlclJlbmRlclwiKSwgSShlICYmIGUub25Db21wbGV0ZSwgW2ldLCB0KTtcbn1cbmZ1bmN0aW9uIFNsKGkpIHtcbiAgY29uc3QgdCA9IGkuY2hhcnQsIGUgPSB0Lm9wdGlvbnMuYW5pbWF0aW9uO1xuICBJKGUgJiYgZS5vblByb2dyZXNzLCBbaV0sIHQpO1xufVxuZnVuY3Rpb24gUW4oaSkge1xuICByZXR1cm4gQW4oKSAmJiB0eXBlb2YgaSA9PSBcInN0cmluZ1wiID8gaSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGkpIDogaSAmJiBpLmxlbmd0aCAmJiAoaSA9IGlbMF0pLCBpICYmIGkuY2FudmFzICYmIChpID0gaS5jYW52YXMpLCBpO1xufVxuY29uc3QgJGUgPSB7fSwgdG8gPSAoaSkgPT4ge1xuICBjb25zdCB0ID0gUW4oaSk7XG4gIHJldHVybiBPYmplY3QudmFsdWVzKCRlKS5maWx0ZXIoKGUpID0+IGUuY2FudmFzID09PSB0KS5wb3AoKTtcbn07XG5mdW5jdGlvbiBQbChpLCB0LCBlKSB7XG4gIGNvbnN0IHMgPSBPYmplY3Qua2V5cyhpKTtcbiAgZm9yIChjb25zdCBuIG9mIHMpIHtcbiAgICBjb25zdCBvID0gK247XG4gICAgaWYgKG8gPj0gdCkge1xuICAgICAgY29uc3QgciA9IGlbbl07XG4gICAgICBkZWxldGUgaVtuXSwgKGUgPiAwIHx8IG8gPiB0KSAmJiAoaVtvICsgZV0gPSByKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIENsKGksIHQsIGUsIHMpIHtcbiAgcmV0dXJuICFlIHx8IGkudHlwZSA9PT0gXCJtb3VzZW91dFwiID8gbnVsbCA6IHMgPyB0IDogaTtcbn1cbmNsYXNzIGppIHtcbiAgY29uc3RydWN0b3IodCwgZSkge1xuICAgIGNvbnN0IHMgPSB0aGlzLmNvbmZpZyA9IG5ldyB5bChlKSwgbiA9IFFuKHQpLCBvID0gdG8obik7XG4gICAgaWYgKG8pXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiQ2FudmFzIGlzIGFscmVhZHkgaW4gdXNlLiBDaGFydCB3aXRoIElEICdcIiArIG8uaWQgKyBcIicgbXVzdCBiZSBkZXN0cm95ZWQgYmVmb3JlIHRoZSBjYW52YXMgd2l0aCBJRCAnXCIgKyBvLmNhbnZhcy5pZCArIFwiJyBjYW4gYmUgcmV1c2VkLlwiXG4gICAgICApO1xuICAgIGNvbnN0IHIgPSBzLmNyZWF0ZVJlc29sdmVyKHMuY2hhcnRPcHRpb25TY29wZXMoKSwgdGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIHRoaXMucGxhdGZvcm0gPSBuZXcgKHMucGxhdGZvcm0gfHwgcW4obikpKCksIHRoaXMucGxhdGZvcm0udXBkYXRlQ29uZmlnKHMpO1xuICAgIGNvbnN0IGEgPSB0aGlzLnBsYXRmb3JtLmFjcXVpcmVDb250ZXh0KG4sIHIuYXNwZWN0UmF0aW8pLCBsID0gYSAmJiBhLmNhbnZhcywgYyA9IGwgJiYgbC5oZWlnaHQsIGggPSBsICYmIGwud2lkdGg7XG4gICAgaWYgKHRoaXMuaWQgPSBfbygpLCB0aGlzLmN0eCA9IGEsIHRoaXMuY2FudmFzID0gbCwgdGhpcy53aWR0aCA9IGgsIHRoaXMuaGVpZ2h0ID0gYywgdGhpcy5fb3B0aW9ucyA9IHIsIHRoaXMuX2FzcGVjdFJhdGlvID0gdGhpcy5hc3BlY3RSYXRpbywgdGhpcy5fbGF5ZXJzID0gW10sIHRoaXMuX21ldGFzZXRzID0gW10sIHRoaXMuX3N0YWNrcyA9IHZvaWQgMCwgdGhpcy5ib3hlcyA9IFtdLCB0aGlzLmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvID0gdm9pZCAwLCB0aGlzLmNoYXJ0QXJlYSA9IHZvaWQgMCwgdGhpcy5fYWN0aXZlID0gW10sIHRoaXMuX2xhc3RFdmVudCA9IHZvaWQgMCwgdGhpcy5fbGlzdGVuZXJzID0ge30sIHRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnMgPSB2b2lkIDAsIHRoaXMuX3NvcnRlZE1ldGFzZXRzID0gW10sIHRoaXMuc2NhbGVzID0ge30sIHRoaXMuX3BsdWdpbnMgPSBuZXcgaGwoKSwgdGhpcy4kcHJveGllcyA9IHt9LCB0aGlzLl9oaWRkZW5JbmRpY2VzID0ge30sIHRoaXMuYXR0YWNoZWQgPSAhMSwgdGhpcy5fYW5pbWF0aW9uc0Rpc2FibGVkID0gdm9pZCAwLCB0aGlzLiRjb250ZXh0ID0gdm9pZCAwLCB0aGlzLl9kb1Jlc2l6ZSA9IEZvKChkKSA9PiB0aGlzLnVwZGF0ZShkKSwgci5yZXNpemVEZWxheSB8fCAwKSwgdGhpcy5fZGF0YUNoYW5nZXMgPSBbXSwgJGVbdGhpcy5pZF0gPSB0aGlzLCAhYSB8fCAhbCkge1xuICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBjcmVhdGUgY2hhcnQ6IGNhbid0IGFjcXVpcmUgY29udGV4dCBmcm9tIHRoZSBnaXZlbiBpdGVtXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhdC5saXN0ZW4odGhpcywgXCJjb21wbGV0ZVwiLCB6cyksIGF0Lmxpc3Rlbih0aGlzLCBcInByb2dyZXNzXCIsIFNsKSwgdGhpcy5faW5pdGlhbGl6ZSgpLCB0aGlzLmF0dGFjaGVkICYmIHRoaXMudXBkYXRlKCk7XG4gIH1cbiAgZ2V0IGFzcGVjdFJhdGlvKCkge1xuICAgIGNvbnN0IHsgb3B0aW9uczogeyBhc3BlY3RSYXRpbzogdCwgbWFpbnRhaW5Bc3BlY3RSYXRpbzogZSB9LCB3aWR0aDogcywgaGVpZ2h0OiBuLCBfYXNwZWN0UmF0aW86IG8gfSA9IHRoaXM7XG4gICAgcmV0dXJuIFQodCkgPyBlICYmIG8gPyBvIDogbiA/IHMgLyBuIDogbnVsbCA6IHQ7XG4gIH1cbiAgZ2V0IGRhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLmRhdGE7XG4gIH1cbiAgc2V0IGRhdGEodCkge1xuICAgIHRoaXMuY29uZmlnLmRhdGEgPSB0O1xuICB9XG4gIGdldCBvcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl9vcHRpb25zO1xuICB9XG4gIHNldCBvcHRpb25zKHQpIHtcbiAgICB0aGlzLmNvbmZpZy5vcHRpb25zID0gdDtcbiAgfVxuICBfaW5pdGlhbGl6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5ub3RpZnlQbHVnaW5zKFwiYmVmb3JlSW5pdFwiKSwgdGhpcy5vcHRpb25zLnJlc3BvbnNpdmUgPyB0aGlzLnJlc2l6ZSgpIDogbHModGhpcywgdGhpcy5vcHRpb25zLmRldmljZVBpeGVsUmF0aW8pLCB0aGlzLmJpbmRFdmVudHMoKSwgdGhpcy5ub3RpZnlQbHVnaW5zKFwiYWZ0ZXJJbml0XCIpLCB0aGlzO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIHJldHVybiBvcyh0aGlzLmNhbnZhcywgdGhpcy5jdHgpLCB0aGlzO1xuICB9XG4gIHN0b3AoKSB7XG4gICAgcmV0dXJuIGF0LnN0b3AodGhpcyksIHRoaXM7XG4gIH1cbiAgcmVzaXplKHQsIGUpIHtcbiAgICBhdC5ydW5uaW5nKHRoaXMpID8gdGhpcy5fcmVzaXplQmVmb3JlRHJhdyA9IHsgd2lkdGg6IHQsIGhlaWdodDogZSB9IDogdGhpcy5fcmVzaXplKHQsIGUpO1xuICB9XG4gIF9yZXNpemUodCwgZSkge1xuICAgIGNvbnN0IHMgPSB0aGlzLm9wdGlvbnMsIG4gPSB0aGlzLmNhbnZhcywgbyA9IHMubWFpbnRhaW5Bc3BlY3RSYXRpbyAmJiB0aGlzLmFzcGVjdFJhdGlvLCByID0gdGhpcy5wbGF0Zm9ybS5nZXRNYXhpbXVtU2l6ZShuLCB0LCBlLCBvKSwgYSA9IHMuZGV2aWNlUGl4ZWxSYXRpbyB8fCB0aGlzLnBsYXRmb3JtLmdldERldmljZVBpeGVsUmF0aW8oKSwgbCA9IHRoaXMud2lkdGggPyBcInJlc2l6ZVwiIDogXCJhdHRhY2hcIjtcbiAgICB0aGlzLndpZHRoID0gci53aWR0aCwgdGhpcy5oZWlnaHQgPSByLmhlaWdodCwgdGhpcy5fYXNwZWN0UmF0aW8gPSB0aGlzLmFzcGVjdFJhdGlvLCBscyh0aGlzLCBhLCAhMCkgJiYgKHRoaXMubm90aWZ5UGx1Z2lucyhcInJlc2l6ZVwiLCB7IHNpemU6IHIgfSksIEkocy5vblJlc2l6ZSwgW3RoaXMsIHJdLCB0aGlzKSwgdGhpcy5hdHRhY2hlZCAmJiB0aGlzLl9kb1Jlc2l6ZShsKSAmJiB0aGlzLnJlbmRlcigpKTtcbiAgfVxuICBlbnN1cmVTY2FsZXNIYXZlSURzKCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLm9wdGlvbnMuc2NhbGVzIHx8IHt9O1xuICAgIEUoZSwgKHMsIG4pID0+IHtcbiAgICAgIHMuaWQgPSBuO1xuICAgIH0pO1xuICB9XG4gIGJ1aWxkT3JVcGRhdGVTY2FsZXMoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMub3B0aW9ucywgZSA9IHQuc2NhbGVzLCBzID0gdGhpcy5zY2FsZXMsIG4gPSBPYmplY3Qua2V5cyhzKS5yZWR1Y2UoKHIsIGEpID0+IChyW2FdID0gITEsIHIpLCB7fSk7XG4gICAgbGV0IG8gPSBbXTtcbiAgICBlICYmIChvID0gby5jb25jYXQoXG4gICAgICBPYmplY3Qua2V5cyhlKS5tYXAoKHIpID0+IHtcbiAgICAgICAgY29uc3QgYSA9IGVbcl0sIGwgPSBraShyLCBhKSwgYyA9IGwgPT09IFwiclwiLCBoID0gbCA9PT0gXCJ4XCI7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgb3B0aW9uczogYSxcbiAgICAgICAgICBkcG9zaXRpb246IGMgPyBcImNoYXJ0QXJlYVwiIDogaCA/IFwiYm90dG9tXCIgOiBcImxlZnRcIixcbiAgICAgICAgICBkdHlwZTogYyA/IFwicmFkaWFsTGluZWFyXCIgOiBoID8gXCJjYXRlZ29yeVwiIDogXCJsaW5lYXJcIlxuICAgICAgICB9O1xuICAgICAgfSlcbiAgICApKSwgRShvLCAocikgPT4ge1xuICAgICAgY29uc3QgYSA9IHIub3B0aW9ucywgbCA9IGEuaWQsIGMgPSBraShsLCBhKSwgaCA9IEMoYS50eXBlLCByLmR0eXBlKTtcbiAgICAgIChhLnBvc2l0aW9uID09PSB2b2lkIDAgfHwgRnMoYS5wb3NpdGlvbiwgYykgIT09IEZzKHIuZHBvc2l0aW9uKSkgJiYgKGEucG9zaXRpb24gPSByLmRwb3NpdGlvbiksIG5bbF0gPSAhMDtcbiAgICAgIGxldCBkID0gbnVsbDtcbiAgICAgIGlmIChsIGluIHMgJiYgc1tsXS50eXBlID09PSBoKVxuICAgICAgICBkID0gc1tsXTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBjb25zdCB1ID0gb3QuZ2V0U2NhbGUoaCk7XG4gICAgICAgIGQgPSBuZXcgdSh7XG4gICAgICAgICAgaWQ6IGwsXG4gICAgICAgICAgdHlwZTogaCxcbiAgICAgICAgICBjdHg6IHRoaXMuY3R4LFxuICAgICAgICAgIGNoYXJ0OiB0aGlzXG4gICAgICAgIH0pLCBzW2QuaWRdID0gZDtcbiAgICAgIH1cbiAgICAgIGQuaW5pdChhLCB0KTtcbiAgICB9KSwgRShuLCAociwgYSkgPT4ge1xuICAgICAgciB8fCBkZWxldGUgc1thXTtcbiAgICB9KSwgRShzLCAocikgPT4ge1xuICAgICAgWC5jb25maWd1cmUodGhpcywgciwgci5vcHRpb25zKSwgWC5hZGRCb3godGhpcywgcik7XG4gICAgfSk7XG4gIH1cbiAgX3VwZGF0ZU1ldGFzZXRzKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9tZXRhc2V0cywgZSA9IHRoaXMuZGF0YS5kYXRhc2V0cy5sZW5ndGgsIHMgPSB0Lmxlbmd0aDtcbiAgICBpZiAodC5zb3J0KChuLCBvKSA9PiBuLmluZGV4IC0gby5pbmRleCksIHMgPiBlKSB7XG4gICAgICBmb3IgKGxldCBuID0gZTsgbiA8IHM7ICsrbilcbiAgICAgICAgdGhpcy5fZGVzdHJveURhdGFzZXRNZXRhKG4pO1xuICAgICAgdC5zcGxpY2UoZSwgcyAtIGUpO1xuICAgIH1cbiAgICB0aGlzLl9zb3J0ZWRNZXRhc2V0cyA9IHQuc2xpY2UoMCkuc29ydChJcyhcIm9yZGVyXCIsIFwiaW5kZXhcIikpO1xuICB9XG4gIF9yZW1vdmVVbnJlZmVyZW5jZWRNZXRhc2V0cygpIHtcbiAgICBjb25zdCB7IF9tZXRhc2V0czogdCwgZGF0YTogeyBkYXRhc2V0czogZSB9IH0gPSB0aGlzO1xuICAgIHQubGVuZ3RoID4gZS5sZW5ndGggJiYgZGVsZXRlIHRoaXMuX3N0YWNrcywgdC5mb3JFYWNoKChzLCBuKSA9PiB7XG4gICAgICBlLmZpbHRlcigobykgPT4gbyA9PT0gcy5fZGF0YXNldCkubGVuZ3RoID09PSAwICYmIHRoaXMuX2Rlc3Ryb3lEYXRhc2V0TWV0YShuKTtcbiAgICB9KTtcbiAgfVxuICBidWlsZE9yVXBkYXRlQ29udHJvbGxlcnMoKSB7XG4gICAgY29uc3QgdCA9IFtdLCBlID0gdGhpcy5kYXRhLmRhdGFzZXRzO1xuICAgIGxldCBzLCBuO1xuICAgIGZvciAodGhpcy5fcmVtb3ZlVW5yZWZlcmVuY2VkTWV0YXNldHMoKSwgcyA9IDAsIG4gPSBlLmxlbmd0aDsgcyA8IG47IHMrKykge1xuICAgICAgY29uc3QgbyA9IGVbc107XG4gICAgICBsZXQgciA9IHRoaXMuZ2V0RGF0YXNldE1ldGEocyk7XG4gICAgICBjb25zdCBhID0gby50eXBlIHx8IHRoaXMuY29uZmlnLnR5cGU7XG4gICAgICBpZiAoci50eXBlICYmIHIudHlwZSAhPT0gYSAmJiAodGhpcy5fZGVzdHJveURhdGFzZXRNZXRhKHMpLCByID0gdGhpcy5nZXREYXRhc2V0TWV0YShzKSksIHIudHlwZSA9IGEsIHIuaW5kZXhBeGlzID0gby5pbmRleEF4aXMgfHwgTWkoYSwgdGhpcy5vcHRpb25zKSwgci5vcmRlciA9IG8ub3JkZXIgfHwgMCwgci5pbmRleCA9IHMsIHIubGFiZWwgPSBcIlwiICsgby5sYWJlbCwgci52aXNpYmxlID0gdGhpcy5pc0RhdGFzZXRWaXNpYmxlKHMpLCByLmNvbnRyb2xsZXIpXG4gICAgICAgIHIuY29udHJvbGxlci51cGRhdGVJbmRleChzKSwgci5jb250cm9sbGVyLmxpbmtTY2FsZXMoKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBsID0gb3QuZ2V0Q29udHJvbGxlcihhKSwgeyBkYXRhc2V0RWxlbWVudFR5cGU6IGMsIGRhdGFFbGVtZW50VHlwZTogaCB9ID0gTy5kYXRhc2V0c1thXTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihsLnByb3RvdHlwZSwge1xuICAgICAgICAgIGRhdGFFbGVtZW50VHlwZTogb3QuZ2V0RWxlbWVudChoKSxcbiAgICAgICAgICBkYXRhc2V0RWxlbWVudFR5cGU6IGMgJiYgb3QuZ2V0RWxlbWVudChjKVxuICAgICAgICB9KSwgci5jb250cm9sbGVyID0gbmV3IGwodGhpcywgcyksIHQucHVzaChyLmNvbnRyb2xsZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fdXBkYXRlTWV0YXNldHMoKSwgdDtcbiAgfVxuICBfcmVzZXRFbGVtZW50cygpIHtcbiAgICBFKHRoaXMuZGF0YS5kYXRhc2V0cywgKHQsIGUpID0+IHtcbiAgICAgIHRoaXMuZ2V0RGF0YXNldE1ldGEoZSkuY29udHJvbGxlci5yZXNldCgpO1xuICAgIH0sIHRoaXMpO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHRoaXMuX3Jlc2V0RWxlbWVudHMoKSwgdGhpcy5ub3RpZnlQbHVnaW5zKFwicmVzZXRcIik7XG4gIH1cbiAgdXBkYXRlKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5jb25maWc7XG4gICAgZS51cGRhdGUoKTtcbiAgICBjb25zdCBzID0gdGhpcy5fb3B0aW9ucyA9IGUuY3JlYXRlUmVzb2x2ZXIoZS5jaGFydE9wdGlvblNjb3BlcygpLCB0aGlzLmdldENvbnRleHQoKSksIG4gPSB0aGlzLl9hbmltYXRpb25zRGlzYWJsZWQgPSAhcy5hbmltYXRpb247XG4gICAgaWYgKHRoaXMuX3VwZGF0ZVNjYWxlcygpLCB0aGlzLl9jaGVja0V2ZW50QmluZGluZ3MoKSwgdGhpcy5fdXBkYXRlSGlkZGVuSW5kaWNlcygpLCB0aGlzLl9wbHVnaW5zLmludmFsaWRhdGUoKSwgdGhpcy5ub3RpZnlQbHVnaW5zKFwiYmVmb3JlVXBkYXRlXCIsIHsgbW9kZTogdCwgY2FuY2VsYWJsZTogITAgfSkgPT09ICExKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG8gPSB0aGlzLmJ1aWxkT3JVcGRhdGVDb250cm9sbGVycygpO1xuICAgIHRoaXMubm90aWZ5UGx1Z2lucyhcImJlZm9yZUVsZW1lbnRzVXBkYXRlXCIpO1xuICAgIGxldCByID0gMDtcbiAgICBmb3IgKGxldCBjID0gMCwgaCA9IHRoaXMuZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGMgPCBoOyBjKyspIHtcbiAgICAgIGNvbnN0IHsgY29udHJvbGxlcjogZCB9ID0gdGhpcy5nZXREYXRhc2V0TWV0YShjKSwgdSA9ICFuICYmIG8uaW5kZXhPZihkKSA9PT0gLTE7XG4gICAgICBkLmJ1aWxkT3JVcGRhdGVFbGVtZW50cyh1KSwgciA9IE1hdGgubWF4KCtkLmdldE1heE92ZXJmbG93KCksIHIpO1xuICAgIH1cbiAgICByID0gdGhpcy5fbWluUGFkZGluZyA9IHMubGF5b3V0LmF1dG9QYWRkaW5nID8gciA6IDAsIHRoaXMuX3VwZGF0ZUxheW91dChyKSwgbiB8fCBFKG8sIChjKSA9PiB7XG4gICAgICBjLnJlc2V0KCk7XG4gICAgfSksIHRoaXMuX3VwZGF0ZURhdGFzZXRzKHQpLCB0aGlzLm5vdGlmeVBsdWdpbnMoXCJhZnRlclVwZGF0ZVwiLCB7IG1vZGU6IHQgfSksIHRoaXMuX2xheWVycy5zb3J0KElzKFwielwiLCBcIl9pZHhcIikpO1xuICAgIGNvbnN0IHsgX2FjdGl2ZTogYSwgX2xhc3RFdmVudDogbCB9ID0gdGhpcztcbiAgICBsID8gdGhpcy5fZXZlbnRIYW5kbGVyKGwsICEwKSA6IGEubGVuZ3RoICYmIHRoaXMuX3VwZGF0ZUhvdmVyU3R5bGVzKGEsIGEsICEwKSwgdGhpcy5yZW5kZXIoKTtcbiAgfVxuICBfdXBkYXRlU2NhbGVzKCkge1xuICAgIEUodGhpcy5zY2FsZXMsICh0KSA9PiB7XG4gICAgICBYLnJlbW92ZUJveCh0aGlzLCB0KTtcbiAgICB9KSwgdGhpcy5lbnN1cmVTY2FsZXNIYXZlSURzKCksIHRoaXMuYnVpbGRPclVwZGF0ZVNjYWxlcygpO1xuICB9XG4gIF9jaGVja0V2ZW50QmluZGluZ3MoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMub3B0aW9ucywgZSA9IG5ldyBTZXQoT2JqZWN0LmtleXModGhpcy5fbGlzdGVuZXJzKSksIHMgPSBuZXcgU2V0KHQuZXZlbnRzKTtcbiAgICAoIVVpKGUsIHMpIHx8ICEhdGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycyAhPT0gdC5yZXNwb25zaXZlKSAmJiAodGhpcy51bmJpbmRFdmVudHMoKSwgdGhpcy5iaW5kRXZlbnRzKCkpO1xuICB9XG4gIF91cGRhdGVIaWRkZW5JbmRpY2VzKCkge1xuICAgIGNvbnN0IHsgX2hpZGRlbkluZGljZXM6IHQgfSA9IHRoaXMsIGUgPSB0aGlzLl9nZXRVbmlmb3JtRGF0YUNoYW5nZXMoKSB8fCBbXTtcbiAgICBmb3IgKGNvbnN0IHsgbWV0aG9kOiBzLCBzdGFydDogbiwgY291bnQ6IG8gfSBvZiBlKSB7XG4gICAgICBjb25zdCByID0gcyA9PT0gXCJfcmVtb3ZlRWxlbWVudHNcIiA/IC1vIDogbztcbiAgICAgIFBsKHQsIG4sIHIpO1xuICAgIH1cbiAgfVxuICBfZ2V0VW5pZm9ybURhdGFDaGFuZ2VzKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9kYXRhQ2hhbmdlcztcbiAgICBpZiAoIXQgfHwgIXQubGVuZ3RoKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX2RhdGFDaGFuZ2VzID0gW107XG4gICAgY29uc3QgZSA9IHRoaXMuZGF0YS5kYXRhc2V0cy5sZW5ndGgsIHMgPSAobykgPT4gbmV3IFNldChcbiAgICAgIHQuZmlsdGVyKChyKSA9PiByWzBdID09PSBvKS5tYXAoKHIsIGEpID0+IGEgKyBcIixcIiArIHIuc3BsaWNlKDEpLmpvaW4oXCIsXCIpKVxuICAgICksIG4gPSBzKDApO1xuICAgIGZvciAobGV0IG8gPSAxOyBvIDwgZTsgbysrKVxuICAgICAgaWYgKCFVaShuLCBzKG8pKSlcbiAgICAgICAgcmV0dXJuO1xuICAgIHJldHVybiBBcnJheS5mcm9tKG4pLm1hcCgobykgPT4gby5zcGxpdChcIixcIikpLm1hcCgobykgPT4gKHsgbWV0aG9kOiBvWzFdLCBzdGFydDogK29bMl0sIGNvdW50OiArb1szXSB9KSk7XG4gIH1cbiAgX3VwZGF0ZUxheW91dCh0KSB7XG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucyhcImJlZm9yZUxheW91dFwiLCB7IGNhbmNlbGFibGU6ICEwIH0pID09PSAhMSlcbiAgICAgIHJldHVybjtcbiAgICBYLnVwZGF0ZSh0aGlzLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgdCk7XG4gICAgY29uc3QgZSA9IHRoaXMuY2hhcnRBcmVhLCBzID0gZS53aWR0aCA8PSAwIHx8IGUuaGVpZ2h0IDw9IDA7XG4gICAgdGhpcy5fbGF5ZXJzID0gW10sIEUodGhpcy5ib3hlcywgKG4pID0+IHtcbiAgICAgIHMgJiYgbi5wb3NpdGlvbiA9PT0gXCJjaGFydEFyZWFcIiB8fCAobi5jb25maWd1cmUgJiYgbi5jb25maWd1cmUoKSwgdGhpcy5fbGF5ZXJzLnB1c2goLi4ubi5fbGF5ZXJzKCkpKTtcbiAgICB9LCB0aGlzKSwgdGhpcy5fbGF5ZXJzLmZvckVhY2goKG4sIG8pID0+IHtcbiAgICAgIG4uX2lkeCA9IG87XG4gICAgfSksIHRoaXMubm90aWZ5UGx1Z2lucyhcImFmdGVyTGF5b3V0XCIpO1xuICB9XG4gIF91cGRhdGVEYXRhc2V0cyh0KSB7XG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucyhcImJlZm9yZURhdGFzZXRzVXBkYXRlXCIsIHsgbW9kZTogdCwgY2FuY2VsYWJsZTogITAgfSkgIT09ICExKSB7XG4gICAgICBmb3IgKGxldCBlID0gMCwgcyA9IHRoaXMuZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGUgPCBzOyArK2UpXG4gICAgICAgIHRoaXMuZ2V0RGF0YXNldE1ldGEoZSkuY29udHJvbGxlci5jb25maWd1cmUoKTtcbiAgICAgIGZvciAobGV0IGUgPSAwLCBzID0gdGhpcy5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgZSA8IHM7ICsrZSlcbiAgICAgICAgdGhpcy5fdXBkYXRlRGF0YXNldChlLCB5dCh0KSA/IHQoeyBkYXRhc2V0SW5kZXg6IGUgfSkgOiB0KTtcbiAgICAgIHRoaXMubm90aWZ5UGx1Z2lucyhcImFmdGVyRGF0YXNldHNVcGRhdGVcIiwgeyBtb2RlOiB0IH0pO1xuICAgIH1cbiAgfVxuICBfdXBkYXRlRGF0YXNldCh0LCBlKSB7XG4gICAgY29uc3QgcyA9IHRoaXMuZ2V0RGF0YXNldE1ldGEodCksIG4gPSB7IG1ldGE6IHMsIGluZGV4OiB0LCBtb2RlOiBlLCBjYW5jZWxhYmxlOiAhMCB9O1xuICAgIHRoaXMubm90aWZ5UGx1Z2lucyhcImJlZm9yZURhdGFzZXRVcGRhdGVcIiwgbikgIT09ICExICYmIChzLmNvbnRyb2xsZXIuX3VwZGF0ZShlKSwgbi5jYW5jZWxhYmxlID0gITEsIHRoaXMubm90aWZ5UGx1Z2lucyhcImFmdGVyRGF0YXNldFVwZGF0ZVwiLCBuKSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMubm90aWZ5UGx1Z2lucyhcImJlZm9yZVJlbmRlclwiLCB7IGNhbmNlbGFibGU6ICEwIH0pICE9PSAhMSAmJiAoYXQuaGFzKHRoaXMpID8gdGhpcy5hdHRhY2hlZCAmJiAhYXQucnVubmluZyh0aGlzKSAmJiBhdC5zdGFydCh0aGlzKSA6ICh0aGlzLmRyYXcoKSwgenMoeyBjaGFydDogdGhpcyB9KSkpO1xuICB9XG4gIGRyYXcoKSB7XG4gICAgbGV0IHQ7XG4gICAgaWYgKHRoaXMuX3Jlc2l6ZUJlZm9yZURyYXcpIHtcbiAgICAgIGNvbnN0IHsgd2lkdGg6IHMsIGhlaWdodDogbiB9ID0gdGhpcy5fcmVzaXplQmVmb3JlRHJhdztcbiAgICAgIHRoaXMuX3Jlc2l6ZShzLCBuKSwgdGhpcy5fcmVzaXplQmVmb3JlRHJhdyA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLmNsZWFyKCksIHRoaXMud2lkdGggPD0gMCB8fCB0aGlzLmhlaWdodCA8PSAwIHx8IHRoaXMubm90aWZ5UGx1Z2lucyhcImJlZm9yZURyYXdcIiwgeyBjYW5jZWxhYmxlOiAhMCB9KSA9PT0gITEpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZSA9IHRoaXMuX2xheWVycztcbiAgICBmb3IgKHQgPSAwOyB0IDwgZS5sZW5ndGggJiYgZVt0XS56IDw9IDA7ICsrdClcbiAgICAgIGVbdF0uZHJhdyh0aGlzLmNoYXJ0QXJlYSk7XG4gICAgZm9yICh0aGlzLl9kcmF3RGF0YXNldHMoKTsgdCA8IGUubGVuZ3RoOyArK3QpXG4gICAgICBlW3RdLmRyYXcodGhpcy5jaGFydEFyZWEpO1xuICAgIHRoaXMubm90aWZ5UGx1Z2lucyhcImFmdGVyRHJhd1wiKTtcbiAgfVxuICBfZ2V0U29ydGVkRGF0YXNldE1ldGFzKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5fc29ydGVkTWV0YXNldHMsIHMgPSBbXTtcbiAgICBsZXQgbiwgbztcbiAgICBmb3IgKG4gPSAwLCBvID0gZS5sZW5ndGg7IG4gPCBvOyArK24pIHtcbiAgICAgIGNvbnN0IHIgPSBlW25dO1xuICAgICAgKCF0IHx8IHIudmlzaWJsZSkgJiYgcy5wdXNoKHIpO1xuICAgIH1cbiAgICByZXR1cm4gcztcbiAgfVxuICBnZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRTb3J0ZWREYXRhc2V0TWV0YXMoITApO1xuICB9XG4gIF9kcmF3RGF0YXNldHMoKSB7XG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucyhcImJlZm9yZURhdGFzZXRzRHJhd1wiLCB7IGNhbmNlbGFibGU6ICEwIH0pID09PSAhMSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB0ID0gdGhpcy5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCk7XG4gICAgZm9yIChsZXQgZSA9IHQubGVuZ3RoIC0gMTsgZSA+PSAwOyAtLWUpXG4gICAgICB0aGlzLl9kcmF3RGF0YXNldCh0W2VdKTtcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoXCJhZnRlckRhdGFzZXRzRHJhd1wiKTtcbiAgfVxuICBfZHJhd0RhdGFzZXQodCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLmN0eCwgcyA9IHQuX2NsaXAsIG4gPSAhcy5kaXNhYmxlZCwgbyA9IHRoaXMuY2hhcnRBcmVhLCByID0ge1xuICAgICAgbWV0YTogdCxcbiAgICAgIGluZGV4OiB0LmluZGV4LFxuICAgICAgY2FuY2VsYWJsZTogITBcbiAgICB9O1xuICAgIHRoaXMubm90aWZ5UGx1Z2lucyhcImJlZm9yZURhdGFzZXREcmF3XCIsIHIpICE9PSAhMSAmJiAobiAmJiBYZShlLCB7XG4gICAgICBsZWZ0OiBzLmxlZnQgPT09ICExID8gMCA6IG8ubGVmdCAtIHMubGVmdCxcbiAgICAgIHJpZ2h0OiBzLnJpZ2h0ID09PSAhMSA/IHRoaXMud2lkdGggOiBvLnJpZ2h0ICsgcy5yaWdodCxcbiAgICAgIHRvcDogcy50b3AgPT09ICExID8gMCA6IG8udG9wIC0gcy50b3AsXG4gICAgICBib3R0b206IHMuYm90dG9tID09PSAhMSA/IHRoaXMuaGVpZ2h0IDogby5ib3R0b20gKyBzLmJvdHRvbVxuICAgIH0pLCB0LmNvbnRyb2xsZXIuZHJhdygpLCBuICYmIFVlKGUpLCByLmNhbmNlbGFibGUgPSAhMSwgdGhpcy5ub3RpZnlQbHVnaW5zKFwiYWZ0ZXJEYXRhc2V0RHJhd1wiLCByKSk7XG4gIH1cbiAgaXNQb2ludEluQXJlYSh0KSB7XG4gICAgcmV0dXJuIHJlKHQsIHRoaXMuY2hhcnRBcmVhLCB0aGlzLl9taW5QYWRkaW5nKTtcbiAgfVxuICBnZXRFbGVtZW50c0F0RXZlbnRGb3JNb2RlKHQsIGUsIHMsIG4pIHtcbiAgICBjb25zdCBvID0gSG4ubW9kZXNbZV07XG4gICAgcmV0dXJuIHR5cGVvZiBvID09IFwiZnVuY3Rpb25cIiA/IG8odGhpcywgdCwgcywgbikgOiBbXTtcbiAgfVxuICBnZXREYXRhc2V0TWV0YSh0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuZGF0YS5kYXRhc2V0c1t0XSwgcyA9IHRoaXMuX21ldGFzZXRzO1xuICAgIGxldCBuID0gcy5maWx0ZXIoKG8pID0+IG8gJiYgby5fZGF0YXNldCA9PT0gZSkucG9wKCk7XG4gICAgcmV0dXJuIG4gfHwgKG4gPSB7XG4gICAgICB0eXBlOiBudWxsLFxuICAgICAgZGF0YTogW10sXG4gICAgICBkYXRhc2V0OiBudWxsLFxuICAgICAgY29udHJvbGxlcjogbnVsbCxcbiAgICAgIGhpZGRlbjogbnVsbCxcbiAgICAgIHhBeGlzSUQ6IG51bGwsXG4gICAgICB5QXhpc0lEOiBudWxsLFxuICAgICAgb3JkZXI6IGUgJiYgZS5vcmRlciB8fCAwLFxuICAgICAgaW5kZXg6IHQsXG4gICAgICBfZGF0YXNldDogZSxcbiAgICAgIF9wYXJzZWQ6IFtdLFxuICAgICAgX3NvcnRlZDogITFcbiAgICB9LCBzLnB1c2gobikpLCBuO1xuICB9XG4gIGdldENvbnRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuJGNvbnRleHQgfHwgKHRoaXMuJGNvbnRleHQgPSB2dChudWxsLCB7IGNoYXJ0OiB0aGlzLCB0eXBlOiBcImNoYXJ0XCIgfSkpO1xuICB9XG4gIGdldFZpc2libGVEYXRhc2V0Q291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpLmxlbmd0aDtcbiAgfVxuICBpc0RhdGFzZXRWaXNpYmxlKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5kYXRhLmRhdGFzZXRzW3RdO1xuICAgIGlmICghZSlcbiAgICAgIHJldHVybiAhMTtcbiAgICBjb25zdCBzID0gdGhpcy5nZXREYXRhc2V0TWV0YSh0KTtcbiAgICByZXR1cm4gdHlwZW9mIHMuaGlkZGVuID09IFwiYm9vbGVhblwiID8gIXMuaGlkZGVuIDogIWUuaGlkZGVuO1xuICB9XG4gIHNldERhdGFzZXRWaXNpYmlsaXR5KHQsIGUpIHtcbiAgICBjb25zdCBzID0gdGhpcy5nZXREYXRhc2V0TWV0YSh0KTtcbiAgICBzLmhpZGRlbiA9ICFlO1xuICB9XG4gIHRvZ2dsZURhdGFWaXNpYmlsaXR5KHQpIHtcbiAgICB0aGlzLl9oaWRkZW5JbmRpY2VzW3RdID0gIXRoaXMuX2hpZGRlbkluZGljZXNbdF07XG4gIH1cbiAgZ2V0RGF0YVZpc2liaWxpdHkodCkge1xuICAgIHJldHVybiAhdGhpcy5faGlkZGVuSW5kaWNlc1t0XTtcbiAgfVxuICBfdXBkYXRlVmlzaWJpbGl0eSh0LCBlLCBzKSB7XG4gICAgY29uc3QgbiA9IHMgPyBcInNob3dcIiA6IFwiaGlkZVwiLCBvID0gdGhpcy5nZXREYXRhc2V0TWV0YSh0KSwgciA9IG8uY29udHJvbGxlci5fcmVzb2x2ZUFuaW1hdGlvbnModm9pZCAwLCBuKTtcbiAgICBldChlKSA/IChvLmRhdGFbZV0uaGlkZGVuID0gIXMsIHRoaXMudXBkYXRlKCkpIDogKHRoaXMuc2V0RGF0YXNldFZpc2liaWxpdHkodCwgcyksIHIudXBkYXRlKG8sIHsgdmlzaWJsZTogcyB9KSwgdGhpcy51cGRhdGUoKGEpID0+IGEuZGF0YXNldEluZGV4ID09PSB0ID8gbiA6IHZvaWQgMCkpO1xuICB9XG4gIGhpZGUodCwgZSkge1xuICAgIHRoaXMuX3VwZGF0ZVZpc2liaWxpdHkodCwgZSwgITEpO1xuICB9XG4gIHNob3codCwgZSkge1xuICAgIHRoaXMuX3VwZGF0ZVZpc2liaWxpdHkodCwgZSwgITApO1xuICB9XG4gIF9kZXN0cm95RGF0YXNldE1ldGEodCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLl9tZXRhc2V0c1t0XTtcbiAgICBlICYmIGUuY29udHJvbGxlciAmJiBlLmNvbnRyb2xsZXIuX2Rlc3Ryb3koKSwgZGVsZXRlIHRoaXMuX21ldGFzZXRzW3RdO1xuICB9XG4gIF9zdG9wKCkge1xuICAgIGxldCB0LCBlO1xuICAgIGZvciAodGhpcy5zdG9wKCksIGF0LnJlbW92ZSh0aGlzKSwgdCA9IDAsIGUgPSB0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoOyB0IDwgZTsgKyt0KVxuICAgICAgdGhpcy5fZGVzdHJveURhdGFzZXRNZXRhKHQpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKFwiYmVmb3JlRGVzdHJveVwiKTtcbiAgICBjb25zdCB7IGNhbnZhczogdCwgY3R4OiBlIH0gPSB0aGlzO1xuICAgIHRoaXMuX3N0b3AoKSwgdGhpcy5jb25maWcuY2xlYXJDYWNoZSgpLCB0ICYmICh0aGlzLnVuYmluZEV2ZW50cygpLCBvcyh0LCBlKSwgdGhpcy5wbGF0Zm9ybS5yZWxlYXNlQ29udGV4dChlKSwgdGhpcy5jYW52YXMgPSBudWxsLCB0aGlzLmN0eCA9IG51bGwpLCB0aGlzLm5vdGlmeVBsdWdpbnMoXCJkZXN0cm95XCIpLCBkZWxldGUgJGVbdGhpcy5pZF0sIHRoaXMubm90aWZ5UGx1Z2lucyhcImFmdGVyRGVzdHJveVwiKTtcbiAgfVxuICB0b0Jhc2U2NEltYWdlKC4uLnQpIHtcbiAgICByZXR1cm4gdGhpcy5jYW52YXMudG9EYXRhVVJMKC4uLnQpO1xuICB9XG4gIGJpbmRFdmVudHMoKSB7XG4gICAgdGhpcy5iaW5kVXNlckV2ZW50cygpLCB0aGlzLm9wdGlvbnMucmVzcG9uc2l2ZSA/IHRoaXMuYmluZFJlc3BvbnNpdmVFdmVudHMoKSA6IHRoaXMuYXR0YWNoZWQgPSAhMDtcbiAgfVxuICBiaW5kVXNlckV2ZW50cygpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fbGlzdGVuZXJzLCBlID0gdGhpcy5wbGF0Zm9ybSwgcyA9IChvLCByKSA9PiB7XG4gICAgICBlLmFkZEV2ZW50TGlzdGVuZXIodGhpcywgbywgciksIHRbb10gPSByO1xuICAgIH0sIG4gPSAobywgciwgYSkgPT4ge1xuICAgICAgby5vZmZzZXRYID0gciwgby5vZmZzZXRZID0gYSwgdGhpcy5fZXZlbnRIYW5kbGVyKG8pO1xuICAgIH07XG4gICAgRSh0aGlzLm9wdGlvbnMuZXZlbnRzLCAobykgPT4gcyhvLCBuKSk7XG4gIH1cbiAgYmluZFJlc3BvbnNpdmVFdmVudHMoKSB7XG4gICAgdGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycyB8fCAodGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycyA9IHt9KTtcbiAgICBjb25zdCB0ID0gdGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycywgZSA9IHRoaXMucGxhdGZvcm0sIHMgPSAobCwgYykgPT4ge1xuICAgICAgZS5hZGRFdmVudExpc3RlbmVyKHRoaXMsIGwsIGMpLCB0W2xdID0gYztcbiAgICB9LCBuID0gKGwsIGMpID0+IHtcbiAgICAgIHRbbF0gJiYgKGUucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLCBsLCBjKSwgZGVsZXRlIHRbbF0pO1xuICAgIH0sIG8gPSAobCwgYykgPT4ge1xuICAgICAgdGhpcy5jYW52YXMgJiYgdGhpcy5yZXNpemUobCwgYyk7XG4gICAgfTtcbiAgICBsZXQgcjtcbiAgICBjb25zdCBhID0gKCkgPT4ge1xuICAgICAgbihcImF0dGFjaFwiLCBhKSwgdGhpcy5hdHRhY2hlZCA9ICEwLCB0aGlzLnJlc2l6ZSgpLCBzKFwicmVzaXplXCIsIG8pLCBzKFwiZGV0YWNoXCIsIHIpO1xuICAgIH07XG4gICAgciA9ICgpID0+IHtcbiAgICAgIHRoaXMuYXR0YWNoZWQgPSAhMSwgbihcInJlc2l6ZVwiLCBvKSwgdGhpcy5fc3RvcCgpLCB0aGlzLl9yZXNpemUoMCwgMCksIHMoXCJhdHRhY2hcIiwgYSk7XG4gICAgfSwgZS5pc0F0dGFjaGVkKHRoaXMuY2FudmFzKSA/IGEoKSA6IHIoKTtcbiAgfVxuICB1bmJpbmRFdmVudHMoKSB7XG4gICAgRSh0aGlzLl9saXN0ZW5lcnMsICh0LCBlKSA9PiB7XG4gICAgICB0aGlzLnBsYXRmb3JtLnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcywgZSwgdCk7XG4gICAgfSksIHRoaXMuX2xpc3RlbmVycyA9IHt9LCBFKHRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnMsICh0LCBlKSA9PiB7XG4gICAgICB0aGlzLnBsYXRmb3JtLnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcywgZSwgdCk7XG4gICAgfSksIHRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnMgPSB2b2lkIDA7XG4gIH1cbiAgdXBkYXRlSG92ZXJTdHlsZSh0LCBlLCBzKSB7XG4gICAgY29uc3QgbiA9IHMgPyBcInNldFwiIDogXCJyZW1vdmVcIjtcbiAgICBsZXQgbywgciwgYSwgbDtcbiAgICBmb3IgKGUgPT09IFwiZGF0YXNldFwiICYmIChvID0gdGhpcy5nZXREYXRhc2V0TWV0YSh0WzBdLmRhdGFzZXRJbmRleCksIG8uY29udHJvbGxlcltcIl9cIiArIG4gKyBcIkRhdGFzZXRIb3ZlclN0eWxlXCJdKCkpLCBhID0gMCwgbCA9IHQubGVuZ3RoOyBhIDwgbDsgKythKSB7XG4gICAgICByID0gdFthXTtcbiAgICAgIGNvbnN0IGMgPSByICYmIHRoaXMuZ2V0RGF0YXNldE1ldGEoci5kYXRhc2V0SW5kZXgpLmNvbnRyb2xsZXI7XG4gICAgICBjICYmIGNbbiArIFwiSG92ZXJTdHlsZVwiXShyLmVsZW1lbnQsIHIuZGF0YXNldEluZGV4LCByLmluZGV4KTtcbiAgICB9XG4gIH1cbiAgZ2V0QWN0aXZlRWxlbWVudHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FjdGl2ZSB8fCBbXTtcbiAgfVxuICBzZXRBY3RpdmVFbGVtZW50cyh0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuX2FjdGl2ZSB8fCBbXSwgcyA9IHQubWFwKCh7IGRhdGFzZXRJbmRleDogbywgaW5kZXg6IHIgfSkgPT4ge1xuICAgICAgY29uc3QgYSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEobyk7XG4gICAgICBpZiAoIWEpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGRhdGFzZXQgZm91bmQgYXQgaW5kZXggXCIgKyBvKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGFzZXRJbmRleDogbyxcbiAgICAgICAgZWxlbWVudDogYS5kYXRhW3JdLFxuICAgICAgICBpbmRleDogclxuICAgICAgfTtcbiAgICB9KTtcbiAgICAhemUocywgZSkgJiYgKHRoaXMuX2FjdGl2ZSA9IHMsIHRoaXMuX2xhc3RFdmVudCA9IG51bGwsIHRoaXMuX3VwZGF0ZUhvdmVyU3R5bGVzKHMsIGUpKTtcbiAgfVxuICBub3RpZnlQbHVnaW5zKHQsIGUsIHMpIHtcbiAgICByZXR1cm4gdGhpcy5fcGx1Z2lucy5ub3RpZnkodGhpcywgdCwgZSwgcyk7XG4gIH1cbiAgX3VwZGF0ZUhvdmVyU3R5bGVzKHQsIGUsIHMpIHtcbiAgICBjb25zdCBuID0gdGhpcy5vcHRpb25zLmhvdmVyLCBvID0gKGwsIGMpID0+IGwuZmlsdGVyKChoKSA9PiAhYy5zb21lKChkKSA9PiBoLmRhdGFzZXRJbmRleCA9PT0gZC5kYXRhc2V0SW5kZXggJiYgaC5pbmRleCA9PT0gZC5pbmRleCkpLCByID0gbyhlLCB0KSwgYSA9IHMgPyB0IDogbyh0LCBlKTtcbiAgICByLmxlbmd0aCAmJiB0aGlzLnVwZGF0ZUhvdmVyU3R5bGUociwgbi5tb2RlLCAhMSksIGEubGVuZ3RoICYmIG4ubW9kZSAmJiB0aGlzLnVwZGF0ZUhvdmVyU3R5bGUoYSwgbi5tb2RlLCAhMCk7XG4gIH1cbiAgX2V2ZW50SGFuZGxlcih0LCBlKSB7XG4gICAgY29uc3QgcyA9IHtcbiAgICAgIGV2ZW50OiB0LFxuICAgICAgcmVwbGF5OiBlLFxuICAgICAgY2FuY2VsYWJsZTogITAsXG4gICAgICBpbkNoYXJ0QXJlYTogdGhpcy5pc1BvaW50SW5BcmVhKHQpXG4gICAgfSwgbiA9IChyKSA9PiAoci5vcHRpb25zLmV2ZW50cyB8fCB0aGlzLm9wdGlvbnMuZXZlbnRzKS5pbmNsdWRlcyh0Lm5hdGl2ZS50eXBlKTtcbiAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKFwiYmVmb3JlRXZlbnRcIiwgcywgbikgPT09ICExKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG8gPSB0aGlzLl9oYW5kbGVFdmVudCh0LCBlLCBzLmluQ2hhcnRBcmVhKTtcbiAgICByZXR1cm4gcy5jYW5jZWxhYmxlID0gITEsIHRoaXMubm90aWZ5UGx1Z2lucyhcImFmdGVyRXZlbnRcIiwgcywgbiksIChvIHx8IHMuY2hhbmdlZCkgJiYgdGhpcy5yZW5kZXIoKSwgdGhpcztcbiAgfVxuICBfaGFuZGxlRXZlbnQodCwgZSwgcykge1xuICAgIGNvbnN0IHsgX2FjdGl2ZTogbiA9IFtdLCBvcHRpb25zOiBvIH0gPSB0aGlzLCByID0gZSwgYSA9IHRoaXMuX2dldEFjdGl2ZUVsZW1lbnRzKHQsIG4sIHMsIHIpLCBsID0gU28odCksIGMgPSBDbCh0LCB0aGlzLl9sYXN0RXZlbnQsIHMsIGwpO1xuICAgIHMgJiYgKHRoaXMuX2xhc3RFdmVudCA9IG51bGwsIEkoby5vbkhvdmVyLCBbdCwgYSwgdGhpc10sIHRoaXMpLCBsICYmIEkoby5vbkNsaWNrLCBbdCwgYSwgdGhpc10sIHRoaXMpKTtcbiAgICBjb25zdCBoID0gIXplKGEsIG4pO1xuICAgIHJldHVybiAoaCB8fCBlKSAmJiAodGhpcy5fYWN0aXZlID0gYSwgdGhpcy5fdXBkYXRlSG92ZXJTdHlsZXMoYSwgbiwgZSkpLCB0aGlzLl9sYXN0RXZlbnQgPSBjLCBoO1xuICB9XG4gIF9nZXRBY3RpdmVFbGVtZW50cyh0LCBlLCBzLCBuKSB7XG4gICAgaWYgKHQudHlwZSA9PT0gXCJtb3VzZW91dFwiKVxuICAgICAgcmV0dXJuIFtdO1xuICAgIGlmICghcylcbiAgICAgIHJldHVybiBlO1xuICAgIGNvbnN0IG8gPSB0aGlzLm9wdGlvbnMuaG92ZXI7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RWxlbWVudHNBdEV2ZW50Rm9yTW9kZSh0LCBvLm1vZGUsIG8sIG4pO1xuICB9XG59XG5jb25zdCBCcyA9ICgpID0+IEUoamkuaW5zdGFuY2VzLCAoaSkgPT4gaS5fcGx1Z2lucy5pbnZhbGlkYXRlKCkpLCBwdCA9ICEwO1xuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoamksIHtcbiAgZGVmYXVsdHM6IHtcbiAgICBlbnVtZXJhYmxlOiBwdCxcbiAgICB2YWx1ZTogT1xuICB9LFxuICBpbnN0YW5jZXM6IHtcbiAgICBlbnVtZXJhYmxlOiBwdCxcbiAgICB2YWx1ZTogJGVcbiAgfSxcbiAgb3ZlcnJpZGVzOiB7XG4gICAgZW51bWVyYWJsZTogcHQsXG4gICAgdmFsdWU6IEF0XG4gIH0sXG4gIHJlZ2lzdHJ5OiB7XG4gICAgZW51bWVyYWJsZTogcHQsXG4gICAgdmFsdWU6IG90XG4gIH0sXG4gIHZlcnNpb246IHtcbiAgICBlbnVtZXJhYmxlOiBwdCxcbiAgICB2YWx1ZToga2xcbiAgfSxcbiAgZ2V0Q2hhcnQ6IHtcbiAgICBlbnVtZXJhYmxlOiBwdCxcbiAgICB2YWx1ZTogdG9cbiAgfSxcbiAgcmVnaXN0ZXI6IHtcbiAgICBlbnVtZXJhYmxlOiBwdCxcbiAgICB2YWx1ZTogKC4uLmkpID0+IHtcbiAgICAgIG90LmFkZCguLi5pKSwgQnMoKTtcbiAgICB9XG4gIH0sXG4gIHVucmVnaXN0ZXI6IHtcbiAgICBlbnVtZXJhYmxlOiBwdCxcbiAgICB2YWx1ZTogKC4uLmkpID0+IHtcbiAgICAgIG90LnJlbW92ZSguLi5pKSwgQnMoKTtcbiAgICB9XG4gIH1cbn0pO1xuZnVuY3Rpb24gZW8oaSwgdCwgZSkge1xuICBjb25zdCB7IHN0YXJ0QW5nbGU6IHMsIHBpeGVsTWFyZ2luOiBuLCB4OiBvLCB5OiByLCBvdXRlclJhZGl1czogYSwgaW5uZXJSYWRpdXM6IGwgfSA9IHQ7XG4gIGxldCBjID0gbiAvIGE7XG4gIGkuYmVnaW5QYXRoKCksIGkuYXJjKG8sIHIsIGEsIHMgLSBjLCBlICsgYyksIGwgPiBuID8gKGMgPSBuIC8gbCwgaS5hcmMobywgciwgbCwgZSArIGMsIHMgLSBjLCAhMCkpIDogaS5hcmMobywgciwgbiwgZSArIFYsIHMgLSBWKSwgaS5jbG9zZVBhdGgoKSwgaS5jbGlwKCk7XG59XG5mdW5jdGlvbiBEbChpKSB7XG4gIHJldHVybiBJaShpLCBbXCJvdXRlclN0YXJ0XCIsIFwib3V0ZXJFbmRcIiwgXCJpbm5lclN0YXJ0XCIsIFwiaW5uZXJFbmRcIl0pO1xufVxuZnVuY3Rpb24gT2woaSwgdCwgZSwgcykge1xuICBjb25zdCBuID0gRGwoaS5vcHRpb25zLmJvcmRlclJhZGl1cyksIG8gPSAoZSAtIHQpIC8gMiwgciA9IE1hdGgubWluKG8sIHMgKiB0IC8gMiksIGEgPSAobCkgPT4ge1xuICAgIGNvbnN0IGMgPSAoZSAtIE1hdGgubWluKG8sIGwpKSAqIHMgLyAyO1xuICAgIHJldHVybiBZKGwsIDAsIE1hdGgubWluKG8sIGMpKTtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBvdXRlclN0YXJ0OiBhKG4ub3V0ZXJTdGFydCksXG4gICAgb3V0ZXJFbmQ6IGEobi5vdXRlckVuZCksXG4gICAgaW5uZXJTdGFydDogWShuLmlubmVyU3RhcnQsIDAsIHIpLFxuICAgIGlubmVyRW5kOiBZKG4uaW5uZXJFbmQsIDAsIHIpXG4gIH07XG59XG5mdW5jdGlvbiBJdChpLCB0LCBlLCBzKSB7XG4gIHJldHVybiB7XG4gICAgeDogZSArIGkgKiBNYXRoLmNvcyh0KSxcbiAgICB5OiBzICsgaSAqIE1hdGguc2luKHQpXG4gIH07XG59XG5mdW5jdGlvbiB3aShpLCB0LCBlLCBzLCBuLCBvKSB7XG4gIGNvbnN0IHsgeDogciwgeTogYSwgc3RhcnRBbmdsZTogbCwgcGl4ZWxNYXJnaW46IGMsIGlubmVyUmFkaXVzOiBoIH0gPSB0LCBkID0gTWF0aC5tYXgodC5vdXRlclJhZGl1cyArIHMgKyBlIC0gYywgMCksIHUgPSBoID4gMCA/IGggKyBzICsgZSArIGMgOiAwO1xuICBsZXQgZiA9IDA7XG4gIGNvbnN0IGcgPSBuIC0gbDtcbiAgaWYgKHMpIHtcbiAgICBjb25zdCBQID0gaCA+IDAgPyBoIC0gcyA6IDAsIGogPSBkID4gMCA/IGQgLSBzIDogMCwgVyA9IChQICsgaikgLyAyLCBrdCA9IFcgIT09IDAgPyBnICogVyAvIChXICsgcykgOiBnO1xuICAgIGYgPSAoZyAtIGt0KSAvIDI7XG4gIH1cbiAgY29uc3QgcCA9IE1hdGgubWF4KDFlLTMsIGcgKiBkIC0gZSAvIEIpIC8gZCwgbSA9IChnIC0gcCkgLyAyLCBiID0gbCArIG0gKyBmLCB4ID0gbiAtIG0gLSBmLCB7IG91dGVyU3RhcnQ6IHYsIG91dGVyRW5kOiB5LCBpbm5lclN0YXJ0OiBfLCBpbm5lckVuZDogTSB9ID0gT2wodCwgdSwgZCwgeCAtIGIpLCBrID0gZCAtIHYsIFMgPSBkIC0geSwgdyA9IGIgKyB2IC8gaywgTCA9IHggLSB5IC8gUywgUiA9IHUgKyBfLCBBID0gdSArIE0sIEggPSBiICsgXyAvIFIsIHEgPSB4IC0gTSAvIEE7XG4gIGlmIChpLmJlZ2luUGF0aCgpLCBvKSB7XG4gICAgaWYgKGkuYXJjKHIsIGEsIGQsIHcsIEwpLCB5ID4gMCkge1xuICAgICAgY29uc3QgVyA9IEl0KFMsIEwsIHIsIGEpO1xuICAgICAgaS5hcmMoVy54LCBXLnksIHksIEwsIHggKyBWKTtcbiAgICB9XG4gICAgY29uc3QgUCA9IEl0KEEsIHgsIHIsIGEpO1xuICAgIGlmIChpLmxpbmVUbyhQLngsIFAueSksIE0gPiAwKSB7XG4gICAgICBjb25zdCBXID0gSXQoQSwgcSwgciwgYSk7XG4gICAgICBpLmFyYyhXLngsIFcueSwgTSwgeCArIFYsIHEgKyBNYXRoLlBJKTtcbiAgICB9XG4gICAgaWYgKGkuYXJjKHIsIGEsIHUsIHggLSBNIC8gdSwgYiArIF8gLyB1LCAhMCksIF8gPiAwKSB7XG4gICAgICBjb25zdCBXID0gSXQoUiwgSCwgciwgYSk7XG4gICAgICBpLmFyYyhXLngsIFcueSwgXywgSCArIE1hdGguUEksIGIgLSBWKTtcbiAgICB9XG4gICAgY29uc3QgaiA9IEl0KGssIGIsIHIsIGEpO1xuICAgIGlmIChpLmxpbmVUbyhqLngsIGoueSksIHYgPiAwKSB7XG4gICAgICBjb25zdCBXID0gSXQoaywgdywgciwgYSk7XG4gICAgICBpLmFyYyhXLngsIFcueSwgdiwgYiAtIFYsIHcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpLm1vdmVUbyhyLCBhKTtcbiAgICBjb25zdCBQID0gTWF0aC5jb3ModykgKiBkICsgciwgaiA9IE1hdGguc2luKHcpICogZCArIGE7XG4gICAgaS5saW5lVG8oUCwgaik7XG4gICAgY29uc3QgVyA9IE1hdGguY29zKEwpICogZCArIHIsIGt0ID0gTWF0aC5zaW4oTCkgKiBkICsgYTtcbiAgICBpLmxpbmVUbyhXLCBrdCk7XG4gIH1cbiAgaS5jbG9zZVBhdGgoKTtcbn1cbmZ1bmN0aW9uIEFsKGksIHQsIGUsIHMsIG4pIHtcbiAgY29uc3QgeyBmdWxsQ2lyY2xlczogbywgc3RhcnRBbmdsZTogciwgY2lyY3VtZmVyZW5jZTogYSB9ID0gdDtcbiAgbGV0IGwgPSB0LmVuZEFuZ2xlO1xuICBpZiAobykge1xuICAgIHdpKGksIHQsIGUsIHMsIHIgKyBGLCBuKTtcbiAgICBmb3IgKGxldCBjID0gMDsgYyA8IG87ICsrYylcbiAgICAgIGkuZmlsbCgpO1xuICAgIGlzTmFOKGEpIHx8IChsID0gciArIGEgJSBGLCBhICUgRiA9PT0gMCAmJiAobCArPSBGKSk7XG4gIH1cbiAgcmV0dXJuIHdpKGksIHQsIGUsIHMsIGwsIG4pLCBpLmZpbGwoKSwgbDtcbn1cbmZ1bmN0aW9uIFRsKGksIHQsIGUpIHtcbiAgY29uc3QgeyB4OiBzLCB5OiBuLCBzdGFydEFuZ2xlOiBvLCBwaXhlbE1hcmdpbjogciwgZnVsbENpcmNsZXM6IGEgfSA9IHQsIGwgPSBNYXRoLm1heCh0Lm91dGVyUmFkaXVzIC0gciwgMCksIGMgPSB0LmlubmVyUmFkaXVzICsgcjtcbiAgbGV0IGg7XG4gIGZvciAoZSAmJiBlbyhpLCB0LCBvICsgRiksIGkuYmVnaW5QYXRoKCksIGkuYXJjKHMsIG4sIGMsIG8gKyBGLCBvLCAhMCksIGggPSAwOyBoIDwgYTsgKytoKVxuICAgIGkuc3Ryb2tlKCk7XG4gIGZvciAoaS5iZWdpblBhdGgoKSwgaS5hcmMocywgbiwgbCwgbywgbyArIEYpLCBoID0gMDsgaCA8IGE7ICsraClcbiAgICBpLnN0cm9rZSgpO1xufVxuZnVuY3Rpb24gTGwoaSwgdCwgZSwgcywgbiwgbykge1xuICBjb25zdCB7IG9wdGlvbnM6IHIgfSA9IHQsIHsgYm9yZGVyV2lkdGg6IGEsIGJvcmRlckpvaW5TdHlsZTogbCB9ID0gciwgYyA9IHIuYm9yZGVyQWxpZ24gPT09IFwiaW5uZXJcIjtcbiAgYSAmJiAoYyA/IChpLmxpbmVXaWR0aCA9IGEgKiAyLCBpLmxpbmVKb2luID0gbCB8fCBcInJvdW5kXCIpIDogKGkubGluZVdpZHRoID0gYSwgaS5saW5lSm9pbiA9IGwgfHwgXCJiZXZlbFwiKSwgdC5mdWxsQ2lyY2xlcyAmJiBUbChpLCB0LCBjKSwgYyAmJiBlbyhpLCB0LCBuKSwgd2koaSwgdCwgZSwgcywgbiwgbyksIGkuc3Ryb2tlKCkpO1xufVxuY2xhc3MgeWUgZXh0ZW5kcyBzdCB7XG4gIGNvbnN0cnVjdG9yKHQpIHtcbiAgICBzdXBlcigpLCB0aGlzLm9wdGlvbnMgPSB2b2lkIDAsIHRoaXMuY2lyY3VtZmVyZW5jZSA9IHZvaWQgMCwgdGhpcy5zdGFydEFuZ2xlID0gdm9pZCAwLCB0aGlzLmVuZEFuZ2xlID0gdm9pZCAwLCB0aGlzLmlubmVyUmFkaXVzID0gdm9pZCAwLCB0aGlzLm91dGVyUmFkaXVzID0gdm9pZCAwLCB0aGlzLnBpeGVsTWFyZ2luID0gMCwgdGhpcy5mdWxsQ2lyY2xlcyA9IDAsIHQgJiYgT2JqZWN0LmFzc2lnbih0aGlzLCB0KTtcbiAgfVxuICBpblJhbmdlKHQsIGUsIHMpIHtcbiAgICBjb25zdCBuID0gdGhpcy5nZXRQcm9wcyhbXCJ4XCIsIFwieVwiXSwgcyksIHsgYW5nbGU6IG8sIGRpc3RhbmNlOiByIH0gPSBobihuLCB7IHg6IHQsIHk6IGUgfSksIHsgc3RhcnRBbmdsZTogYSwgZW5kQW5nbGU6IGwsIGlubmVyUmFkaXVzOiBjLCBvdXRlclJhZGl1czogaCwgY2lyY3VtZmVyZW5jZTogZCB9ID0gdGhpcy5nZXRQcm9wcyhbXG4gICAgICBcInN0YXJ0QW5nbGVcIixcbiAgICAgIFwiZW5kQW5nbGVcIixcbiAgICAgIFwiaW5uZXJSYWRpdXNcIixcbiAgICAgIFwib3V0ZXJSYWRpdXNcIixcbiAgICAgIFwiY2lyY3VtZmVyZW5jZVwiXG4gICAgXSwgcyksIHUgPSB0aGlzLm9wdGlvbnMuc3BhY2luZyAvIDIsIGcgPSBDKGQsIGwgLSBhKSA+PSBGIHx8IG9lKG8sIGEsIGwpLCBwID0gdXQociwgYyArIHUsIGggKyB1KTtcbiAgICByZXR1cm4gZyAmJiBwO1xuICB9XG4gIGdldENlbnRlclBvaW50KHQpIHtcbiAgICBjb25zdCB7IHg6IGUsIHk6IHMsIHN0YXJ0QW5nbGU6IG4sIGVuZEFuZ2xlOiBvLCBpbm5lclJhZGl1czogciwgb3V0ZXJSYWRpdXM6IGEgfSA9IHRoaXMuZ2V0UHJvcHMoW1xuICAgICAgXCJ4XCIsXG4gICAgICBcInlcIixcbiAgICAgIFwic3RhcnRBbmdsZVwiLFxuICAgICAgXCJlbmRBbmdsZVwiLFxuICAgICAgXCJpbm5lclJhZGl1c1wiLFxuICAgICAgXCJvdXRlclJhZGl1c1wiLFxuICAgICAgXCJjaXJjdW1mZXJlbmNlXCJcbiAgICBdLCB0KSwgeyBvZmZzZXQ6IGwsIHNwYWNpbmc6IGMgfSA9IHRoaXMub3B0aW9ucywgaCA9IChuICsgbykgLyAyLCBkID0gKHIgKyBhICsgYyArIGwpIC8gMjtcbiAgICByZXR1cm4ge1xuICAgICAgeDogZSArIE1hdGguY29zKGgpICogZCxcbiAgICAgIHk6IHMgKyBNYXRoLnNpbihoKSAqIGRcbiAgICB9O1xuICB9XG4gIHRvb2x0aXBQb3NpdGlvbih0KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q2VudGVyUG9pbnQodCk7XG4gIH1cbiAgZHJhdyh0KSB7XG4gICAgY29uc3QgeyBvcHRpb25zOiBlLCBjaXJjdW1mZXJlbmNlOiBzIH0gPSB0aGlzLCBuID0gKGUub2Zmc2V0IHx8IDApIC8gMiwgbyA9IChlLnNwYWNpbmcgfHwgMCkgLyAyLCByID0gZS5jaXJjdWxhcjtcbiAgICBpZiAodGhpcy5waXhlbE1hcmdpbiA9IGUuYm9yZGVyQWxpZ24gPT09IFwiaW5uZXJcIiA/IDAuMzMgOiAwLCB0aGlzLmZ1bGxDaXJjbGVzID0gcyA+IEYgPyBNYXRoLmZsb29yKHMgLyBGKSA6IDAsIHMgPT09IDAgfHwgdGhpcy5pbm5lclJhZGl1cyA8IDAgfHwgdGhpcy5vdXRlclJhZGl1cyA8IDApXG4gICAgICByZXR1cm47XG4gICAgdC5zYXZlKCk7XG4gICAgbGV0IGEgPSAwO1xuICAgIGlmIChuKSB7XG4gICAgICBhID0gbiAvIDI7XG4gICAgICBjb25zdCBjID0gKHRoaXMuc3RhcnRBbmdsZSArIHRoaXMuZW5kQW5nbGUpIC8gMjtcbiAgICAgIHQudHJhbnNsYXRlKE1hdGguY29zKGMpICogYSwgTWF0aC5zaW4oYykgKiBhKSwgdGhpcy5jaXJjdW1mZXJlbmNlID49IEIgJiYgKGEgPSBuKTtcbiAgICB9XG4gICAgdC5maWxsU3R5bGUgPSBlLmJhY2tncm91bmRDb2xvciwgdC5zdHJva2VTdHlsZSA9IGUuYm9yZGVyQ29sb3I7XG4gICAgY29uc3QgbCA9IEFsKHQsIHRoaXMsIGEsIG8sIHIpO1xuICAgIExsKHQsIHRoaXMsIGEsIG8sIGwsIHIpLCB0LnJlc3RvcmUoKTtcbiAgfVxufVxueWUuaWQgPSBcImFyY1wiO1xueWUuZGVmYXVsdHMgPSB7XG4gIGJvcmRlckFsaWduOiBcImNlbnRlclwiLFxuICBib3JkZXJDb2xvcjogXCIjZmZmXCIsXG4gIGJvcmRlckpvaW5TdHlsZTogdm9pZCAwLFxuICBib3JkZXJSYWRpdXM6IDAsXG4gIGJvcmRlcldpZHRoOiAyLFxuICBvZmZzZXQ6IDAsXG4gIHNwYWNpbmc6IDAsXG4gIGFuZ2xlOiB2b2lkIDAsXG4gIGNpcmN1bGFyOiAhMFxufTtcbnllLmRlZmF1bHRSb3V0ZXMgPSB7XG4gIGJhY2tncm91bmRDb2xvcjogXCJiYWNrZ3JvdW5kQ29sb3JcIlxufTtcbmZ1bmN0aW9uIGlvKGksIHQsIGUgPSB0KSB7XG4gIGkubGluZUNhcCA9IEMoZS5ib3JkZXJDYXBTdHlsZSwgdC5ib3JkZXJDYXBTdHlsZSksIGkuc2V0TGluZURhc2goQyhlLmJvcmRlckRhc2gsIHQuYm9yZGVyRGFzaCkpLCBpLmxpbmVEYXNoT2Zmc2V0ID0gQyhlLmJvcmRlckRhc2hPZmZzZXQsIHQuYm9yZGVyRGFzaE9mZnNldCksIGkubGluZUpvaW4gPSBDKGUuYm9yZGVySm9pblN0eWxlLCB0LmJvcmRlckpvaW5TdHlsZSksIGkubGluZVdpZHRoID0gQyhlLmJvcmRlcldpZHRoLCB0LmJvcmRlcldpZHRoKSwgaS5zdHJva2VTdHlsZSA9IEMoZS5ib3JkZXJDb2xvciwgdC5ib3JkZXJDb2xvcik7XG59XG5mdW5jdGlvbiBSbChpLCB0LCBlKSB7XG4gIGkubGluZVRvKGUueCwgZS55KTtcbn1cbmZ1bmN0aW9uIEVsKGkpIHtcbiAgcmV0dXJuIGkuc3RlcHBlZCA/IGxyIDogaS50ZW5zaW9uIHx8IGkuY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSA9PT0gXCJtb25vdG9uZVwiID8gY3IgOiBSbDtcbn1cbmZ1bmN0aW9uIHNvKGksIHQsIGUgPSB7fSkge1xuICBjb25zdCBzID0gaS5sZW5ndGgsIHsgc3RhcnQ6IG4gPSAwLCBlbmQ6IG8gPSBzIC0gMSB9ID0gZSwgeyBzdGFydDogciwgZW5kOiBhIH0gPSB0LCBsID0gTWF0aC5tYXgobiwgciksIGMgPSBNYXRoLm1pbihvLCBhKSwgaCA9IG4gPCByICYmIG8gPCByIHx8IG4gPiBhICYmIG8gPiBhO1xuICByZXR1cm4ge1xuICAgIGNvdW50OiBzLFxuICAgIHN0YXJ0OiBsLFxuICAgIGxvb3A6IHQubG9vcCxcbiAgICBpbGVuOiBjIDwgbCAmJiAhaCA/IHMgKyBjIC0gbCA6IGMgLSBsXG4gIH07XG59XG5mdW5jdGlvbiBGbChpLCB0LCBlLCBzKSB7XG4gIGNvbnN0IHsgcG9pbnRzOiBuLCBvcHRpb25zOiBvIH0gPSB0LCB7IGNvdW50OiByLCBzdGFydDogYSwgbG9vcDogbCwgaWxlbjogYyB9ID0gc28obiwgZSwgcyksIGggPSBFbChvKTtcbiAgbGV0IHsgbW92ZTogZCA9ICEwLCByZXZlcnNlOiB1IH0gPSBzIHx8IHt9LCBmLCBnLCBwO1xuICBmb3IgKGYgPSAwOyBmIDw9IGM7ICsrZilcbiAgICBnID0gblsoYSArICh1ID8gYyAtIGYgOiBmKSkgJSByXSwgIWcuc2tpcCAmJiAoZCA/IChpLm1vdmVUbyhnLngsIGcueSksIGQgPSAhMSkgOiBoKGksIHAsIGcsIHUsIG8uc3RlcHBlZCksIHAgPSBnKTtcbiAgcmV0dXJuIGwgJiYgKGcgPSBuWyhhICsgKHUgPyBjIDogMCkpICUgcl0sIGgoaSwgcCwgZywgdSwgby5zdGVwcGVkKSksICEhbDtcbn1cbmZ1bmN0aW9uIElsKGksIHQsIGUsIHMpIHtcbiAgY29uc3QgbiA9IHQucG9pbnRzLCB7IGNvdW50OiBvLCBzdGFydDogciwgaWxlbjogYSB9ID0gc28obiwgZSwgcyksIHsgbW92ZTogbCA9ICEwLCByZXZlcnNlOiBjIH0gPSBzIHx8IHt9O1xuICBsZXQgaCA9IDAsIGQgPSAwLCB1LCBmLCBnLCBwLCBtLCBiO1xuICBjb25zdCB4ID0gKHkpID0+IChyICsgKGMgPyBhIC0geSA6IHkpKSAlIG8sIHYgPSAoKSA9PiB7XG4gICAgcCAhPT0gbSAmJiAoaS5saW5lVG8oaCwgbSksIGkubGluZVRvKGgsIHApLCBpLmxpbmVUbyhoLCBiKSk7XG4gIH07XG4gIGZvciAobCAmJiAoZiA9IG5beCgwKV0sIGkubW92ZVRvKGYueCwgZi55KSksIHUgPSAwOyB1IDw9IGE7ICsrdSkge1xuICAgIGlmIChmID0gblt4KHUpXSwgZi5za2lwKVxuICAgICAgY29udGludWU7XG4gICAgY29uc3QgeSA9IGYueCwgXyA9IGYueSwgTSA9IHkgfCAwO1xuICAgIE0gPT09IGcgPyAoXyA8IHAgPyBwID0gXyA6IF8gPiBtICYmIChtID0gXyksIGggPSAoZCAqIGggKyB5KSAvICsrZCkgOiAodigpLCBpLmxpbmVUbyh5LCBfKSwgZyA9IE0sIGQgPSAwLCBwID0gbSA9IF8pLCBiID0gXztcbiAgfVxuICB2KCk7XG59XG5mdW5jdGlvbiBTaShpKSB7XG4gIGNvbnN0IHQgPSBpLm9wdGlvbnMsIGUgPSB0LmJvcmRlckRhc2ggJiYgdC5ib3JkZXJEYXNoLmxlbmd0aDtcbiAgcmV0dXJuICFpLl9kZWNpbWF0ZWQgJiYgIWkuX2xvb3AgJiYgIXQudGVuc2lvbiAmJiB0LmN1YmljSW50ZXJwb2xhdGlvbk1vZGUgIT09IFwibW9ub3RvbmVcIiAmJiAhdC5zdGVwcGVkICYmICFlID8gSWwgOiBGbDtcbn1cbmZ1bmN0aW9uIHpsKGkpIHtcbiAgcmV0dXJuIGkuc3RlcHBlZCA/IFdyIDogaS50ZW5zaW9uIHx8IGkuY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSA9PT0gXCJtb25vdG9uZVwiID8gTnIgOiBDdDtcbn1cbmZ1bmN0aW9uIEJsKGksIHQsIGUsIHMpIHtcbiAgbGV0IG4gPSB0Ll9wYXRoO1xuICBuIHx8IChuID0gdC5fcGF0aCA9IG5ldyBQYXRoMkQoKSwgdC5wYXRoKG4sIGUsIHMpICYmIG4uY2xvc2VQYXRoKCkpLCBpbyhpLCB0Lm9wdGlvbnMpLCBpLnN0cm9rZShuKTtcbn1cbmZ1bmN0aW9uIFZsKGksIHQsIGUsIHMpIHtcbiAgY29uc3QgeyBzZWdtZW50czogbiwgb3B0aW9uczogbyB9ID0gdCwgciA9IFNpKHQpO1xuICBmb3IgKGNvbnN0IGEgb2YgbilcbiAgICBpbyhpLCBvLCBhLnN0eWxlKSwgaS5iZWdpblBhdGgoKSwgcihpLCB0LCBhLCB7IHN0YXJ0OiBlLCBlbmQ6IGUgKyBzIC0gMSB9KSAmJiBpLmNsb3NlUGF0aCgpLCBpLnN0cm9rZSgpO1xufVxuY29uc3QgV2wgPSB0eXBlb2YgUGF0aDJEID09IFwiZnVuY3Rpb25cIjtcbmZ1bmN0aW9uIE5sKGksIHQsIGUsIHMpIHtcbiAgV2wgJiYgIXQub3B0aW9ucy5zZWdtZW50ID8gQmwoaSwgdCwgZSwgcykgOiBWbChpLCB0LCBlLCBzKTtcbn1cbmNsYXNzIGd0IGV4dGVuZHMgc3Qge1xuICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgc3VwZXIoKSwgdGhpcy5hbmltYXRlZCA9ICEwLCB0aGlzLm9wdGlvbnMgPSB2b2lkIDAsIHRoaXMuX2NoYXJ0ID0gdm9pZCAwLCB0aGlzLl9sb29wID0gdm9pZCAwLCB0aGlzLl9mdWxsTG9vcCA9IHZvaWQgMCwgdGhpcy5fcGF0aCA9IHZvaWQgMCwgdGhpcy5fcG9pbnRzID0gdm9pZCAwLCB0aGlzLl9zZWdtZW50cyA9IHZvaWQgMCwgdGhpcy5fZGVjaW1hdGVkID0gITEsIHRoaXMuX3BvaW50c1VwZGF0ZWQgPSAhMSwgdGhpcy5fZGF0YXNldEluZGV4ID0gdm9pZCAwLCB0ICYmIE9iamVjdC5hc3NpZ24odGhpcywgdCk7XG4gIH1cbiAgdXBkYXRlQ29udHJvbFBvaW50cyh0LCBlKSB7XG4gICAgY29uc3QgcyA9IHRoaXMub3B0aW9ucztcbiAgICBpZiAoKHMudGVuc2lvbiB8fCBzLmN1YmljSW50ZXJwb2xhdGlvbk1vZGUgPT09IFwibW9ub3RvbmVcIikgJiYgIXMuc3RlcHBlZCAmJiAhdGhpcy5fcG9pbnRzVXBkYXRlZCkge1xuICAgICAgY29uc3QgbiA9IHMuc3BhbkdhcHMgPyB0aGlzLl9sb29wIDogdGhpcy5fZnVsbExvb3A7XG4gICAgICBMcih0aGlzLl9wb2ludHMsIHMsIHQsIG4sIGUpLCB0aGlzLl9wb2ludHNVcGRhdGVkID0gITA7XG4gICAgfVxuICB9XG4gIHNldCBwb2ludHModCkge1xuICAgIHRoaXMuX3BvaW50cyA9IHQsIGRlbGV0ZSB0aGlzLl9zZWdtZW50cywgZGVsZXRlIHRoaXMuX3BhdGgsIHRoaXMuX3BvaW50c1VwZGF0ZWQgPSAhMTtcbiAgfVxuICBnZXQgcG9pbnRzKCkge1xuICAgIHJldHVybiB0aGlzLl9wb2ludHM7XG4gIH1cbiAgZ2V0IHNlZ21lbnRzKCkge1xuICAgIHJldHVybiB0aGlzLl9zZWdtZW50cyB8fCAodGhpcy5fc2VnbWVudHMgPSBLcih0aGlzLCB0aGlzLm9wdGlvbnMuc2VnbWVudCkpO1xuICB9XG4gIGZpcnN0KCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLnNlZ21lbnRzLCBlID0gdGhpcy5wb2ludHM7XG4gICAgcmV0dXJuIHQubGVuZ3RoICYmIGVbdFswXS5zdGFydF07XG4gIH1cbiAgbGFzdCgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5zZWdtZW50cywgZSA9IHRoaXMucG9pbnRzLCBzID0gdC5sZW5ndGg7XG4gICAgcmV0dXJuIHMgJiYgZVt0W3MgLSAxXS5lbmRdO1xuICB9XG4gIGludGVycG9sYXRlKHQsIGUpIHtcbiAgICBjb25zdCBzID0gdGhpcy5vcHRpb25zLCBuID0gdFtlXSwgbyA9IHRoaXMucG9pbnRzLCByID0gRm4odGhpcywgeyBwcm9wZXJ0eTogZSwgc3RhcnQ6IG4sIGVuZDogbiB9KTtcbiAgICBpZiAoIXIubGVuZ3RoKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGEgPSBbXSwgbCA9IHpsKHMpO1xuICAgIGxldCBjLCBoO1xuICAgIGZvciAoYyA9IDAsIGggPSByLmxlbmd0aDsgYyA8IGg7ICsrYykge1xuICAgICAgY29uc3QgeyBzdGFydDogZCwgZW5kOiB1IH0gPSByW2NdLCBmID0gb1tkXSwgZyA9IG9bdV07XG4gICAgICBpZiAoZiA9PT0gZykge1xuICAgICAgICBhLnB1c2goZik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgcCA9IE1hdGguYWJzKChuIC0gZltlXSkgLyAoZ1tlXSAtIGZbZV0pKSwgbSA9IGwoZiwgZywgcCwgcy5zdGVwcGVkKTtcbiAgICAgIG1bZV0gPSB0W2VdLCBhLnB1c2gobSk7XG4gICAgfVxuICAgIHJldHVybiBhLmxlbmd0aCA9PT0gMSA/IGFbMF0gOiBhO1xuICB9XG4gIHBhdGhTZWdtZW50KHQsIGUsIHMpIHtcbiAgICByZXR1cm4gU2kodGhpcykodCwgdGhpcywgZSwgcyk7XG4gIH1cbiAgcGF0aCh0LCBlLCBzKSB7XG4gICAgY29uc3QgbiA9IHRoaXMuc2VnbWVudHMsIG8gPSBTaSh0aGlzKTtcbiAgICBsZXQgciA9IHRoaXMuX2xvb3A7XG4gICAgZSA9IGUgfHwgMCwgcyA9IHMgfHwgdGhpcy5wb2ludHMubGVuZ3RoIC0gZTtcbiAgICBmb3IgKGNvbnN0IGEgb2YgbilcbiAgICAgIHIgJj0gbyh0LCB0aGlzLCBhLCB7IHN0YXJ0OiBlLCBlbmQ6IGUgKyBzIC0gMSB9KTtcbiAgICByZXR1cm4gISFyO1xuICB9XG4gIGRyYXcodCwgZSwgcywgbikge1xuICAgIGNvbnN0IG8gPSB0aGlzLm9wdGlvbnMgfHwge307XG4gICAgKHRoaXMucG9pbnRzIHx8IFtdKS5sZW5ndGggJiYgby5ib3JkZXJXaWR0aCAmJiAodC5zYXZlKCksIE5sKHQsIHRoaXMsIHMsIG4pLCB0LnJlc3RvcmUoKSksIHRoaXMuYW5pbWF0ZWQgJiYgKHRoaXMuX3BvaW50c1VwZGF0ZWQgPSAhMSwgdGhpcy5fcGF0aCA9IHZvaWQgMCk7XG4gIH1cbn1cbmd0LmlkID0gXCJsaW5lXCI7XG5ndC5kZWZhdWx0cyA9IHtcbiAgYm9yZGVyQ2FwU3R5bGU6IFwiYnV0dFwiLFxuICBib3JkZXJEYXNoOiBbXSxcbiAgYm9yZGVyRGFzaE9mZnNldDogMCxcbiAgYm9yZGVySm9pblN0eWxlOiBcIm1pdGVyXCIsXG4gIGJvcmRlcldpZHRoOiAzLFxuICBjYXBCZXppZXJQb2ludHM6ICEwLFxuICBjdWJpY0ludGVycG9sYXRpb25Nb2RlOiBcImRlZmF1bHRcIixcbiAgZmlsbDogITEsXG4gIHNwYW5HYXBzOiAhMSxcbiAgc3RlcHBlZDogITEsXG4gIHRlbnNpb246IDBcbn07XG5ndC5kZWZhdWx0Um91dGVzID0ge1xuICBiYWNrZ3JvdW5kQ29sb3I6IFwiYmFja2dyb3VuZENvbG9yXCIsXG4gIGJvcmRlckNvbG9yOiBcImJvcmRlckNvbG9yXCJcbn07XG5ndC5kZXNjcmlwdG9ycyA9IHtcbiAgX3NjcmlwdGFibGU6ICEwLFxuICBfaW5kZXhhYmxlOiAoaSkgPT4gaSAhPT0gXCJib3JkZXJEYXNoXCIgJiYgaSAhPT0gXCJmaWxsXCJcbn07XG5mdW5jdGlvbiBWcyhpLCB0LCBlLCBzKSB7XG4gIGNvbnN0IG4gPSBpLm9wdGlvbnMsIHsgW2VdOiBvIH0gPSBpLmdldFByb3BzKFtlXSwgcyk7XG4gIHJldHVybiBNYXRoLmFicyh0IC0gbykgPCBuLnJhZGl1cyArIG4uaGl0UmFkaXVzO1xufVxuY2xhc3MgdmUgZXh0ZW5kcyBzdCB7XG4gIGNvbnN0cnVjdG9yKHQpIHtcbiAgICBzdXBlcigpLCB0aGlzLm9wdGlvbnMgPSB2b2lkIDAsIHRoaXMucGFyc2VkID0gdm9pZCAwLCB0aGlzLnNraXAgPSB2b2lkIDAsIHRoaXMuc3RvcCA9IHZvaWQgMCwgdCAmJiBPYmplY3QuYXNzaWduKHRoaXMsIHQpO1xuICB9XG4gIGluUmFuZ2UodCwgZSwgcykge1xuICAgIGNvbnN0IG4gPSB0aGlzLm9wdGlvbnMsIHsgeDogbywgeTogciB9ID0gdGhpcy5nZXRQcm9wcyhbXCJ4XCIsIFwieVwiXSwgcyk7XG4gICAgcmV0dXJuIE1hdGgucG93KHQgLSBvLCAyKSArIE1hdGgucG93KGUgLSByLCAyKSA8IE1hdGgucG93KG4uaGl0UmFkaXVzICsgbi5yYWRpdXMsIDIpO1xuICB9XG4gIGluWFJhbmdlKHQsIGUpIHtcbiAgICByZXR1cm4gVnModGhpcywgdCwgXCJ4XCIsIGUpO1xuICB9XG4gIGluWVJhbmdlKHQsIGUpIHtcbiAgICByZXR1cm4gVnModGhpcywgdCwgXCJ5XCIsIGUpO1xuICB9XG4gIGdldENlbnRlclBvaW50KHQpIHtcbiAgICBjb25zdCB7IHg6IGUsIHk6IHMgfSA9IHRoaXMuZ2V0UHJvcHMoW1wieFwiLCBcInlcIl0sIHQpO1xuICAgIHJldHVybiB7IHg6IGUsIHk6IHMgfTtcbiAgfVxuICBzaXplKHQpIHtcbiAgICB0ID0gdCB8fCB0aGlzLm9wdGlvbnMgfHwge307XG4gICAgbGV0IGUgPSB0LnJhZGl1cyB8fCAwO1xuICAgIGUgPSBNYXRoLm1heChlLCBlICYmIHQuaG92ZXJSYWRpdXMgfHwgMCk7XG4gICAgY29uc3QgcyA9IGUgJiYgdC5ib3JkZXJXaWR0aCB8fCAwO1xuICAgIHJldHVybiAoZSArIHMpICogMjtcbiAgfVxuICBkcmF3KHQsIGUpIHtcbiAgICBjb25zdCBzID0gdGhpcy5vcHRpb25zO1xuICAgIHRoaXMuc2tpcCB8fCBzLnJhZGl1cyA8IDAuMSB8fCAhcmUodGhpcywgZSwgdGhpcy5zaXplKHMpIC8gMikgfHwgKHQuc3Ryb2tlU3R5bGUgPSBzLmJvcmRlckNvbG9yLCB0LmxpbmVXaWR0aCA9IHMuYm9yZGVyV2lkdGgsIHQuZmlsbFN0eWxlID0gcy5iYWNrZ3JvdW5kQ29sb3IsIHlpKHQsIHMsIHRoaXMueCwgdGhpcy55KSk7XG4gIH1cbiAgZ2V0UmFuZ2UoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMub3B0aW9ucyB8fCB7fTtcbiAgICByZXR1cm4gdC5yYWRpdXMgKyB0LmhpdFJhZGl1cztcbiAgfVxufVxudmUuaWQgPSBcInBvaW50XCI7XG52ZS5kZWZhdWx0cyA9IHtcbiAgYm9yZGVyV2lkdGg6IDEsXG4gIGhpdFJhZGl1czogMSxcbiAgaG92ZXJCb3JkZXJXaWR0aDogMSxcbiAgaG92ZXJSYWRpdXM6IDQsXG4gIHBvaW50U3R5bGU6IFwiY2lyY2xlXCIsXG4gIHJhZGl1czogMyxcbiAgcm90YXRpb246IDBcbn07XG52ZS5kZWZhdWx0Um91dGVzID0ge1xuICBiYWNrZ3JvdW5kQ29sb3I6IFwiYmFja2dyb3VuZENvbG9yXCIsXG4gIGJvcmRlckNvbG9yOiBcImJvcmRlckNvbG9yXCJcbn07XG5mdW5jdGlvbiBubyhpLCB0KSB7XG4gIGNvbnN0IHsgeDogZSwgeTogcywgYmFzZTogbiwgd2lkdGg6IG8sIGhlaWdodDogciB9ID0gaS5nZXRQcm9wcyhbXCJ4XCIsIFwieVwiLCBcImJhc2VcIiwgXCJ3aWR0aFwiLCBcImhlaWdodFwiXSwgdCk7XG4gIGxldCBhLCBsLCBjLCBoLCBkO1xuICByZXR1cm4gaS5ob3Jpem9udGFsID8gKGQgPSByIC8gMiwgYSA9IE1hdGgubWluKGUsIG4pLCBsID0gTWF0aC5tYXgoZSwgbiksIGMgPSBzIC0gZCwgaCA9IHMgKyBkKSA6IChkID0gbyAvIDIsIGEgPSBlIC0gZCwgbCA9IGUgKyBkLCBjID0gTWF0aC5taW4ocywgbiksIGggPSBNYXRoLm1heChzLCBuKSksIHsgbGVmdDogYSwgdG9wOiBjLCByaWdodDogbCwgYm90dG9tOiBoIH07XG59XG5mdW5jdGlvbiBidChpLCB0LCBlLCBzKSB7XG4gIHJldHVybiBpID8gMCA6IFkodCwgZSwgcyk7XG59XG5mdW5jdGlvbiBIbChpLCB0LCBlKSB7XG4gIGNvbnN0IHMgPSBpLm9wdGlvbnMuYm9yZGVyV2lkdGgsIG4gPSBpLmJvcmRlclNraXBwZWQsIG8gPSBrbihzKTtcbiAgcmV0dXJuIHtcbiAgICB0OiBidChuLnRvcCwgby50b3AsIDAsIGUpLFxuICAgIHI6IGJ0KG4ucmlnaHQsIG8ucmlnaHQsIDAsIHQpLFxuICAgIGI6IGJ0KG4uYm90dG9tLCBvLmJvdHRvbSwgMCwgZSksXG4gICAgbDogYnQobi5sZWZ0LCBvLmxlZnQsIDAsIHQpXG4gIH07XG59XG5mdW5jdGlvbiBqbChpLCB0LCBlKSB7XG4gIGNvbnN0IHsgZW5hYmxlQm9yZGVyUmFkaXVzOiBzIH0gPSBpLmdldFByb3BzKFtcImVuYWJsZUJvcmRlclJhZGl1c1wiXSksIG4gPSBpLm9wdGlvbnMuYm9yZGVyUmFkaXVzLCBvID0gRHQobiksIHIgPSBNYXRoLm1pbih0LCBlKSwgYSA9IGkuYm9yZGVyU2tpcHBlZCwgbCA9IHMgfHwgRChuKTtcbiAgcmV0dXJuIHtcbiAgICB0b3BMZWZ0OiBidCghbCB8fCBhLnRvcCB8fCBhLmxlZnQsIG8udG9wTGVmdCwgMCwgciksXG4gICAgdG9wUmlnaHQ6IGJ0KCFsIHx8IGEudG9wIHx8IGEucmlnaHQsIG8udG9wUmlnaHQsIDAsIHIpLFxuICAgIGJvdHRvbUxlZnQ6IGJ0KCFsIHx8IGEuYm90dG9tIHx8IGEubGVmdCwgby5ib3R0b21MZWZ0LCAwLCByKSxcbiAgICBib3R0b21SaWdodDogYnQoIWwgfHwgYS5ib3R0b20gfHwgYS5yaWdodCwgby5ib3R0b21SaWdodCwgMCwgcilcbiAgfTtcbn1cbmZ1bmN0aW9uICRsKGkpIHtcbiAgY29uc3QgdCA9IG5vKGkpLCBlID0gdC5yaWdodCAtIHQubGVmdCwgcyA9IHQuYm90dG9tIC0gdC50b3AsIG4gPSBIbChpLCBlIC8gMiwgcyAvIDIpLCBvID0gamwoaSwgZSAvIDIsIHMgLyAyKTtcbiAgcmV0dXJuIHtcbiAgICBvdXRlcjoge1xuICAgICAgeDogdC5sZWZ0LFxuICAgICAgeTogdC50b3AsXG4gICAgICB3OiBlLFxuICAgICAgaDogcyxcbiAgICAgIHJhZGl1czogb1xuICAgIH0sXG4gICAgaW5uZXI6IHtcbiAgICAgIHg6IHQubGVmdCArIG4ubCxcbiAgICAgIHk6IHQudG9wICsgbi50LFxuICAgICAgdzogZSAtIG4ubCAtIG4ucixcbiAgICAgIGg6IHMgLSBuLnQgLSBuLmIsXG4gICAgICByYWRpdXM6IHtcbiAgICAgICAgdG9wTGVmdDogTWF0aC5tYXgoMCwgby50b3BMZWZ0IC0gTWF0aC5tYXgobi50LCBuLmwpKSxcbiAgICAgICAgdG9wUmlnaHQ6IE1hdGgubWF4KDAsIG8udG9wUmlnaHQgLSBNYXRoLm1heChuLnQsIG4ucikpLFxuICAgICAgICBib3R0b21MZWZ0OiBNYXRoLm1heCgwLCBvLmJvdHRvbUxlZnQgLSBNYXRoLm1heChuLmIsIG4ubCkpLFxuICAgICAgICBib3R0b21SaWdodDogTWF0aC5tYXgoMCwgby5ib3R0b21SaWdodCAtIE1hdGgubWF4KG4uYiwgbi5yKSlcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBnaShpLCB0LCBlLCBzKSB7XG4gIGNvbnN0IG4gPSB0ID09PSBudWxsLCBvID0gZSA9PT0gbnVsbCwgYSA9IGkgJiYgIShuICYmIG8pICYmIG5vKGksIHMpO1xuICByZXR1cm4gYSAmJiAobiB8fCB1dCh0LCBhLmxlZnQsIGEucmlnaHQpKSAmJiAobyB8fCB1dChlLCBhLnRvcCwgYS5ib3R0b20pKTtcbn1cbmZ1bmN0aW9uIFlsKGkpIHtcbiAgcmV0dXJuIGkudG9wTGVmdCB8fCBpLnRvcFJpZ2h0IHx8IGkuYm90dG9tTGVmdCB8fCBpLmJvdHRvbVJpZ2h0O1xufVxuZnVuY3Rpb24gWGwoaSwgdCkge1xuICBpLnJlY3QodC54LCB0LnksIHQudywgdC5oKTtcbn1cbmZ1bmN0aW9uIHBpKGksIHQsIGUgPSB7fSkge1xuICBjb25zdCBzID0gaS54ICE9PSBlLnggPyAtdCA6IDAsIG4gPSBpLnkgIT09IGUueSA/IC10IDogMCwgbyA9IChpLnggKyBpLncgIT09IGUueCArIGUudyA/IHQgOiAwKSAtIHMsIHIgPSAoaS55ICsgaS5oICE9PSBlLnkgKyBlLmggPyB0IDogMCkgLSBuO1xuICByZXR1cm4ge1xuICAgIHg6IGkueCArIHMsXG4gICAgeTogaS55ICsgbixcbiAgICB3OiBpLncgKyBvLFxuICAgIGg6IGkuaCArIHIsXG4gICAgcmFkaXVzOiBpLnJhZGl1c1xuICB9O1xufVxuY2xhc3MgTWUgZXh0ZW5kcyBzdCB7XG4gIGNvbnN0cnVjdG9yKHQpIHtcbiAgICBzdXBlcigpLCB0aGlzLm9wdGlvbnMgPSB2b2lkIDAsIHRoaXMuaG9yaXpvbnRhbCA9IHZvaWQgMCwgdGhpcy5iYXNlID0gdm9pZCAwLCB0aGlzLndpZHRoID0gdm9pZCAwLCB0aGlzLmhlaWdodCA9IHZvaWQgMCwgdGhpcy5pbmZsYXRlQW1vdW50ID0gdm9pZCAwLCB0ICYmIE9iamVjdC5hc3NpZ24odGhpcywgdCk7XG4gIH1cbiAgZHJhdyh0KSB7XG4gICAgY29uc3QgeyBpbmZsYXRlQW1vdW50OiBlLCBvcHRpb25zOiB7IGJvcmRlckNvbG9yOiBzLCBiYWNrZ3JvdW5kQ29sb3I6IG4gfSB9ID0gdGhpcywgeyBpbm5lcjogbywgb3V0ZXI6IHIgfSA9ICRsKHRoaXMpLCBhID0gWWwoci5yYWRpdXMpID8gYWUgOiBYbDtcbiAgICB0LnNhdmUoKSwgKHIudyAhPT0gby53IHx8IHIuaCAhPT0gby5oKSAmJiAodC5iZWdpblBhdGgoKSwgYSh0LCBwaShyLCBlLCBvKSksIHQuY2xpcCgpLCBhKHQsIHBpKG8sIC1lLCByKSksIHQuZmlsbFN0eWxlID0gcywgdC5maWxsKFwiZXZlbm9kZFwiKSksIHQuYmVnaW5QYXRoKCksIGEodCwgcGkobywgZSkpLCB0LmZpbGxTdHlsZSA9IG4sIHQuZmlsbCgpLCB0LnJlc3RvcmUoKTtcbiAgfVxuICBpblJhbmdlKHQsIGUsIHMpIHtcbiAgICByZXR1cm4gZ2kodGhpcywgdCwgZSwgcyk7XG4gIH1cbiAgaW5YUmFuZ2UodCwgZSkge1xuICAgIHJldHVybiBnaSh0aGlzLCB0LCBudWxsLCBlKTtcbiAgfVxuICBpbllSYW5nZSh0LCBlKSB7XG4gICAgcmV0dXJuIGdpKHRoaXMsIG51bGwsIHQsIGUpO1xuICB9XG4gIGdldENlbnRlclBvaW50KHQpIHtcbiAgICBjb25zdCB7IHg6IGUsIHk6IHMsIGJhc2U6IG4sIGhvcml6b250YWw6IG8gfSA9IHRoaXMuZ2V0UHJvcHMoW1wieFwiLCBcInlcIiwgXCJiYXNlXCIsIFwiaG9yaXpvbnRhbFwiXSwgdCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IG8gPyAoZSArIG4pIC8gMiA6IGUsXG4gICAgICB5OiBvID8gcyA6IChzICsgbikgLyAyXG4gICAgfTtcbiAgfVxuICBnZXRSYW5nZSh0KSB7XG4gICAgcmV0dXJuIHQgPT09IFwieFwiID8gdGhpcy53aWR0aCAvIDIgOiB0aGlzLmhlaWdodCAvIDI7XG4gIH1cbn1cbk1lLmlkID0gXCJiYXJcIjtcbk1lLmRlZmF1bHRzID0ge1xuICBib3JkZXJTa2lwcGVkOiBcInN0YXJ0XCIsXG4gIGJvcmRlcldpZHRoOiAwLFxuICBib3JkZXJSYWRpdXM6IDAsXG4gIGluZmxhdGVBbW91bnQ6IFwiYXV0b1wiLFxuICBwb2ludFN0eWxlOiB2b2lkIDBcbn07XG5NZS5kZWZhdWx0Um91dGVzID0ge1xuICBiYWNrZ3JvdW5kQ29sb3I6IFwiYmFja2dyb3VuZENvbG9yXCIsXG4gIGJvcmRlckNvbG9yOiBcImJvcmRlckNvbG9yXCJcbn07XG52YXIgb28gPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgQXJjRWxlbWVudDogeWUsXG4gIExpbmVFbGVtZW50OiBndCxcbiAgUG9pbnRFbGVtZW50OiB2ZSxcbiAgQmFyRWxlbWVudDogTWVcbn0pO1xuZnVuY3Rpb24gVWwoaSwgdCwgZSwgcywgbikge1xuICBjb25zdCBvID0gbi5zYW1wbGVzIHx8IHM7XG4gIGlmIChvID49IGUpXG4gICAgcmV0dXJuIGkuc2xpY2UodCwgdCArIGUpO1xuICBjb25zdCByID0gW10sIGEgPSAoZSAtIDIpIC8gKG8gLSAyKTtcbiAgbGV0IGwgPSAwO1xuICBjb25zdCBjID0gdCArIGUgLSAxO1xuICBsZXQgaCA9IHQsIGQsIHUsIGYsIGcsIHA7XG4gIGZvciAocltsKytdID0gaVtoXSwgZCA9IDA7IGQgPCBvIC0gMjsgZCsrKSB7XG4gICAgbGV0IG0gPSAwLCBiID0gMCwgeDtcbiAgICBjb25zdCB2ID0gTWF0aC5mbG9vcigoZCArIDEpICogYSkgKyAxICsgdCwgeSA9IE1hdGgubWluKE1hdGguZmxvb3IoKGQgKyAyKSAqIGEpICsgMSwgZSkgKyB0LCBfID0geSAtIHY7XG4gICAgZm9yICh4ID0gdjsgeCA8IHk7IHgrKylcbiAgICAgIG0gKz0gaVt4XS54LCBiICs9IGlbeF0ueTtcbiAgICBtIC89IF8sIGIgLz0gXztcbiAgICBjb25zdCBNID0gTWF0aC5mbG9vcihkICogYSkgKyAxICsgdCwgayA9IE1hdGgubWluKE1hdGguZmxvb3IoKGQgKyAxKSAqIGEpICsgMSwgZSkgKyB0LCB7IHg6IFMsIHk6IHcgfSA9IGlbaF07XG4gICAgZm9yIChmID0gZyA9IC0xLCB4ID0gTTsgeCA8IGs7IHgrKylcbiAgICAgIGcgPSAwLjUgKiBNYXRoLmFicyhcbiAgICAgICAgKFMgLSBtKSAqIChpW3hdLnkgLSB3KSAtIChTIC0gaVt4XS54KSAqIChiIC0gdylcbiAgICAgICksIGcgPiBmICYmIChmID0gZywgdSA9IGlbeF0sIHAgPSB4KTtcbiAgICByW2wrK10gPSB1LCBoID0gcDtcbiAgfVxuICByZXR1cm4gcltsKytdID0gaVtjXSwgcjtcbn1cbmZ1bmN0aW9uIEtsKGksIHQsIGUsIHMpIHtcbiAgbGV0IG4gPSAwLCBvID0gMCwgciwgYSwgbCwgYywgaCwgZCwgdSwgZiwgZywgcDtcbiAgY29uc3QgbSA9IFtdLCBiID0gdCArIGUgLSAxLCB4ID0gaVt0XS54LCB5ID0gaVtiXS54IC0geDtcbiAgZm9yIChyID0gdDsgciA8IHQgKyBlOyArK3IpIHtcbiAgICBhID0gaVtyXSwgbCA9IChhLnggLSB4KSAvIHkgKiBzLCBjID0gYS55O1xuICAgIGNvbnN0IF8gPSBsIHwgMDtcbiAgICBpZiAoXyA9PT0gaClcbiAgICAgIGMgPCBnID8gKGcgPSBjLCBkID0gcikgOiBjID4gcCAmJiAocCA9IGMsIHUgPSByKSwgbiA9IChvICogbiArIGEueCkgLyArK287XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCBNID0gciAtIDE7XG4gICAgICBpZiAoIVQoZCkgJiYgIVQodSkpIHtcbiAgICAgICAgY29uc3QgayA9IE1hdGgubWluKGQsIHUpLCBTID0gTWF0aC5tYXgoZCwgdSk7XG4gICAgICAgIGsgIT09IGYgJiYgayAhPT0gTSAmJiBtLnB1c2goe1xuICAgICAgICAgIC4uLmlba10sXG4gICAgICAgICAgeDogblxuICAgICAgICB9KSwgUyAhPT0gZiAmJiBTICE9PSBNICYmIG0ucHVzaCh7XG4gICAgICAgICAgLi4uaVtTXSxcbiAgICAgICAgICB4OiBuXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgciA+IDAgJiYgTSAhPT0gZiAmJiBtLnB1c2goaVtNXSksIG0ucHVzaChhKSwgaCA9IF8sIG8gPSAwLCBnID0gcCA9IGMsIGQgPSB1ID0gZiA9IHI7XG4gICAgfVxuICB9XG4gIHJldHVybiBtO1xufVxuZnVuY3Rpb24gcm8oaSkge1xuICBpZiAoaS5fZGVjaW1hdGVkKSB7XG4gICAgY29uc3QgdCA9IGkuX2RhdGE7XG4gICAgZGVsZXRlIGkuX2RlY2ltYXRlZCwgZGVsZXRlIGkuX2RhdGEsIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpLCBcImRhdGFcIiwgeyB2YWx1ZTogdCB9KTtcbiAgfVxufVxuZnVuY3Rpb24gV3MoaSkge1xuICBpLmRhdGEuZGF0YXNldHMuZm9yRWFjaCgodCkgPT4ge1xuICAgIHJvKHQpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHFsKGksIHQpIHtcbiAgY29uc3QgZSA9IHQubGVuZ3RoO1xuICBsZXQgcyA9IDAsIG47XG4gIGNvbnN0IHsgaVNjYWxlOiBvIH0gPSBpLCB7IG1pbjogciwgbWF4OiBhLCBtaW5EZWZpbmVkOiBsLCBtYXhEZWZpbmVkOiBjIH0gPSBvLmdldFVzZXJCb3VuZHMoKTtcbiAgcmV0dXJuIGwgJiYgKHMgPSBZKGZ0KHQsIG8uYXhpcywgcikubG8sIDAsIGUgLSAxKSksIGMgPyBuID0gWShmdCh0LCBvLmF4aXMsIGEpLmhpICsgMSwgcywgZSkgLSBzIDogbiA9IGUgLSBzLCB7IHN0YXJ0OiBzLCBjb3VudDogbiB9O1xufVxudmFyIGFvID0ge1xuICBpZDogXCJkZWNpbWF0aW9uXCIsXG4gIGRlZmF1bHRzOiB7XG4gICAgYWxnb3JpdGhtOiBcIm1pbi1tYXhcIixcbiAgICBlbmFibGVkOiAhMVxuICB9LFxuICBiZWZvcmVFbGVtZW50c1VwZGF0ZTogKGksIHQsIGUpID0+IHtcbiAgICBpZiAoIWUuZW5hYmxlZCkge1xuICAgICAgV3MoaSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHMgPSBpLndpZHRoO1xuICAgIGkuZGF0YS5kYXRhc2V0cy5mb3JFYWNoKChuLCBvKSA9PiB7XG4gICAgICBjb25zdCB7IF9kYXRhOiByLCBpbmRleEF4aXM6IGEgfSA9IG4sIGwgPSBpLmdldERhdGFzZXRNZXRhKG8pLCBjID0gciB8fCBuLmRhdGE7XG4gICAgICBpZiAoWnQoW2EsIGkub3B0aW9ucy5pbmRleEF4aXNdKSA9PT0gXCJ5XCIgfHwgIWwuY29udHJvbGxlci5zdXBwb3J0c0RlY2ltYXRpb24pXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IGggPSBpLnNjYWxlc1tsLnhBeGlzSURdO1xuICAgICAgaWYgKGgudHlwZSAhPT0gXCJsaW5lYXJcIiAmJiBoLnR5cGUgIT09IFwidGltZVwiIHx8IGkub3B0aW9ucy5wYXJzaW5nKVxuICAgICAgICByZXR1cm47XG4gICAgICBsZXQgeyBzdGFydDogZCwgY291bnQ6IHUgfSA9IHFsKGwsIGMpO1xuICAgICAgY29uc3QgZiA9IGUudGhyZXNob2xkIHx8IDQgKiBzO1xuICAgICAgaWYgKHUgPD0gZikge1xuICAgICAgICBybyhuKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgVChyKSAmJiAobi5fZGF0YSA9IGMsIGRlbGV0ZSBuLmRhdGEsIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBcImRhdGFcIiwge1xuICAgICAgICBjb25maWd1cmFibGU6ICEwLFxuICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZGVjaW1hdGVkO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICB0aGlzLl9kYXRhID0gcDtcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgICAgbGV0IGc7XG4gICAgICBzd2l0Y2ggKGUuYWxnb3JpdGhtKSB7XG4gICAgICAgIGNhc2UgXCJsdHRiXCI6XG4gICAgICAgICAgZyA9IFVsKGMsIGQsIHUsIHMsIGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibWluLW1heFwiOlxuICAgICAgICAgIGcgPSBLbChjLCBkLCB1LCBzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGRlY2ltYXRpb24gYWxnb3JpdGhtICcke2UuYWxnb3JpdGhtfSdgKTtcbiAgICAgIH1cbiAgICAgIG4uX2RlY2ltYXRlZCA9IGc7XG4gICAgfSk7XG4gIH0sXG4gIGRlc3Ryb3koaSkge1xuICAgIFdzKGkpO1xuICB9XG59O1xuZnVuY3Rpb24gR2woaSwgdCwgZSkge1xuICBjb25zdCBzID0gaS5zZWdtZW50cywgbiA9IGkucG9pbnRzLCBvID0gdC5wb2ludHMsIHIgPSBbXTtcbiAgZm9yIChjb25zdCBhIG9mIHMpIHtcbiAgICBsZXQgeyBzdGFydDogbCwgZW5kOiBjIH0gPSBhO1xuICAgIGMgPSAkaShsLCBjLCBuKTtcbiAgICBjb25zdCBoID0gUGkoZSwgbltsXSwgbltjXSwgYS5sb29wKTtcbiAgICBpZiAoIXQuc2VnbWVudHMpIHtcbiAgICAgIHIucHVzaCh7XG4gICAgICAgIHNvdXJjZTogYSxcbiAgICAgICAgdGFyZ2V0OiBoLFxuICAgICAgICBzdGFydDogbltsXSxcbiAgICAgICAgZW5kOiBuW2NdXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBkID0gRm4odCwgaCk7XG4gICAgZm9yIChjb25zdCB1IG9mIGQpIHtcbiAgICAgIGNvbnN0IGYgPSBQaShlLCBvW3Uuc3RhcnRdLCBvW3UuZW5kXSwgdS5sb29wKSwgZyA9IEVuKGEsIG4sIGYpO1xuICAgICAgZm9yIChjb25zdCBwIG9mIGcpXG4gICAgICAgIHIucHVzaCh7XG4gICAgICAgICAgc291cmNlOiBwLFxuICAgICAgICAgIHRhcmdldDogdSxcbiAgICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgW2VdOiBOcyhoLCBmLCBcInN0YXJ0XCIsIE1hdGgubWF4KVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZW5kOiB7XG4gICAgICAgICAgICBbZV06IE5zKGgsIGYsIFwiZW5kXCIsIE1hdGgubWluKVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByO1xufVxuZnVuY3Rpb24gUGkoaSwgdCwgZSwgcykge1xuICBpZiAocylcbiAgICByZXR1cm47XG4gIGxldCBuID0gdFtpXSwgbyA9IGVbaV07XG4gIHJldHVybiBpID09PSBcImFuZ2xlXCIgJiYgKG4gPSBaKG4pLCBvID0gWihvKSksIHsgcHJvcGVydHk6IGksIHN0YXJ0OiBuLCBlbmQ6IG8gfTtcbn1cbmZ1bmN0aW9uIFpsKGksIHQpIHtcbiAgY29uc3QgeyB4OiBlID0gbnVsbCwgeTogcyA9IG51bGwgfSA9IGkgfHwge30sIG4gPSB0LnBvaW50cywgbyA9IFtdO1xuICByZXR1cm4gdC5zZWdtZW50cy5mb3JFYWNoKCh7IHN0YXJ0OiByLCBlbmQ6IGEgfSkgPT4ge1xuICAgIGEgPSAkaShyLCBhLCBuKTtcbiAgICBjb25zdCBsID0gbltyXSwgYyA9IG5bYV07XG4gICAgcyAhPT0gbnVsbCA/IChvLnB1c2goeyB4OiBsLngsIHk6IHMgfSksIG8ucHVzaCh7IHg6IGMueCwgeTogcyB9KSkgOiBlICE9PSBudWxsICYmIChvLnB1c2goeyB4OiBlLCB5OiBsLnkgfSksIG8ucHVzaCh7IHg6IGUsIHk6IGMueSB9KSk7XG4gIH0pLCBvO1xufVxuZnVuY3Rpb24gJGkoaSwgdCwgZSkge1xuICBmb3IgKDsgdCA+IGk7IHQtLSkge1xuICAgIGNvbnN0IHMgPSBlW3RdO1xuICAgIGlmICghaXNOYU4ocy54KSAmJiAhaXNOYU4ocy55KSlcbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiB0O1xufVxuZnVuY3Rpb24gTnMoaSwgdCwgZSwgcykge1xuICByZXR1cm4gaSAmJiB0ID8gcyhpW2VdLCB0W2VdKSA6IGkgPyBpW2VdIDogdCA/IHRbZV0gOiAwO1xufVxuZnVuY3Rpb24gbG8oaSwgdCkge1xuICBsZXQgZSA9IFtdLCBzID0gITE7XG4gIHJldHVybiB6KGkpID8gKHMgPSAhMCwgZSA9IGkpIDogZSA9IFpsKGksIHQpLCBlLmxlbmd0aCA/IG5ldyBndCh7XG4gICAgcG9pbnRzOiBlLFxuICAgIG9wdGlvbnM6IHsgdGVuc2lvbjogMCB9LFxuICAgIF9sb29wOiBzLFxuICAgIF9mdWxsTG9vcDogc1xuICB9KSA6IG51bGw7XG59XG5mdW5jdGlvbiBIcyhpKSB7XG4gIHJldHVybiBpICYmIGkuZmlsbCAhPT0gITE7XG59XG5mdW5jdGlvbiBKbChpLCB0LCBlKSB7XG4gIGxldCBuID0gaVt0XS5maWxsO1xuICBjb25zdCBvID0gW3RdO1xuICBsZXQgcjtcbiAgaWYgKCFlKVxuICAgIHJldHVybiBuO1xuICBmb3IgKDsgbiAhPT0gITEgJiYgby5pbmRleE9mKG4pID09PSAtMTsgKSB7XG4gICAgaWYgKCFOKG4pKVxuICAgICAgcmV0dXJuIG47XG4gICAgaWYgKHIgPSBpW25dLCAhcilcbiAgICAgIHJldHVybiAhMTtcbiAgICBpZiAoci52aXNpYmxlKVxuICAgICAgcmV0dXJuIG47XG4gICAgby5wdXNoKG4pLCBuID0gci5maWxsO1xuICB9XG4gIHJldHVybiAhMTtcbn1cbmZ1bmN0aW9uIFFsKGksIHQsIGUpIHtcbiAgY29uc3QgcyA9IHNjKGkpO1xuICBpZiAoRChzKSlcbiAgICByZXR1cm4gaXNOYU4ocy52YWx1ZSkgPyAhMSA6IHM7XG4gIGxldCBuID0gcGFyc2VGbG9hdChzKTtcbiAgcmV0dXJuIE4obikgJiYgTWF0aC5mbG9vcihuKSA9PT0gbiA/IHRjKHNbMF0sIHQsIG4sIGUpIDogW1wib3JpZ2luXCIsIFwic3RhcnRcIiwgXCJlbmRcIiwgXCJzdGFja1wiLCBcInNoYXBlXCJdLmluZGV4T2YocykgPj0gMCAmJiBzO1xufVxuZnVuY3Rpb24gdGMoaSwgdCwgZSwgcykge1xuICByZXR1cm4gKGkgPT09IFwiLVwiIHx8IGkgPT09IFwiK1wiKSAmJiAoZSA9IHQgKyBlKSwgZSA9PT0gdCB8fCBlIDwgMCB8fCBlID49IHMgPyAhMSA6IGU7XG59XG5mdW5jdGlvbiBlYyhpLCB0KSB7XG4gIGxldCBlID0gbnVsbDtcbiAgcmV0dXJuIGkgPT09IFwic3RhcnRcIiA/IGUgPSB0LmJvdHRvbSA6IGkgPT09IFwiZW5kXCIgPyBlID0gdC50b3AgOiBEKGkpID8gZSA9IHQuZ2V0UGl4ZWxGb3JWYWx1ZShpLnZhbHVlKSA6IHQuZ2V0QmFzZVBpeGVsICYmIChlID0gdC5nZXRCYXNlUGl4ZWwoKSksIGU7XG59XG5mdW5jdGlvbiBpYyhpLCB0LCBlKSB7XG4gIGxldCBzO1xuICByZXR1cm4gaSA9PT0gXCJzdGFydFwiID8gcyA9IGUgOiBpID09PSBcImVuZFwiID8gcyA9IHQub3B0aW9ucy5yZXZlcnNlID8gdC5taW4gOiB0Lm1heCA6IEQoaSkgPyBzID0gaS52YWx1ZSA6IHMgPSB0LmdldEJhc2VWYWx1ZSgpLCBzO1xufVxuZnVuY3Rpb24gc2MoaSkge1xuICBjb25zdCB0ID0gaS5vcHRpb25zLCBlID0gdC5maWxsO1xuICBsZXQgcyA9IEMoZSAmJiBlLnRhcmdldCwgZSk7XG4gIHJldHVybiBzID09PSB2b2lkIDAgJiYgKHMgPSAhIXQuYmFja2dyb3VuZENvbG9yKSwgcyA9PT0gITEgfHwgcyA9PT0gbnVsbCA/ICExIDogcyA9PT0gITAgPyBcIm9yaWdpblwiIDogcztcbn1cbmZ1bmN0aW9uIG5jKGkpIHtcbiAgY29uc3QgeyBzY2FsZTogdCwgaW5kZXg6IGUsIGxpbmU6IHMgfSA9IGksIG4gPSBbXSwgbyA9IHMuc2VnbWVudHMsIHIgPSBzLnBvaW50cywgYSA9IG9jKHQsIGUpO1xuICBhLnB1c2gobG8oeyB4OiBudWxsLCB5OiB0LmJvdHRvbSB9LCBzKSk7XG4gIGZvciAobGV0IGwgPSAwOyBsIDwgby5sZW5ndGg7IGwrKykge1xuICAgIGNvbnN0IGMgPSBvW2xdO1xuICAgIGZvciAobGV0IGggPSBjLnN0YXJ0OyBoIDw9IGMuZW5kOyBoKyspXG4gICAgICByYyhuLCByW2hdLCBhKTtcbiAgfVxuICByZXR1cm4gbmV3IGd0KHsgcG9pbnRzOiBuLCBvcHRpb25zOiB7fSB9KTtcbn1cbmZ1bmN0aW9uIG9jKGksIHQpIHtcbiAgY29uc3QgZSA9IFtdLCBzID0gaS5nZXRNYXRjaGluZ1Zpc2libGVNZXRhcyhcImxpbmVcIik7XG4gIGZvciAobGV0IG4gPSAwOyBuIDwgcy5sZW5ndGg7IG4rKykge1xuICAgIGNvbnN0IG8gPSBzW25dO1xuICAgIGlmIChvLmluZGV4ID09PSB0KVxuICAgICAgYnJlYWs7XG4gICAgby5oaWRkZW4gfHwgZS51bnNoaWZ0KG8uZGF0YXNldCk7XG4gIH1cbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiByYyhpLCB0LCBlKSB7XG4gIGNvbnN0IHMgPSBbXTtcbiAgZm9yIChsZXQgbiA9IDA7IG4gPCBlLmxlbmd0aDsgbisrKSB7XG4gICAgY29uc3QgbyA9IGVbbl0sIHsgZmlyc3Q6IHIsIGxhc3Q6IGEsIHBvaW50OiBsIH0gPSBhYyhvLCB0LCBcInhcIik7XG4gICAgaWYgKCEoIWwgfHwgciAmJiBhKSkge1xuICAgICAgaWYgKHIpXG4gICAgICAgIHMudW5zaGlmdChsKTtcbiAgICAgIGVsc2UgaWYgKGkucHVzaChsKSwgIWEpXG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBpLnB1c2goLi4ucyk7XG59XG5mdW5jdGlvbiBhYyhpLCB0LCBlKSB7XG4gIGNvbnN0IHMgPSBpLmludGVycG9sYXRlKHQsIGUpO1xuICBpZiAoIXMpXG4gICAgcmV0dXJuIHt9O1xuICBjb25zdCBuID0gc1tlXSwgbyA9IGkuc2VnbWVudHMsIHIgPSBpLnBvaW50cztcbiAgbGV0IGEgPSAhMSwgbCA9ICExO1xuICBmb3IgKGxldCBjID0gMDsgYyA8IG8ubGVuZ3RoOyBjKyspIHtcbiAgICBjb25zdCBoID0gb1tjXSwgZCA9IHJbaC5zdGFydF1bZV0sIHUgPSByW2guZW5kXVtlXTtcbiAgICBpZiAodXQobiwgZCwgdSkpIHtcbiAgICAgIGEgPSBuID09PSBkLCBsID0gbiA9PT0gdTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4geyBmaXJzdDogYSwgbGFzdDogbCwgcG9pbnQ6IHMgfTtcbn1cbmNsYXNzIGNvIHtcbiAgY29uc3RydWN0b3IodCkge1xuICAgIHRoaXMueCA9IHQueCwgdGhpcy55ID0gdC55LCB0aGlzLnJhZGl1cyA9IHQucmFkaXVzO1xuICB9XG4gIHBhdGhTZWdtZW50KHQsIGUsIHMpIHtcbiAgICBjb25zdCB7IHg6IG4sIHk6IG8sIHJhZGl1czogciB9ID0gdGhpcztcbiAgICByZXR1cm4gZSA9IGUgfHwgeyBzdGFydDogMCwgZW5kOiBGIH0sIHQuYXJjKG4sIG8sIHIsIGUuZW5kLCBlLnN0YXJ0LCAhMCksICFzLmJvdW5kcztcbiAgfVxuICBpbnRlcnBvbGF0ZSh0KSB7XG4gICAgY29uc3QgeyB4OiBlLCB5OiBzLCByYWRpdXM6IG4gfSA9IHRoaXMsIG8gPSB0LmFuZ2xlO1xuICAgIHJldHVybiB7XG4gICAgICB4OiBlICsgTWF0aC5jb3MobykgKiBuLFxuICAgICAgeTogcyArIE1hdGguc2luKG8pICogbixcbiAgICAgIGFuZ2xlOiBvXG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gbGMoaSkge1xuICBjb25zdCB7IGNoYXJ0OiB0LCBmaWxsOiBlLCBsaW5lOiBzIH0gPSBpO1xuICBpZiAoTihlKSlcbiAgICByZXR1cm4gY2ModCwgZSk7XG4gIGlmIChlID09PSBcInN0YWNrXCIpXG4gICAgcmV0dXJuIG5jKGkpO1xuICBpZiAoZSA9PT0gXCJzaGFwZVwiKVxuICAgIHJldHVybiAhMDtcbiAgY29uc3QgbiA9IGhjKGkpO1xuICByZXR1cm4gbiBpbnN0YW5jZW9mIGNvID8gbiA6IGxvKG4sIHMpO1xufVxuZnVuY3Rpb24gY2MoaSwgdCkge1xuICBjb25zdCBlID0gaS5nZXREYXRhc2V0TWV0YSh0KTtcbiAgcmV0dXJuIGUgJiYgaS5pc0RhdGFzZXRWaXNpYmxlKHQpID8gZS5kYXRhc2V0IDogbnVsbDtcbn1cbmZ1bmN0aW9uIGhjKGkpIHtcbiAgcmV0dXJuIChpLnNjYWxlIHx8IHt9KS5nZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUgPyB1YyhpKSA6IGRjKGkpO1xufVxuZnVuY3Rpb24gZGMoaSkge1xuICBjb25zdCB7IHNjYWxlOiB0ID0ge30sIGZpbGw6IGUgfSA9IGksIHMgPSBlYyhlLCB0KTtcbiAgaWYgKE4ocykpIHtcbiAgICBjb25zdCBuID0gdC5pc0hvcml6b250YWwoKTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogbiA/IHMgOiBudWxsLFxuICAgICAgeTogbiA/IG51bGwgOiBzXG4gICAgfTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHVjKGkpIHtcbiAgY29uc3QgeyBzY2FsZTogdCwgZmlsbDogZSB9ID0gaSwgcyA9IHQub3B0aW9ucywgbiA9IHQuZ2V0TGFiZWxzKCkubGVuZ3RoLCBvID0gcy5yZXZlcnNlID8gdC5tYXggOiB0Lm1pbiwgciA9IGljKGUsIHQsIG8pLCBhID0gW107XG4gIGlmIChzLmdyaWQuY2lyY3VsYXIpIHtcbiAgICBjb25zdCBsID0gdC5nZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUoMCwgbyk7XG4gICAgcmV0dXJuIG5ldyBjbyh7XG4gICAgICB4OiBsLngsXG4gICAgICB5OiBsLnksXG4gICAgICByYWRpdXM6IHQuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUocilcbiAgICB9KTtcbiAgfVxuICBmb3IgKGxldCBsID0gMDsgbCA8IG47ICsrbClcbiAgICBhLnB1c2godC5nZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUobCwgcikpO1xuICByZXR1cm4gYTtcbn1cbmZ1bmN0aW9uIG1pKGksIHQsIGUpIHtcbiAgY29uc3QgcyA9IGxjKHQpLCB7IGxpbmU6IG4sIHNjYWxlOiBvLCBheGlzOiByIH0gPSB0LCBhID0gbi5vcHRpb25zLCBsID0gYS5maWxsLCBjID0gYS5iYWNrZ3JvdW5kQ29sb3IsIHsgYWJvdmU6IGggPSBjLCBiZWxvdzogZCA9IGMgfSA9IGwgfHwge307XG4gIHMgJiYgbi5wb2ludHMubGVuZ3RoICYmIChYZShpLCBlKSwgZmMoaSwgeyBsaW5lOiBuLCB0YXJnZXQ6IHMsIGFib3ZlOiBoLCBiZWxvdzogZCwgYXJlYTogZSwgc2NhbGU6IG8sIGF4aXM6IHIgfSksIFVlKGkpKTtcbn1cbmZ1bmN0aW9uIGZjKGksIHQpIHtcbiAgY29uc3QgeyBsaW5lOiBlLCB0YXJnZXQ6IHMsIGFib3ZlOiBuLCBiZWxvdzogbywgYXJlYTogciwgc2NhbGU6IGEgfSA9IHQsIGwgPSBlLl9sb29wID8gXCJhbmdsZVwiIDogdC5heGlzO1xuICBpLnNhdmUoKSwgbCA9PT0gXCJ4XCIgJiYgbyAhPT0gbiAmJiAoanMoaSwgcywgci50b3ApLCAkcyhpLCB7IGxpbmU6IGUsIHRhcmdldDogcywgY29sb3I6IG4sIHNjYWxlOiBhLCBwcm9wZXJ0eTogbCB9KSwgaS5yZXN0b3JlKCksIGkuc2F2ZSgpLCBqcyhpLCBzLCByLmJvdHRvbSkpLCAkcyhpLCB7IGxpbmU6IGUsIHRhcmdldDogcywgY29sb3I6IG8sIHNjYWxlOiBhLCBwcm9wZXJ0eTogbCB9KSwgaS5yZXN0b3JlKCk7XG59XG5mdW5jdGlvbiBqcyhpLCB0LCBlKSB7XG4gIGNvbnN0IHsgc2VnbWVudHM6IHMsIHBvaW50czogbiB9ID0gdDtcbiAgbGV0IG8gPSAhMCwgciA9ICExO1xuICBpLmJlZ2luUGF0aCgpO1xuICBmb3IgKGNvbnN0IGEgb2Ygcykge1xuICAgIGNvbnN0IHsgc3RhcnQ6IGwsIGVuZDogYyB9ID0gYSwgaCA9IG5bbF0sIGQgPSBuWyRpKGwsIGMsIG4pXTtcbiAgICBvID8gKGkubW92ZVRvKGgueCwgaC55KSwgbyA9ICExKSA6IChpLmxpbmVUbyhoLngsIGUpLCBpLmxpbmVUbyhoLngsIGgueSkpLCByID0gISF0LnBhdGhTZWdtZW50KGksIGEsIHsgbW92ZTogciB9KSwgciA/IGkuY2xvc2VQYXRoKCkgOiBpLmxpbmVUbyhkLngsIGUpO1xuICB9XG4gIGkubGluZVRvKHQuZmlyc3QoKS54LCBlKSwgaS5jbG9zZVBhdGgoKSwgaS5jbGlwKCk7XG59XG5mdW5jdGlvbiAkcyhpLCB0KSB7XG4gIGNvbnN0IHsgbGluZTogZSwgdGFyZ2V0OiBzLCBwcm9wZXJ0eTogbiwgY29sb3I6IG8sIHNjYWxlOiByIH0gPSB0LCBhID0gR2woZSwgcywgbik7XG4gIGZvciAoY29uc3QgeyBzb3VyY2U6IGwsIHRhcmdldDogYywgc3RhcnQ6IGgsIGVuZDogZCB9IG9mIGEpIHtcbiAgICBjb25zdCB7IHN0eWxlOiB7IGJhY2tncm91bmRDb2xvcjogdSA9IG8gfSA9IHt9IH0gPSBsLCBmID0gcyAhPT0gITA7XG4gICAgaS5zYXZlKCksIGkuZmlsbFN0eWxlID0gdSwgZ2MoaSwgciwgZiAmJiBQaShuLCBoLCBkKSksIGkuYmVnaW5QYXRoKCk7XG4gICAgY29uc3QgZyA9ICEhZS5wYXRoU2VnbWVudChpLCBsKTtcbiAgICBsZXQgcDtcbiAgICBpZiAoZikge1xuICAgICAgZyA/IGkuY2xvc2VQYXRoKCkgOiBZcyhpLCBzLCBkLCBuKTtcbiAgICAgIGNvbnN0IG0gPSAhIXMucGF0aFNlZ21lbnQoaSwgYywgeyBtb3ZlOiBnLCByZXZlcnNlOiAhMCB9KTtcbiAgICAgIHAgPSBnICYmIG0sIHAgfHwgWXMoaSwgcywgaCwgbik7XG4gICAgfVxuICAgIGkuY2xvc2VQYXRoKCksIGkuZmlsbChwID8gXCJldmVub2RkXCIgOiBcIm5vbnplcm9cIiksIGkucmVzdG9yZSgpO1xuICB9XG59XG5mdW5jdGlvbiBnYyhpLCB0LCBlKSB7XG4gIGNvbnN0IHsgdG9wOiBzLCBib3R0b206IG4gfSA9IHQuY2hhcnQuY2hhcnRBcmVhLCB7IHByb3BlcnR5OiBvLCBzdGFydDogciwgZW5kOiBhIH0gPSBlIHx8IHt9O1xuICBvID09PSBcInhcIiAmJiAoaS5iZWdpblBhdGgoKSwgaS5yZWN0KHIsIHMsIGEgLSByLCBuIC0gcyksIGkuY2xpcCgpKTtcbn1cbmZ1bmN0aW9uIFlzKGksIHQsIGUsIHMpIHtcbiAgY29uc3QgbiA9IHQuaW50ZXJwb2xhdGUoZSwgcyk7XG4gIG4gJiYgaS5saW5lVG8obi54LCBuLnkpO1xufVxudmFyIGhvID0ge1xuICBpZDogXCJmaWxsZXJcIixcbiAgYWZ0ZXJEYXRhc2V0c1VwZGF0ZShpLCB0LCBlKSB7XG4gICAgY29uc3QgcyA9IChpLmRhdGEuZGF0YXNldHMgfHwgW10pLmxlbmd0aCwgbiA9IFtdO1xuICAgIGxldCBvLCByLCBhLCBsO1xuICAgIGZvciAociA9IDA7IHIgPCBzOyArK3IpXG4gICAgICBvID0gaS5nZXREYXRhc2V0TWV0YShyKSwgYSA9IG8uZGF0YXNldCwgbCA9IG51bGwsIGEgJiYgYS5vcHRpb25zICYmIGEgaW5zdGFuY2VvZiBndCAmJiAobCA9IHtcbiAgICAgICAgdmlzaWJsZTogaS5pc0RhdGFzZXRWaXNpYmxlKHIpLFxuICAgICAgICBpbmRleDogcixcbiAgICAgICAgZmlsbDogUWwoYSwgciwgcyksXG4gICAgICAgIGNoYXJ0OiBpLFxuICAgICAgICBheGlzOiBvLmNvbnRyb2xsZXIub3B0aW9ucy5pbmRleEF4aXMsXG4gICAgICAgIHNjYWxlOiBvLnZTY2FsZSxcbiAgICAgICAgbGluZTogYVxuICAgICAgfSksIG8uJGZpbGxlciA9IGwsIG4ucHVzaChsKTtcbiAgICBmb3IgKHIgPSAwOyByIDwgczsgKytyKVxuICAgICAgbCA9IG5bcl0sICEoIWwgfHwgbC5maWxsID09PSAhMSkgJiYgKGwuZmlsbCA9IEpsKG4sIHIsIGUucHJvcGFnYXRlKSk7XG4gIH0sXG4gIGJlZm9yZURyYXcoaSwgdCwgZSkge1xuICAgIGNvbnN0IHMgPSBlLmRyYXdUaW1lID09PSBcImJlZm9yZURyYXdcIiwgbiA9IGkuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpLCBvID0gaS5jaGFydEFyZWE7XG4gICAgZm9yIChsZXQgciA9IG4ubGVuZ3RoIC0gMTsgciA+PSAwOyAtLXIpIHtcbiAgICAgIGNvbnN0IGEgPSBuW3JdLiRmaWxsZXI7XG4gICAgICBhICYmIChhLmxpbmUudXBkYXRlQ29udHJvbFBvaW50cyhvLCBhLmF4aXMpLCBzICYmIGEuZmlsbCAmJiBtaShpLmN0eCwgYSwgbykpO1xuICAgIH1cbiAgfSxcbiAgYmVmb3JlRGF0YXNldHNEcmF3KGksIHQsIGUpIHtcbiAgICBpZiAoZS5kcmF3VGltZSAhPT0gXCJiZWZvcmVEYXRhc2V0c0RyYXdcIilcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBzID0gaS5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCk7XG4gICAgZm9yIChsZXQgbiA9IHMubGVuZ3RoIC0gMTsgbiA+PSAwOyAtLW4pIHtcbiAgICAgIGNvbnN0IG8gPSBzW25dLiRmaWxsZXI7XG4gICAgICBIcyhvKSAmJiBtaShpLmN0eCwgbywgaS5jaGFydEFyZWEpO1xuICAgIH1cbiAgfSxcbiAgYmVmb3JlRGF0YXNldERyYXcoaSwgdCwgZSkge1xuICAgIGNvbnN0IHMgPSB0Lm1ldGEuJGZpbGxlcjtcbiAgICAhSHMocykgfHwgZS5kcmF3VGltZSAhPT0gXCJiZWZvcmVEYXRhc2V0RHJhd1wiIHx8IG1pKGkuY3R4LCBzLCBpLmNoYXJ0QXJlYSk7XG4gIH0sXG4gIGRlZmF1bHRzOiB7XG4gICAgcHJvcGFnYXRlOiAhMCxcbiAgICBkcmF3VGltZTogXCJiZWZvcmVEYXRhc2V0RHJhd1wiXG4gIH1cbn07XG5jb25zdCBYcyA9IChpLCB0KSA9PiB7XG4gIGxldCB7IGJveEhlaWdodDogZSA9IHQsIGJveFdpZHRoOiBzID0gdCB9ID0gaTtcbiAgcmV0dXJuIGkudXNlUG9pbnRTdHlsZSAmJiAoZSA9IE1hdGgubWluKGUsIHQpLCBzID0gaS5wb2ludFN0eWxlV2lkdGggfHwgTWF0aC5taW4ocywgdCkpLCB7XG4gICAgYm94V2lkdGg6IHMsXG4gICAgYm94SGVpZ2h0OiBlLFxuICAgIGl0ZW1IZWlnaHQ6IE1hdGgubWF4KHQsIGUpXG4gIH07XG59LCBwYyA9IChpLCB0KSA9PiBpICE9PSBudWxsICYmIHQgIT09IG51bGwgJiYgaS5kYXRhc2V0SW5kZXggPT09IHQuZGF0YXNldEluZGV4ICYmIGkuaW5kZXggPT09IHQuaW5kZXg7XG5jbGFzcyBVcyBleHRlbmRzIHN0IHtcbiAgY29uc3RydWN0b3IodCkge1xuICAgIHN1cGVyKCksIHRoaXMuX2FkZGVkID0gITEsIHRoaXMubGVnZW5kSGl0Qm94ZXMgPSBbXSwgdGhpcy5faG92ZXJlZEl0ZW0gPSBudWxsLCB0aGlzLmRvdWdobnV0TW9kZSA9ICExLCB0aGlzLmNoYXJ0ID0gdC5jaGFydCwgdGhpcy5vcHRpb25zID0gdC5vcHRpb25zLCB0aGlzLmN0eCA9IHQuY3R4LCB0aGlzLmxlZ2VuZEl0ZW1zID0gdm9pZCAwLCB0aGlzLmNvbHVtblNpemVzID0gdm9pZCAwLCB0aGlzLmxpbmVXaWR0aHMgPSB2b2lkIDAsIHRoaXMubWF4SGVpZ2h0ID0gdm9pZCAwLCB0aGlzLm1heFdpZHRoID0gdm9pZCAwLCB0aGlzLnRvcCA9IHZvaWQgMCwgdGhpcy5ib3R0b20gPSB2b2lkIDAsIHRoaXMubGVmdCA9IHZvaWQgMCwgdGhpcy5yaWdodCA9IHZvaWQgMCwgdGhpcy5oZWlnaHQgPSB2b2lkIDAsIHRoaXMud2lkdGggPSB2b2lkIDAsIHRoaXMuX21hcmdpbnMgPSB2b2lkIDAsIHRoaXMucG9zaXRpb24gPSB2b2lkIDAsIHRoaXMud2VpZ2h0ID0gdm9pZCAwLCB0aGlzLmZ1bGxTaXplID0gdm9pZCAwO1xuICB9XG4gIHVwZGF0ZSh0LCBlLCBzKSB7XG4gICAgdGhpcy5tYXhXaWR0aCA9IHQsIHRoaXMubWF4SGVpZ2h0ID0gZSwgdGhpcy5fbWFyZ2lucyA9IHMsIHRoaXMuc2V0RGltZW5zaW9ucygpLCB0aGlzLmJ1aWxkTGFiZWxzKCksIHRoaXMuZml0KCk7XG4gIH1cbiAgc2V0RGltZW5zaW9ucygpIHtcbiAgICB0aGlzLmlzSG9yaXpvbnRhbCgpID8gKHRoaXMud2lkdGggPSB0aGlzLm1heFdpZHRoLCB0aGlzLmxlZnQgPSB0aGlzLl9tYXJnaW5zLmxlZnQsIHRoaXMucmlnaHQgPSB0aGlzLndpZHRoKSA6ICh0aGlzLmhlaWdodCA9IHRoaXMubWF4SGVpZ2h0LCB0aGlzLnRvcCA9IHRoaXMuX21hcmdpbnMudG9wLCB0aGlzLmJvdHRvbSA9IHRoaXMuaGVpZ2h0KTtcbiAgfVxuICBidWlsZExhYmVscygpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5vcHRpb25zLmxhYmVscyB8fCB7fTtcbiAgICBsZXQgZSA9IEkodC5nZW5lcmF0ZUxhYmVscywgW3RoaXMuY2hhcnRdLCB0aGlzKSB8fCBbXTtcbiAgICB0LmZpbHRlciAmJiAoZSA9IGUuZmlsdGVyKChzKSA9PiB0LmZpbHRlcihzLCB0aGlzLmNoYXJ0LmRhdGEpKSksIHQuc29ydCAmJiAoZSA9IGUuc29ydCgocywgbikgPT4gdC5zb3J0KHMsIG4sIHRoaXMuY2hhcnQuZGF0YSkpKSwgdGhpcy5vcHRpb25zLnJldmVyc2UgJiYgZS5yZXZlcnNlKCksIHRoaXMubGVnZW5kSXRlbXMgPSBlO1xuICB9XG4gIGZpdCgpIHtcbiAgICBjb25zdCB7IG9wdGlvbnM6IHQsIGN0eDogZSB9ID0gdGhpcztcbiAgICBpZiAoIXQuZGlzcGxheSkge1xuICAgICAgdGhpcy53aWR0aCA9IHRoaXMuaGVpZ2h0ID0gMDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcyA9IHQubGFiZWxzLCBuID0gJChzLmZvbnQpLCBvID0gbi5zaXplLCByID0gdGhpcy5fY29tcHV0ZVRpdGxlSGVpZ2h0KCksIHsgYm94V2lkdGg6IGEsIGl0ZW1IZWlnaHQ6IGwgfSA9IFhzKHMsIG8pO1xuICAgIGxldCBjLCBoO1xuICAgIGUuZm9udCA9IG4uc3RyaW5nLCB0aGlzLmlzSG9yaXpvbnRhbCgpID8gKGMgPSB0aGlzLm1heFdpZHRoLCBoID0gdGhpcy5fZml0Um93cyhyLCBvLCBhLCBsKSArIDEwKSA6IChoID0gdGhpcy5tYXhIZWlnaHQsIGMgPSB0aGlzLl9maXRDb2xzKHIsIG8sIGEsIGwpICsgMTApLCB0aGlzLndpZHRoID0gTWF0aC5taW4oYywgdC5tYXhXaWR0aCB8fCB0aGlzLm1heFdpZHRoKSwgdGhpcy5oZWlnaHQgPSBNYXRoLm1pbihoLCB0Lm1heEhlaWdodCB8fCB0aGlzLm1heEhlaWdodCk7XG4gIH1cbiAgX2ZpdFJvd3ModCwgZSwgcywgbikge1xuICAgIGNvbnN0IHsgY3R4OiBvLCBtYXhXaWR0aDogciwgb3B0aW9uczogeyBsYWJlbHM6IHsgcGFkZGluZzogYSB9IH0gfSA9IHRoaXMsIGwgPSB0aGlzLmxlZ2VuZEhpdEJveGVzID0gW10sIGMgPSB0aGlzLmxpbmVXaWR0aHMgPSBbMF0sIGggPSBuICsgYTtcbiAgICBsZXQgZCA9IHQ7XG4gICAgby50ZXh0QWxpZ24gPSBcImxlZnRcIiwgby50ZXh0QmFzZWxpbmUgPSBcIm1pZGRsZVwiO1xuICAgIGxldCB1ID0gLTEsIGYgPSAtaDtcbiAgICByZXR1cm4gdGhpcy5sZWdlbmRJdGVtcy5mb3JFYWNoKChnLCBwKSA9PiB7XG4gICAgICBjb25zdCBtID0gcyArIGUgLyAyICsgby5tZWFzdXJlVGV4dChnLnRleHQpLndpZHRoO1xuICAgICAgKHAgPT09IDAgfHwgY1tjLmxlbmd0aCAtIDFdICsgbSArIDIgKiBhID4gcikgJiYgKGQgKz0gaCwgY1tjLmxlbmd0aCAtIChwID4gMCA/IDAgOiAxKV0gPSAwLCBmICs9IGgsIHUrKyksIGxbcF0gPSB7IGxlZnQ6IDAsIHRvcDogZiwgcm93OiB1LCB3aWR0aDogbSwgaGVpZ2h0OiBuIH0sIGNbYy5sZW5ndGggLSAxXSArPSBtICsgYTtcbiAgICB9KSwgZDtcbiAgfVxuICBfZml0Q29scyh0LCBlLCBzLCBuKSB7XG4gICAgY29uc3QgeyBjdHg6IG8sIG1heEhlaWdodDogciwgb3B0aW9uczogeyBsYWJlbHM6IHsgcGFkZGluZzogYSB9IH0gfSA9IHRoaXMsIGwgPSB0aGlzLmxlZ2VuZEhpdEJveGVzID0gW10sIGMgPSB0aGlzLmNvbHVtblNpemVzID0gW10sIGggPSByIC0gdDtcbiAgICBsZXQgZCA9IGEsIHUgPSAwLCBmID0gMCwgZyA9IDAsIHAgPSAwO1xuICAgIHJldHVybiB0aGlzLmxlZ2VuZEl0ZW1zLmZvckVhY2goKG0sIGIpID0+IHtcbiAgICAgIGNvbnN0IHggPSBzICsgZSAvIDIgKyBvLm1lYXN1cmVUZXh0KG0udGV4dCkud2lkdGg7XG4gICAgICBiID4gMCAmJiBmICsgbiArIDIgKiBhID4gaCAmJiAoZCArPSB1ICsgYSwgYy5wdXNoKHsgd2lkdGg6IHUsIGhlaWdodDogZiB9KSwgZyArPSB1ICsgYSwgcCsrLCB1ID0gZiA9IDApLCBsW2JdID0geyBsZWZ0OiBnLCB0b3A6IGYsIGNvbDogcCwgd2lkdGg6IHgsIGhlaWdodDogbiB9LCB1ID0gTWF0aC5tYXgodSwgeCksIGYgKz0gbiArIGE7XG4gICAgfSksIGQgKz0gdSwgYy5wdXNoKHsgd2lkdGg6IHUsIGhlaWdodDogZiB9KSwgZDtcbiAgfVxuICBhZGp1c3RIaXRCb3hlcygpIHtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5kaXNwbGF5KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHQgPSB0aGlzLl9jb21wdXRlVGl0bGVIZWlnaHQoKSwgeyBsZWdlbmRIaXRCb3hlczogZSwgb3B0aW9uczogeyBhbGlnbjogcywgbGFiZWxzOiB7IHBhZGRpbmc6IG4gfSwgcnRsOiBvIH0gfSA9IHRoaXMsIHIgPSB6dChvLCB0aGlzLmxlZnQsIHRoaXMud2lkdGgpO1xuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICBsZXQgYSA9IDAsIGwgPSBVKHMsIHRoaXMubGVmdCArIG4sIHRoaXMucmlnaHQgLSB0aGlzLmxpbmVXaWR0aHNbYV0pO1xuICAgICAgZm9yIChjb25zdCBjIG9mIGUpXG4gICAgICAgIGEgIT09IGMucm93ICYmIChhID0gYy5yb3csIGwgPSBVKHMsIHRoaXMubGVmdCArIG4sIHRoaXMucmlnaHQgLSB0aGlzLmxpbmVXaWR0aHNbYV0pKSwgYy50b3AgKz0gdGhpcy50b3AgKyB0ICsgbiwgYy5sZWZ0ID0gci5sZWZ0Rm9yTHRyKHIueChsKSwgYy53aWR0aCksIGwgKz0gYy53aWR0aCArIG47XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBhID0gMCwgbCA9IFUocywgdGhpcy50b3AgKyB0ICsgbiwgdGhpcy5ib3R0b20gLSB0aGlzLmNvbHVtblNpemVzW2FdLmhlaWdodCk7XG4gICAgICBmb3IgKGNvbnN0IGMgb2YgZSlcbiAgICAgICAgYy5jb2wgIT09IGEgJiYgKGEgPSBjLmNvbCwgbCA9IFUocywgdGhpcy50b3AgKyB0ICsgbiwgdGhpcy5ib3R0b20gLSB0aGlzLmNvbHVtblNpemVzW2FdLmhlaWdodCkpLCBjLnRvcCA9IGwsIGMubGVmdCArPSB0aGlzLmxlZnQgKyBuLCBjLmxlZnQgPSByLmxlZnRGb3JMdHIoci54KGMubGVmdCksIGMud2lkdGgpLCBsICs9IGMuaGVpZ2h0ICsgbjtcbiAgICB9XG4gIH1cbiAgaXNIb3Jpem9udGFsKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMucG9zaXRpb24gPT09IFwidG9wXCIgfHwgdGhpcy5vcHRpb25zLnBvc2l0aW9uID09PSBcImJvdHRvbVwiO1xuICB9XG4gIGRyYXcoKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5kaXNwbGF5KSB7XG4gICAgICBjb25zdCB0ID0gdGhpcy5jdHg7XG4gICAgICBYZSh0LCB0aGlzKSwgdGhpcy5fZHJhdygpLCBVZSh0KTtcbiAgICB9XG4gIH1cbiAgX2RyYXcoKSB7XG4gICAgY29uc3QgeyBvcHRpb25zOiB0LCBjb2x1bW5TaXplczogZSwgbGluZVdpZHRoczogcywgY3R4OiBuIH0gPSB0aGlzLCB7IGFsaWduOiBvLCBsYWJlbHM6IHIgfSA9IHQsIGEgPSBPLmNvbG9yLCBsID0genQodC5ydGwsIHRoaXMubGVmdCwgdGhpcy53aWR0aCksIGMgPSAkKHIuZm9udCksIHsgY29sb3I6IGgsIHBhZGRpbmc6IGQgfSA9IHIsIHUgPSBjLnNpemUsIGYgPSB1IC8gMjtcbiAgICBsZXQgZztcbiAgICB0aGlzLmRyYXdUaXRsZSgpLCBuLnRleHRBbGlnbiA9IGwudGV4dEFsaWduKFwibGVmdFwiKSwgbi50ZXh0QmFzZWxpbmUgPSBcIm1pZGRsZVwiLCBuLmxpbmVXaWR0aCA9IDAuNSwgbi5mb250ID0gYy5zdHJpbmc7XG4gICAgY29uc3QgeyBib3hXaWR0aDogcCwgYm94SGVpZ2h0OiBtLCBpdGVtSGVpZ2h0OiBiIH0gPSBYcyhyLCB1KSwgeCA9IGZ1bmN0aW9uKGssIFMsIHcpIHtcbiAgICAgIGlmIChpc05hTihwKSB8fCBwIDw9IDAgfHwgaXNOYU4obSkgfHwgbSA8IDApXG4gICAgICAgIHJldHVybjtcbiAgICAgIG4uc2F2ZSgpO1xuICAgICAgY29uc3QgTCA9IEMody5saW5lV2lkdGgsIDEpO1xuICAgICAgaWYgKG4uZmlsbFN0eWxlID0gQyh3LmZpbGxTdHlsZSwgYSksIG4ubGluZUNhcCA9IEMody5saW5lQ2FwLCBcImJ1dHRcIiksIG4ubGluZURhc2hPZmZzZXQgPSBDKHcubGluZURhc2hPZmZzZXQsIDApLCBuLmxpbmVKb2luID0gQyh3LmxpbmVKb2luLCBcIm1pdGVyXCIpLCBuLmxpbmVXaWR0aCA9IEwsIG4uc3Ryb2tlU3R5bGUgPSBDKHcuc3Ryb2tlU3R5bGUsIGEpLCBuLnNldExpbmVEYXNoKEMody5saW5lRGFzaCwgW10pKSwgci51c2VQb2ludFN0eWxlKSB7XG4gICAgICAgIGNvbnN0IFIgPSB7XG4gICAgICAgICAgcmFkaXVzOiBtICogTWF0aC5TUVJUMiAvIDIsXG4gICAgICAgICAgcG9pbnRTdHlsZTogdy5wb2ludFN0eWxlLFxuICAgICAgICAgIHJvdGF0aW9uOiB3LnJvdGF0aW9uLFxuICAgICAgICAgIGJvcmRlcldpZHRoOiBMXG4gICAgICAgIH0sIEEgPSBsLnhQbHVzKGssIHAgLyAyKSwgSCA9IFMgKyBmO1xuICAgICAgICBNbihuLCBSLCBBLCBILCByLnBvaW50U3R5bGVXaWR0aCAmJiBwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IFIgPSBTICsgTWF0aC5tYXgoKHUgLSBtKSAvIDIsIDApLCBBID0gbC5sZWZ0Rm9yTHRyKGssIHApLCBIID0gRHQody5ib3JkZXJSYWRpdXMpO1xuICAgICAgICBuLmJlZ2luUGF0aCgpLCBPYmplY3QudmFsdWVzKEgpLnNvbWUoKHEpID0+IHEgIT09IDApID8gYWUobiwge1xuICAgICAgICAgIHg6IEEsXG4gICAgICAgICAgeTogUixcbiAgICAgICAgICB3OiBwLFxuICAgICAgICAgIGg6IG0sXG4gICAgICAgICAgcmFkaXVzOiBIXG4gICAgICAgIH0pIDogbi5yZWN0KEEsIFIsIHAsIG0pLCBuLmZpbGwoKSwgTCAhPT0gMCAmJiBuLnN0cm9rZSgpO1xuICAgICAgfVxuICAgICAgbi5yZXN0b3JlKCk7XG4gICAgfSwgdiA9IGZ1bmN0aW9uKGssIFMsIHcpIHtcbiAgICAgIFR0KG4sIHcudGV4dCwgaywgUyArIGIgLyAyLCBjLCB7XG4gICAgICAgIHN0cmlrZXRocm91Z2g6IHcuaGlkZGVuLFxuICAgICAgICB0ZXh0QWxpZ246IGwudGV4dEFsaWduKHcudGV4dEFsaWduKVxuICAgICAgfSk7XG4gICAgfSwgeSA9IHRoaXMuaXNIb3Jpem9udGFsKCksIF8gPSB0aGlzLl9jb21wdXRlVGl0bGVIZWlnaHQoKTtcbiAgICB5ID8gZyA9IHtcbiAgICAgIHg6IFUobywgdGhpcy5sZWZ0ICsgZCwgdGhpcy5yaWdodCAtIHNbMF0pLFxuICAgICAgeTogdGhpcy50b3AgKyBkICsgXyxcbiAgICAgIGxpbmU6IDBcbiAgICB9IDogZyA9IHtcbiAgICAgIHg6IHRoaXMubGVmdCArIGQsXG4gICAgICB5OiBVKG8sIHRoaXMudG9wICsgXyArIGQsIHRoaXMuYm90dG9tIC0gZVswXS5oZWlnaHQpLFxuICAgICAgbGluZTogMFxuICAgIH0sIFRuKHRoaXMuY3R4LCB0LnRleHREaXJlY3Rpb24pO1xuICAgIGNvbnN0IE0gPSBiICsgZDtcbiAgICB0aGlzLmxlZ2VuZEl0ZW1zLmZvckVhY2goKGssIFMpID0+IHtcbiAgICAgIG4uc3Ryb2tlU3R5bGUgPSBrLmZvbnRDb2xvciB8fCBoLCBuLmZpbGxTdHlsZSA9IGsuZm9udENvbG9yIHx8IGg7XG4gICAgICBjb25zdCB3ID0gbi5tZWFzdXJlVGV4dChrLnRleHQpLndpZHRoLCBMID0gbC50ZXh0QWxpZ24oay50ZXh0QWxpZ24gfHwgKGsudGV4dEFsaWduID0gci50ZXh0QWxpZ24pKSwgUiA9IHAgKyBmICsgdztcbiAgICAgIGxldCBBID0gZy54LCBIID0gZy55O1xuICAgICAgbC5zZXRXaWR0aCh0aGlzLndpZHRoKSwgeSA/IFMgPiAwICYmIEEgKyBSICsgZCA+IHRoaXMucmlnaHQgJiYgKEggPSBnLnkgKz0gTSwgZy5saW5lKyssIEEgPSBnLnggPSBVKG8sIHRoaXMubGVmdCArIGQsIHRoaXMucmlnaHQgLSBzW2cubGluZV0pKSA6IFMgPiAwICYmIEggKyBNID4gdGhpcy5ib3R0b20gJiYgKEEgPSBnLnggPSBBICsgZVtnLmxpbmVdLndpZHRoICsgZCwgZy5saW5lKyssIEggPSBnLnkgPSBVKG8sIHRoaXMudG9wICsgXyArIGQsIHRoaXMuYm90dG9tIC0gZVtnLmxpbmVdLmhlaWdodCkpO1xuICAgICAgY29uc3QgcSA9IGwueChBKTtcbiAgICAgIHgocSwgSCwgayksIEEgPSBJbyhMLCBBICsgcCArIGYsIHkgPyBBICsgUiA6IHRoaXMucmlnaHQsIHQucnRsKSwgdihsLngoQSksIEgsIGspLCB5ID8gZy54ICs9IFIgKyBkIDogZy55ICs9IE07XG4gICAgfSksIExuKHRoaXMuY3R4LCB0LnRleHREaXJlY3Rpb24pO1xuICB9XG4gIGRyYXdUaXRsZSgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5vcHRpb25zLCBlID0gdC50aXRsZSwgcyA9ICQoZS5mb250KSwgbiA9IEsoZS5wYWRkaW5nKTtcbiAgICBpZiAoIWUuZGlzcGxheSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBvID0genQodC5ydGwsIHRoaXMubGVmdCwgdGhpcy53aWR0aCksIHIgPSB0aGlzLmN0eCwgYSA9IGUucG9zaXRpb24sIGwgPSBzLnNpemUgLyAyLCBjID0gbi50b3AgKyBsO1xuICAgIGxldCBoLCBkID0gdGhpcy5sZWZ0LCB1ID0gdGhpcy53aWR0aDtcbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSlcbiAgICAgIHUgPSBNYXRoLm1heCguLi50aGlzLmxpbmVXaWR0aHMpLCBoID0gdGhpcy50b3AgKyBjLCBkID0gVSh0LmFsaWduLCBkLCB0aGlzLnJpZ2h0IC0gdSk7XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCBnID0gdGhpcy5jb2x1bW5TaXplcy5yZWR1Y2UoKHAsIG0pID0+IE1hdGgubWF4KHAsIG0uaGVpZ2h0KSwgMCk7XG4gICAgICBoID0gYyArIFUodC5hbGlnbiwgdGhpcy50b3AsIHRoaXMuYm90dG9tIC0gZyAtIHQubGFiZWxzLnBhZGRpbmcgLSB0aGlzLl9jb21wdXRlVGl0bGVIZWlnaHQoKSk7XG4gICAgfVxuICAgIGNvbnN0IGYgPSBVKGEsIGQsIGQgKyB1KTtcbiAgICByLnRleHRBbGlnbiA9IG8udGV4dEFsaWduKExpKGEpKSwgci50ZXh0QmFzZWxpbmUgPSBcIm1pZGRsZVwiLCByLnN0cm9rZVN0eWxlID0gZS5jb2xvciwgci5maWxsU3R5bGUgPSBlLmNvbG9yLCByLmZvbnQgPSBzLnN0cmluZywgVHQociwgZS50ZXh0LCBmLCBoLCBzKTtcbiAgfVxuICBfY29tcHV0ZVRpdGxlSGVpZ2h0KCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLm9wdGlvbnMudGl0bGUsIGUgPSAkKHQuZm9udCksIHMgPSBLKHQucGFkZGluZyk7XG4gICAgcmV0dXJuIHQuZGlzcGxheSA/IGUubGluZUhlaWdodCArIHMuaGVpZ2h0IDogMDtcbiAgfVxuICBfZ2V0TGVnZW5kSXRlbUF0KHQsIGUpIHtcbiAgICBsZXQgcywgbiwgbztcbiAgICBpZiAodXQodCwgdGhpcy5sZWZ0LCB0aGlzLnJpZ2h0KSAmJiB1dChlLCB0aGlzLnRvcCwgdGhpcy5ib3R0b20pKSB7XG4gICAgICBmb3IgKG8gPSB0aGlzLmxlZ2VuZEhpdEJveGVzLCBzID0gMDsgcyA8IG8ubGVuZ3RoOyArK3MpXG4gICAgICAgIGlmIChuID0gb1tzXSwgdXQodCwgbi5sZWZ0LCBuLmxlZnQgKyBuLndpZHRoKSAmJiB1dChlLCBuLnRvcCwgbi50b3AgKyBuLmhlaWdodCkpXG4gICAgICAgICAgcmV0dXJuIHRoaXMubGVnZW5kSXRlbXNbc107XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGhhbmRsZUV2ZW50KHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5vcHRpb25zO1xuICAgIGlmICghbWModC50eXBlLCBlKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBzID0gdGhpcy5fZ2V0TGVnZW5kSXRlbUF0KHQueCwgdC55KTtcbiAgICBpZiAodC50eXBlID09PSBcIm1vdXNlbW92ZVwiIHx8IHQudHlwZSA9PT0gXCJtb3VzZW91dFwiKSB7XG4gICAgICBjb25zdCBuID0gdGhpcy5faG92ZXJlZEl0ZW0sIG8gPSBwYyhuLCBzKTtcbiAgICAgIG4gJiYgIW8gJiYgSShlLm9uTGVhdmUsIFt0LCBuLCB0aGlzXSwgdGhpcyksIHRoaXMuX2hvdmVyZWRJdGVtID0gcywgcyAmJiAhbyAmJiBJKGUub25Ib3ZlciwgW3QsIHMsIHRoaXNdLCB0aGlzKTtcbiAgICB9IGVsc2VcbiAgICAgIHMgJiYgSShlLm9uQ2xpY2ssIFt0LCBzLCB0aGlzXSwgdGhpcyk7XG4gIH1cbn1cbmZ1bmN0aW9uIG1jKGksIHQpIHtcbiAgcmV0dXJuICEhKChpID09PSBcIm1vdXNlbW92ZVwiIHx8IGkgPT09IFwibW91c2VvdXRcIikgJiYgKHQub25Ib3ZlciB8fCB0Lm9uTGVhdmUpIHx8IHQub25DbGljayAmJiAoaSA9PT0gXCJjbGlja1wiIHx8IGkgPT09IFwibW91c2V1cFwiKSk7XG59XG52YXIgdW8gPSB7XG4gIGlkOiBcImxlZ2VuZFwiLFxuICBfZWxlbWVudDogVXMsXG4gIHN0YXJ0KGksIHQsIGUpIHtcbiAgICBjb25zdCBzID0gaS5sZWdlbmQgPSBuZXcgVXMoeyBjdHg6IGkuY3R4LCBvcHRpb25zOiBlLCBjaGFydDogaSB9KTtcbiAgICBYLmNvbmZpZ3VyZShpLCBzLCBlKSwgWC5hZGRCb3goaSwgcyk7XG4gIH0sXG4gIHN0b3AoaSkge1xuICAgIFgucmVtb3ZlQm94KGksIGkubGVnZW5kKSwgZGVsZXRlIGkubGVnZW5kO1xuICB9LFxuICBiZWZvcmVVcGRhdGUoaSwgdCwgZSkge1xuICAgIGNvbnN0IHMgPSBpLmxlZ2VuZDtcbiAgICBYLmNvbmZpZ3VyZShpLCBzLCBlKSwgcy5vcHRpb25zID0gZTtcbiAgfSxcbiAgYWZ0ZXJVcGRhdGUoaSkge1xuICAgIGNvbnN0IHQgPSBpLmxlZ2VuZDtcbiAgICB0LmJ1aWxkTGFiZWxzKCksIHQuYWRqdXN0SGl0Qm94ZXMoKTtcbiAgfSxcbiAgYWZ0ZXJFdmVudChpLCB0KSB7XG4gICAgdC5yZXBsYXkgfHwgaS5sZWdlbmQuaGFuZGxlRXZlbnQodC5ldmVudCk7XG4gIH0sXG4gIGRlZmF1bHRzOiB7XG4gICAgZGlzcGxheTogITAsXG4gICAgcG9zaXRpb246IFwidG9wXCIsXG4gICAgYWxpZ246IFwiY2VudGVyXCIsXG4gICAgZnVsbFNpemU6ICEwLFxuICAgIHJldmVyc2U6ICExLFxuICAgIHdlaWdodDogMWUzLFxuICAgIG9uQ2xpY2soaSwgdCwgZSkge1xuICAgICAgY29uc3QgcyA9IHQuZGF0YXNldEluZGV4LCBuID0gZS5jaGFydDtcbiAgICAgIG4uaXNEYXRhc2V0VmlzaWJsZShzKSA/IChuLmhpZGUocyksIHQuaGlkZGVuID0gITApIDogKG4uc2hvdyhzKSwgdC5oaWRkZW4gPSAhMSk7XG4gICAgfSxcbiAgICBvbkhvdmVyOiBudWxsLFxuICAgIG9uTGVhdmU6IG51bGwsXG4gICAgbGFiZWxzOiB7XG4gICAgICBjb2xvcjogKGkpID0+IGkuY2hhcnQub3B0aW9ucy5jb2xvcixcbiAgICAgIGJveFdpZHRoOiA0MCxcbiAgICAgIHBhZGRpbmc6IDEwLFxuICAgICAgZ2VuZXJhdGVMYWJlbHMoaSkge1xuICAgICAgICBjb25zdCB0ID0gaS5kYXRhLmRhdGFzZXRzLCB7IGxhYmVsczogeyB1c2VQb2ludFN0eWxlOiBlLCBwb2ludFN0eWxlOiBzLCB0ZXh0QWxpZ246IG4sIGNvbG9yOiBvIH0gfSA9IGkubGVnZW5kLm9wdGlvbnM7XG4gICAgICAgIHJldHVybiBpLl9nZXRTb3J0ZWREYXRhc2V0TWV0YXMoKS5tYXAoKHIpID0+IHtcbiAgICAgICAgICBjb25zdCBhID0gci5jb250cm9sbGVyLmdldFN0eWxlKGUgPyAwIDogdm9pZCAwKSwgbCA9IEsoYS5ib3JkZXJXaWR0aCk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRleHQ6IHRbci5pbmRleF0ubGFiZWwsXG4gICAgICAgICAgICBmaWxsU3R5bGU6IGEuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgZm9udENvbG9yOiBvLFxuICAgICAgICAgICAgaGlkZGVuOiAhci52aXNpYmxlLFxuICAgICAgICAgICAgbGluZUNhcDogYS5ib3JkZXJDYXBTdHlsZSxcbiAgICAgICAgICAgIGxpbmVEYXNoOiBhLmJvcmRlckRhc2gsXG4gICAgICAgICAgICBsaW5lRGFzaE9mZnNldDogYS5ib3JkZXJEYXNoT2Zmc2V0LFxuICAgICAgICAgICAgbGluZUpvaW46IGEuYm9yZGVySm9pblN0eWxlLFxuICAgICAgICAgICAgbGluZVdpZHRoOiAobC53aWR0aCArIGwuaGVpZ2h0KSAvIDQsXG4gICAgICAgICAgICBzdHJva2VTdHlsZTogYS5ib3JkZXJDb2xvcixcbiAgICAgICAgICAgIHBvaW50U3R5bGU6IHMgfHwgYS5wb2ludFN0eWxlLFxuICAgICAgICAgICAgcm90YXRpb246IGEucm90YXRpb24sXG4gICAgICAgICAgICB0ZXh0QWxpZ246IG4gfHwgYS50ZXh0QWxpZ24sXG4gICAgICAgICAgICBib3JkZXJSYWRpdXM6IDAsXG4gICAgICAgICAgICBkYXRhc2V0SW5kZXg6IHIuaW5kZXhcbiAgICAgICAgICB9O1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHRpdGxlOiB7XG4gICAgICBjb2xvcjogKGkpID0+IGkuY2hhcnQub3B0aW9ucy5jb2xvcixcbiAgICAgIGRpc3BsYXk6ICExLFxuICAgICAgcG9zaXRpb246IFwiY2VudGVyXCIsXG4gICAgICB0ZXh0OiBcIlwiXG4gICAgfVxuICB9LFxuICBkZXNjcmlwdG9yczoge1xuICAgIF9zY3JpcHRhYmxlOiAoaSkgPT4gIWkuc3RhcnRzV2l0aChcIm9uXCIpLFxuICAgIGxhYmVsczoge1xuICAgICAgX3NjcmlwdGFibGU6IChpKSA9PiAhW1wiZ2VuZXJhdGVMYWJlbHNcIiwgXCJmaWx0ZXJcIiwgXCJzb3J0XCJdLmluY2x1ZGVzKGkpXG4gICAgfVxuICB9XG59O1xuY2xhc3MgWWkgZXh0ZW5kcyBzdCB7XG4gIGNvbnN0cnVjdG9yKHQpIHtcbiAgICBzdXBlcigpLCB0aGlzLmNoYXJ0ID0gdC5jaGFydCwgdGhpcy5vcHRpb25zID0gdC5vcHRpb25zLCB0aGlzLmN0eCA9IHQuY3R4LCB0aGlzLl9wYWRkaW5nID0gdm9pZCAwLCB0aGlzLnRvcCA9IHZvaWQgMCwgdGhpcy5ib3R0b20gPSB2b2lkIDAsIHRoaXMubGVmdCA9IHZvaWQgMCwgdGhpcy5yaWdodCA9IHZvaWQgMCwgdGhpcy53aWR0aCA9IHZvaWQgMCwgdGhpcy5oZWlnaHQgPSB2b2lkIDAsIHRoaXMucG9zaXRpb24gPSB2b2lkIDAsIHRoaXMud2VpZ2h0ID0gdm9pZCAwLCB0aGlzLmZ1bGxTaXplID0gdm9pZCAwO1xuICB9XG4gIHVwZGF0ZSh0LCBlKSB7XG4gICAgY29uc3QgcyA9IHRoaXMub3B0aW9ucztcbiAgICBpZiAodGhpcy5sZWZ0ID0gMCwgdGhpcy50b3AgPSAwLCAhcy5kaXNwbGF5KSB7XG4gICAgICB0aGlzLndpZHRoID0gdGhpcy5oZWlnaHQgPSB0aGlzLnJpZ2h0ID0gdGhpcy5ib3R0b20gPSAwO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLndpZHRoID0gdGhpcy5yaWdodCA9IHQsIHRoaXMuaGVpZ2h0ID0gdGhpcy5ib3R0b20gPSBlO1xuICAgIGNvbnN0IG4gPSB6KHMudGV4dCkgPyBzLnRleHQubGVuZ3RoIDogMTtcbiAgICB0aGlzLl9wYWRkaW5nID0gSyhzLnBhZGRpbmcpO1xuICAgIGNvbnN0IG8gPSBuICogJChzLmZvbnQpLmxpbmVIZWlnaHQgKyB0aGlzLl9wYWRkaW5nLmhlaWdodDtcbiAgICB0aGlzLmlzSG9yaXpvbnRhbCgpID8gdGhpcy5oZWlnaHQgPSBvIDogdGhpcy53aWR0aCA9IG87XG4gIH1cbiAgaXNIb3Jpem9udGFsKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLm9wdGlvbnMucG9zaXRpb247XG4gICAgcmV0dXJuIHQgPT09IFwidG9wXCIgfHwgdCA9PT0gXCJib3R0b21cIjtcbiAgfVxuICBfZHJhd0FyZ3ModCkge1xuICAgIGNvbnN0IHsgdG9wOiBlLCBsZWZ0OiBzLCBib3R0b206IG4sIHJpZ2h0OiBvLCBvcHRpb25zOiByIH0gPSB0aGlzLCBhID0gci5hbGlnbjtcbiAgICBsZXQgbCA9IDAsIGMsIGgsIGQ7XG4gICAgcmV0dXJuIHRoaXMuaXNIb3Jpem9udGFsKCkgPyAoaCA9IFUoYSwgcywgbyksIGQgPSBlICsgdCwgYyA9IG8gLSBzKSA6IChyLnBvc2l0aW9uID09PSBcImxlZnRcIiA/IChoID0gcyArIHQsIGQgPSBVKGEsIG4sIGUpLCBsID0gQiAqIC0wLjUpIDogKGggPSBvIC0gdCwgZCA9IFUoYSwgZSwgbiksIGwgPSBCICogMC41KSwgYyA9IG4gLSBlKSwgeyB0aXRsZVg6IGgsIHRpdGxlWTogZCwgbWF4V2lkdGg6IGMsIHJvdGF0aW9uOiBsIH07XG4gIH1cbiAgZHJhdygpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5jdHgsIGUgPSB0aGlzLm9wdGlvbnM7XG4gICAgaWYgKCFlLmRpc3BsYXkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgcyA9ICQoZS5mb250KSwgbyA9IHMubGluZUhlaWdodCAvIDIgKyB0aGlzLl9wYWRkaW5nLnRvcCwgeyB0aXRsZVg6IHIsIHRpdGxlWTogYSwgbWF4V2lkdGg6IGwsIHJvdGF0aW9uOiBjIH0gPSB0aGlzLl9kcmF3QXJncyhvKTtcbiAgICBUdCh0LCBlLnRleHQsIDAsIDAsIHMsIHtcbiAgICAgIGNvbG9yOiBlLmNvbG9yLFxuICAgICAgbWF4V2lkdGg6IGwsXG4gICAgICByb3RhdGlvbjogYyxcbiAgICAgIHRleHRBbGlnbjogTGkoZS5hbGlnbiksXG4gICAgICB0ZXh0QmFzZWxpbmU6IFwibWlkZGxlXCIsXG4gICAgICB0cmFuc2xhdGlvbjogW3IsIGFdXG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGJjKGksIHQpIHtcbiAgY29uc3QgZSA9IG5ldyBZaSh7XG4gICAgY3R4OiBpLmN0eCxcbiAgICBvcHRpb25zOiB0LFxuICAgIGNoYXJ0OiBpXG4gIH0pO1xuICBYLmNvbmZpZ3VyZShpLCBlLCB0KSwgWC5hZGRCb3goaSwgZSksIGkudGl0bGVCbG9jayA9IGU7XG59XG52YXIgZm8gPSB7XG4gIGlkOiBcInRpdGxlXCIsXG4gIF9lbGVtZW50OiBZaSxcbiAgc3RhcnQoaSwgdCwgZSkge1xuICAgIGJjKGksIGUpO1xuICB9LFxuICBzdG9wKGkpIHtcbiAgICBjb25zdCB0ID0gaS50aXRsZUJsb2NrO1xuICAgIFgucmVtb3ZlQm94KGksIHQpLCBkZWxldGUgaS50aXRsZUJsb2NrO1xuICB9LFxuICBiZWZvcmVVcGRhdGUoaSwgdCwgZSkge1xuICAgIGNvbnN0IHMgPSBpLnRpdGxlQmxvY2s7XG4gICAgWC5jb25maWd1cmUoaSwgcywgZSksIHMub3B0aW9ucyA9IGU7XG4gIH0sXG4gIGRlZmF1bHRzOiB7XG4gICAgYWxpZ246IFwiY2VudGVyXCIsXG4gICAgZGlzcGxheTogITEsXG4gICAgZm9udDoge1xuICAgICAgd2VpZ2h0OiBcImJvbGRcIlxuICAgIH0sXG4gICAgZnVsbFNpemU6ICEwLFxuICAgIHBhZGRpbmc6IDEwLFxuICAgIHBvc2l0aW9uOiBcInRvcFwiLFxuICAgIHRleHQ6IFwiXCIsXG4gICAgd2VpZ2h0OiAyZTNcbiAgfSxcbiAgZGVmYXVsdFJvdXRlczoge1xuICAgIGNvbG9yOiBcImNvbG9yXCJcbiAgfSxcbiAgZGVzY3JpcHRvcnM6IHtcbiAgICBfc2NyaXB0YWJsZTogITAsXG4gICAgX2luZGV4YWJsZTogITFcbiAgfVxufTtcbmNvbnN0IFJlID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG52YXIgZ28gPSB7XG4gIGlkOiBcInN1YnRpdGxlXCIsXG4gIHN0YXJ0KGksIHQsIGUpIHtcbiAgICBjb25zdCBzID0gbmV3IFlpKHtcbiAgICAgIGN0eDogaS5jdHgsXG4gICAgICBvcHRpb25zOiBlLFxuICAgICAgY2hhcnQ6IGlcbiAgICB9KTtcbiAgICBYLmNvbmZpZ3VyZShpLCBzLCBlKSwgWC5hZGRCb3goaSwgcyksIFJlLnNldChpLCBzKTtcbiAgfSxcbiAgc3RvcChpKSB7XG4gICAgWC5yZW1vdmVCb3goaSwgUmUuZ2V0KGkpKSwgUmUuZGVsZXRlKGkpO1xuICB9LFxuICBiZWZvcmVVcGRhdGUoaSwgdCwgZSkge1xuICAgIGNvbnN0IHMgPSBSZS5nZXQoaSk7XG4gICAgWC5jb25maWd1cmUoaSwgcywgZSksIHMub3B0aW9ucyA9IGU7XG4gIH0sXG4gIGRlZmF1bHRzOiB7XG4gICAgYWxpZ246IFwiY2VudGVyXCIsXG4gICAgZGlzcGxheTogITEsXG4gICAgZm9udDoge1xuICAgICAgd2VpZ2h0OiBcIm5vcm1hbFwiXG4gICAgfSxcbiAgICBmdWxsU2l6ZTogITAsXG4gICAgcGFkZGluZzogMCxcbiAgICBwb3NpdGlvbjogXCJ0b3BcIixcbiAgICB0ZXh0OiBcIlwiLFxuICAgIHdlaWdodDogMTUwMFxuICB9LFxuICBkZWZhdWx0Um91dGVzOiB7XG4gICAgY29sb3I6IFwiY29sb3JcIlxuICB9LFxuICBkZXNjcmlwdG9yczoge1xuICAgIF9zY3JpcHRhYmxlOiAhMCxcbiAgICBfaW5kZXhhYmxlOiAhMVxuICB9XG59O1xuY29uc3Qgc2UgPSB7XG4gIGF2ZXJhZ2UoaSkge1xuICAgIGlmICghaS5sZW5ndGgpXG4gICAgICByZXR1cm4gITE7XG4gICAgbGV0IHQsIGUsIHMgPSAwLCBuID0gMCwgbyA9IDA7XG4gICAgZm9yICh0ID0gMCwgZSA9IGkubGVuZ3RoOyB0IDwgZTsgKyt0KSB7XG4gICAgICBjb25zdCByID0gaVt0XS5lbGVtZW50O1xuICAgICAgaWYgKHIgJiYgci5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIGNvbnN0IGEgPSByLnRvb2x0aXBQb3NpdGlvbigpO1xuICAgICAgICBzICs9IGEueCwgbiArPSBhLnksICsrbztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHMgLyBvLFxuICAgICAgeTogbiAvIG9cbiAgICB9O1xuICB9LFxuICBuZWFyZXN0KGksIHQpIHtcbiAgICBpZiAoIWkubGVuZ3RoKVxuICAgICAgcmV0dXJuICExO1xuICAgIGxldCBlID0gdC54LCBzID0gdC55LCBuID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCBvLCByLCBhO1xuICAgIGZvciAobyA9IDAsIHIgPSBpLmxlbmd0aDsgbyA8IHI7ICsrbykge1xuICAgICAgY29uc3QgbCA9IGlbb10uZWxlbWVudDtcbiAgICAgIGlmIChsICYmIGwuaGFzVmFsdWUoKSkge1xuICAgICAgICBjb25zdCBjID0gbC5nZXRDZW50ZXJQb2ludCgpLCBoID0gYmkodCwgYyk7XG4gICAgICAgIGggPCBuICYmIChuID0gaCwgYSA9IGwpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYSkge1xuICAgICAgY29uc3QgbCA9IGEudG9vbHRpcFBvc2l0aW9uKCk7XG4gICAgICBlID0gbC54LCBzID0gbC55O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgeDogZSxcbiAgICAgIHk6IHNcbiAgICB9O1xuICB9XG59O1xuZnVuY3Rpb24gcnQoaSwgdCkge1xuICByZXR1cm4gdCAmJiAoeih0KSA/IEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGksIHQpIDogaS5wdXNoKHQpKSwgaTtcbn1cbmZ1bmN0aW9uIGh0KGkpIHtcbiAgcmV0dXJuICh0eXBlb2YgaSA9PSBcInN0cmluZ1wiIHx8IGkgaW5zdGFuY2VvZiBTdHJpbmcpICYmIGkuaW5kZXhPZihgXG5gKSA+IC0xID8gaS5zcGxpdChgXG5gKSA6IGk7XG59XG5mdW5jdGlvbiB4YyhpLCB0KSB7XG4gIGNvbnN0IHsgZWxlbWVudDogZSwgZGF0YXNldEluZGV4OiBzLCBpbmRleDogbiB9ID0gdCwgbyA9IGkuZ2V0RGF0YXNldE1ldGEocykuY29udHJvbGxlciwgeyBsYWJlbDogciwgdmFsdWU6IGEgfSA9IG8uZ2V0TGFiZWxBbmRWYWx1ZShuKTtcbiAgcmV0dXJuIHtcbiAgICBjaGFydDogaSxcbiAgICBsYWJlbDogcixcbiAgICBwYXJzZWQ6IG8uZ2V0UGFyc2VkKG4pLFxuICAgIHJhdzogaS5kYXRhLmRhdGFzZXRzW3NdLmRhdGFbbl0sXG4gICAgZm9ybWF0dGVkVmFsdWU6IGEsXG4gICAgZGF0YXNldDogby5nZXREYXRhc2V0KCksXG4gICAgZGF0YUluZGV4OiBuLFxuICAgIGRhdGFzZXRJbmRleDogcyxcbiAgICBlbGVtZW50OiBlXG4gIH07XG59XG5mdW5jdGlvbiBLcyhpLCB0KSB7XG4gIGNvbnN0IGUgPSBpLmNoYXJ0LmN0eCwgeyBib2R5OiBzLCBmb290ZXI6IG4sIHRpdGxlOiBvIH0gPSBpLCB7IGJveFdpZHRoOiByLCBib3hIZWlnaHQ6IGEgfSA9IHQsIGwgPSAkKHQuYm9keUZvbnQpLCBjID0gJCh0LnRpdGxlRm9udCksIGggPSAkKHQuZm9vdGVyRm9udCksIGQgPSBvLmxlbmd0aCwgdSA9IG4ubGVuZ3RoLCBmID0gcy5sZW5ndGgsIGcgPSBLKHQucGFkZGluZyk7XG4gIGxldCBwID0gZy5oZWlnaHQsIG0gPSAwLCBiID0gcy5yZWR1Y2UoKHksIF8pID0+IHkgKyBfLmJlZm9yZS5sZW5ndGggKyBfLmxpbmVzLmxlbmd0aCArIF8uYWZ0ZXIubGVuZ3RoLCAwKTtcbiAgaWYgKGIgKz0gaS5iZWZvcmVCb2R5Lmxlbmd0aCArIGkuYWZ0ZXJCb2R5Lmxlbmd0aCwgZCAmJiAocCArPSBkICogYy5saW5lSGVpZ2h0ICsgKGQgLSAxKSAqIHQudGl0bGVTcGFjaW5nICsgdC50aXRsZU1hcmdpbkJvdHRvbSksIGIpIHtcbiAgICBjb25zdCB5ID0gdC5kaXNwbGF5Q29sb3JzID8gTWF0aC5tYXgoYSwgbC5saW5lSGVpZ2h0KSA6IGwubGluZUhlaWdodDtcbiAgICBwICs9IGYgKiB5ICsgKGIgLSBmKSAqIGwubGluZUhlaWdodCArIChiIC0gMSkgKiB0LmJvZHlTcGFjaW5nO1xuICB9XG4gIHUgJiYgKHAgKz0gdC5mb290ZXJNYXJnaW5Ub3AgKyB1ICogaC5saW5lSGVpZ2h0ICsgKHUgLSAxKSAqIHQuZm9vdGVyU3BhY2luZyk7XG4gIGxldCB4ID0gMDtcbiAgY29uc3QgdiA9IGZ1bmN0aW9uKHkpIHtcbiAgICBtID0gTWF0aC5tYXgobSwgZS5tZWFzdXJlVGV4dCh5KS53aWR0aCArIHgpO1xuICB9O1xuICByZXR1cm4gZS5zYXZlKCksIGUuZm9udCA9IGMuc3RyaW5nLCBFKGkudGl0bGUsIHYpLCBlLmZvbnQgPSBsLnN0cmluZywgRShpLmJlZm9yZUJvZHkuY29uY2F0KGkuYWZ0ZXJCb2R5KSwgdiksIHggPSB0LmRpc3BsYXlDb2xvcnMgPyByICsgMiArIHQuYm94UGFkZGluZyA6IDAsIEUocywgKHkpID0+IHtcbiAgICBFKHkuYmVmb3JlLCB2KSwgRSh5LmxpbmVzLCB2KSwgRSh5LmFmdGVyLCB2KTtcbiAgfSksIHggPSAwLCBlLmZvbnQgPSBoLnN0cmluZywgRShpLmZvb3RlciwgdiksIGUucmVzdG9yZSgpLCBtICs9IGcud2lkdGgsIHsgd2lkdGg6IG0sIGhlaWdodDogcCB9O1xufVxuZnVuY3Rpb24gX2MoaSwgdCkge1xuICBjb25zdCB7IHk6IGUsIGhlaWdodDogcyB9ID0gdDtcbiAgcmV0dXJuIGUgPCBzIC8gMiA/IFwidG9wXCIgOiBlID4gaS5oZWlnaHQgLSBzIC8gMiA/IFwiYm90dG9tXCIgOiBcImNlbnRlclwiO1xufVxuZnVuY3Rpb24geWMoaSwgdCwgZSwgcykge1xuICBjb25zdCB7IHg6IG4sIHdpZHRoOiBvIH0gPSBzLCByID0gZS5jYXJldFNpemUgKyBlLmNhcmV0UGFkZGluZztcbiAgaWYgKGkgPT09IFwibGVmdFwiICYmIG4gKyBvICsgciA+IHQud2lkdGggfHwgaSA9PT0gXCJyaWdodFwiICYmIG4gLSBvIC0gciA8IDApXG4gICAgcmV0dXJuICEwO1xufVxuZnVuY3Rpb24gdmMoaSwgdCwgZSwgcykge1xuICBjb25zdCB7IHg6IG4sIHdpZHRoOiBvIH0gPSBlLCB7IHdpZHRoOiByLCBjaGFydEFyZWE6IHsgbGVmdDogYSwgcmlnaHQ6IGwgfSB9ID0gaTtcbiAgbGV0IGMgPSBcImNlbnRlclwiO1xuICByZXR1cm4gcyA9PT0gXCJjZW50ZXJcIiA/IGMgPSBuIDw9IChhICsgbCkgLyAyID8gXCJsZWZ0XCIgOiBcInJpZ2h0XCIgOiBuIDw9IG8gLyAyID8gYyA9IFwibGVmdFwiIDogbiA+PSByIC0gbyAvIDIgJiYgKGMgPSBcInJpZ2h0XCIpLCB5YyhjLCBpLCB0LCBlKSAmJiAoYyA9IFwiY2VudGVyXCIpLCBjO1xufVxuZnVuY3Rpb24gcXMoaSwgdCwgZSkge1xuICBjb25zdCBzID0gZS55QWxpZ24gfHwgdC55QWxpZ24gfHwgX2MoaSwgZSk7XG4gIHJldHVybiB7XG4gICAgeEFsaWduOiBlLnhBbGlnbiB8fCB0LnhBbGlnbiB8fCB2YyhpLCB0LCBlLCBzKSxcbiAgICB5QWxpZ246IHNcbiAgfTtcbn1cbmZ1bmN0aW9uIE1jKGksIHQpIHtcbiAgbGV0IHsgeDogZSwgd2lkdGg6IHMgfSA9IGk7XG4gIHJldHVybiB0ID09PSBcInJpZ2h0XCIgPyBlIC09IHMgOiB0ID09PSBcImNlbnRlclwiICYmIChlIC09IHMgLyAyKSwgZTtcbn1cbmZ1bmN0aW9uIGtjKGksIHQsIGUpIHtcbiAgbGV0IHsgeTogcywgaGVpZ2h0OiBuIH0gPSBpO1xuICByZXR1cm4gdCA9PT0gXCJ0b3BcIiA/IHMgKz0gZSA6IHQgPT09IFwiYm90dG9tXCIgPyBzIC09IG4gKyBlIDogcyAtPSBuIC8gMiwgcztcbn1cbmZ1bmN0aW9uIEdzKGksIHQsIGUsIHMpIHtcbiAgY29uc3QgeyBjYXJldFNpemU6IG4sIGNhcmV0UGFkZGluZzogbywgY29ybmVyUmFkaXVzOiByIH0gPSBpLCB7IHhBbGlnbjogYSwgeUFsaWduOiBsIH0gPSBlLCBjID0gbiArIG8sIHsgdG9wTGVmdDogaCwgdG9wUmlnaHQ6IGQsIGJvdHRvbUxlZnQ6IHUsIGJvdHRvbVJpZ2h0OiBmIH0gPSBEdChyKTtcbiAgbGV0IGcgPSBNYyh0LCBhKTtcbiAgY29uc3QgcCA9IGtjKHQsIGwsIGMpO1xuICByZXR1cm4gbCA9PT0gXCJjZW50ZXJcIiA/IGEgPT09IFwibGVmdFwiID8gZyArPSBjIDogYSA9PT0gXCJyaWdodFwiICYmIChnIC09IGMpIDogYSA9PT0gXCJsZWZ0XCIgPyBnIC09IE1hdGgubWF4KGgsIHUpICsgbiA6IGEgPT09IFwicmlnaHRcIiAmJiAoZyArPSBNYXRoLm1heChkLCBmKSArIG4pLCB7XG4gICAgeDogWShnLCAwLCBzLndpZHRoIC0gdC53aWR0aCksXG4gICAgeTogWShwLCAwLCBzLmhlaWdodCAtIHQuaGVpZ2h0KVxuICB9O1xufVxuZnVuY3Rpb24gRWUoaSwgdCwgZSkge1xuICBjb25zdCBzID0gSyhlLnBhZGRpbmcpO1xuICByZXR1cm4gdCA9PT0gXCJjZW50ZXJcIiA/IGkueCArIGkud2lkdGggLyAyIDogdCA9PT0gXCJyaWdodFwiID8gaS54ICsgaS53aWR0aCAtIHMucmlnaHQgOiBpLnggKyBzLmxlZnQ7XG59XG5mdW5jdGlvbiBacyhpKSB7XG4gIHJldHVybiBydChbXSwgaHQoaSkpO1xufVxuZnVuY3Rpb24gd2MoaSwgdCwgZSkge1xuICByZXR1cm4gdnQoaSwge1xuICAgIHRvb2x0aXA6IHQsXG4gICAgdG9vbHRpcEl0ZW1zOiBlLFxuICAgIHR5cGU6IFwidG9vbHRpcFwiXG4gIH0pO1xufVxuZnVuY3Rpb24gSnMoaSwgdCkge1xuICBjb25zdCBlID0gdCAmJiB0LmRhdGFzZXQgJiYgdC5kYXRhc2V0LnRvb2x0aXAgJiYgdC5kYXRhc2V0LnRvb2x0aXAuY2FsbGJhY2tzO1xuICByZXR1cm4gZSA/IGkub3ZlcnJpZGUoZSkgOiBpO1xufVxuY2xhc3MgQ2kgZXh0ZW5kcyBzdCB7XG4gIGNvbnN0cnVjdG9yKHQpIHtcbiAgICBzdXBlcigpLCB0aGlzLm9wYWNpdHkgPSAwLCB0aGlzLl9hY3RpdmUgPSBbXSwgdGhpcy5fZXZlbnRQb3NpdGlvbiA9IHZvaWQgMCwgdGhpcy5fc2l6ZSA9IHZvaWQgMCwgdGhpcy5fY2FjaGVkQW5pbWF0aW9ucyA9IHZvaWQgMCwgdGhpcy5fdG9vbHRpcEl0ZW1zID0gW10sIHRoaXMuJGFuaW1hdGlvbnMgPSB2b2lkIDAsIHRoaXMuJGNvbnRleHQgPSB2b2lkIDAsIHRoaXMuY2hhcnQgPSB0LmNoYXJ0IHx8IHQuX2NoYXJ0LCB0aGlzLl9jaGFydCA9IHRoaXMuY2hhcnQsIHRoaXMub3B0aW9ucyA9IHQub3B0aW9ucywgdGhpcy5kYXRhUG9pbnRzID0gdm9pZCAwLCB0aGlzLnRpdGxlID0gdm9pZCAwLCB0aGlzLmJlZm9yZUJvZHkgPSB2b2lkIDAsIHRoaXMuYm9keSA9IHZvaWQgMCwgdGhpcy5hZnRlckJvZHkgPSB2b2lkIDAsIHRoaXMuZm9vdGVyID0gdm9pZCAwLCB0aGlzLnhBbGlnbiA9IHZvaWQgMCwgdGhpcy55QWxpZ24gPSB2b2lkIDAsIHRoaXMueCA9IHZvaWQgMCwgdGhpcy55ID0gdm9pZCAwLCB0aGlzLmhlaWdodCA9IHZvaWQgMCwgdGhpcy53aWR0aCA9IHZvaWQgMCwgdGhpcy5jYXJldFggPSB2b2lkIDAsIHRoaXMuY2FyZXRZID0gdm9pZCAwLCB0aGlzLmxhYmVsQ29sb3JzID0gdm9pZCAwLCB0aGlzLmxhYmVsUG9pbnRTdHlsZXMgPSB2b2lkIDAsIHRoaXMubGFiZWxUZXh0Q29sb3JzID0gdm9pZCAwO1xuICB9XG4gIGluaXRpYWxpemUodCkge1xuICAgIHRoaXMub3B0aW9ucyA9IHQsIHRoaXMuX2NhY2hlZEFuaW1hdGlvbnMgPSB2b2lkIDAsIHRoaXMuJGNvbnRleHQgPSB2b2lkIDA7XG4gIH1cbiAgX3Jlc29sdmVBbmltYXRpb25zKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9jYWNoZWRBbmltYXRpb25zO1xuICAgIGlmICh0KVxuICAgICAgcmV0dXJuIHQ7XG4gICAgY29uc3QgZSA9IHRoaXMuY2hhcnQsIHMgPSB0aGlzLm9wdGlvbnMuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoKSksIG4gPSBzLmVuYWJsZWQgJiYgZS5vcHRpb25zLmFuaW1hdGlvbiAmJiBzLmFuaW1hdGlvbnMsIG8gPSBuZXcgTmkodGhpcy5jaGFydCwgbik7XG4gICAgcmV0dXJuIG4uX2NhY2hlYWJsZSAmJiAodGhpcy5fY2FjaGVkQW5pbWF0aW9ucyA9IE9iamVjdC5mcmVlemUobykpLCBvO1xuICB9XG4gIGdldENvbnRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuJGNvbnRleHQgfHwgKHRoaXMuJGNvbnRleHQgPSB3Yyh0aGlzLmNoYXJ0LmdldENvbnRleHQoKSwgdGhpcywgdGhpcy5fdG9vbHRpcEl0ZW1zKSk7XG4gIH1cbiAgZ2V0VGl0bGUodCwgZSkge1xuICAgIGNvbnN0IHsgY2FsbGJhY2tzOiBzIH0gPSBlLCBuID0gcy5iZWZvcmVUaXRsZS5hcHBseSh0aGlzLCBbdF0pLCBvID0gcy50aXRsZS5hcHBseSh0aGlzLCBbdF0pLCByID0gcy5hZnRlclRpdGxlLmFwcGx5KHRoaXMsIFt0XSk7XG4gICAgbGV0IGEgPSBbXTtcbiAgICByZXR1cm4gYSA9IHJ0KGEsIGh0KG4pKSwgYSA9IHJ0KGEsIGh0KG8pKSwgYSA9IHJ0KGEsIGh0KHIpKSwgYTtcbiAgfVxuICBnZXRCZWZvcmVCb2R5KHQsIGUpIHtcbiAgICByZXR1cm4gWnMoZS5jYWxsYmFja3MuYmVmb3JlQm9keS5hcHBseSh0aGlzLCBbdF0pKTtcbiAgfVxuICBnZXRCb2R5KHQsIGUpIHtcbiAgICBjb25zdCB7IGNhbGxiYWNrczogcyB9ID0gZSwgbiA9IFtdO1xuICAgIHJldHVybiBFKHQsIChvKSA9PiB7XG4gICAgICBjb25zdCByID0ge1xuICAgICAgICBiZWZvcmU6IFtdLFxuICAgICAgICBsaW5lczogW10sXG4gICAgICAgIGFmdGVyOiBbXVxuICAgICAgfSwgYSA9IEpzKHMsIG8pO1xuICAgICAgcnQoci5iZWZvcmUsIGh0KGEuYmVmb3JlTGFiZWwuY2FsbCh0aGlzLCBvKSkpLCBydChyLmxpbmVzLCBhLmxhYmVsLmNhbGwodGhpcywgbykpLCBydChyLmFmdGVyLCBodChhLmFmdGVyTGFiZWwuY2FsbCh0aGlzLCBvKSkpLCBuLnB1c2gocik7XG4gICAgfSksIG47XG4gIH1cbiAgZ2V0QWZ0ZXJCb2R5KHQsIGUpIHtcbiAgICByZXR1cm4gWnMoZS5jYWxsYmFja3MuYWZ0ZXJCb2R5LmFwcGx5KHRoaXMsIFt0XSkpO1xuICB9XG4gIGdldEZvb3Rlcih0LCBlKSB7XG4gICAgY29uc3QgeyBjYWxsYmFja3M6IHMgfSA9IGUsIG4gPSBzLmJlZm9yZUZvb3Rlci5hcHBseSh0aGlzLCBbdF0pLCBvID0gcy5mb290ZXIuYXBwbHkodGhpcywgW3RdKSwgciA9IHMuYWZ0ZXJGb290ZXIuYXBwbHkodGhpcywgW3RdKTtcbiAgICBsZXQgYSA9IFtdO1xuICAgIHJldHVybiBhID0gcnQoYSwgaHQobikpLCBhID0gcnQoYSwgaHQobykpLCBhID0gcnQoYSwgaHQocikpLCBhO1xuICB9XG4gIF9jcmVhdGVJdGVtcyh0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuX2FjdGl2ZSwgcyA9IHRoaXMuY2hhcnQuZGF0YSwgbiA9IFtdLCBvID0gW10sIHIgPSBbXTtcbiAgICBsZXQgYSA9IFtdLCBsLCBjO1xuICAgIGZvciAobCA9IDAsIGMgPSBlLmxlbmd0aDsgbCA8IGM7ICsrbClcbiAgICAgIGEucHVzaCh4Yyh0aGlzLmNoYXJ0LCBlW2xdKSk7XG4gICAgcmV0dXJuIHQuZmlsdGVyICYmIChhID0gYS5maWx0ZXIoKGgsIGQsIHUpID0+IHQuZmlsdGVyKGgsIGQsIHUsIHMpKSksIHQuaXRlbVNvcnQgJiYgKGEgPSBhLnNvcnQoKGgsIGQpID0+IHQuaXRlbVNvcnQoaCwgZCwgcykpKSwgRShhLCAoaCkgPT4ge1xuICAgICAgY29uc3QgZCA9IEpzKHQuY2FsbGJhY2tzLCBoKTtcbiAgICAgIG4ucHVzaChkLmxhYmVsQ29sb3IuY2FsbCh0aGlzLCBoKSksIG8ucHVzaChkLmxhYmVsUG9pbnRTdHlsZS5jYWxsKHRoaXMsIGgpKSwgci5wdXNoKGQubGFiZWxUZXh0Q29sb3IuY2FsbCh0aGlzLCBoKSk7XG4gICAgfSksIHRoaXMubGFiZWxDb2xvcnMgPSBuLCB0aGlzLmxhYmVsUG9pbnRTdHlsZXMgPSBvLCB0aGlzLmxhYmVsVGV4dENvbG9ycyA9IHIsIHRoaXMuZGF0YVBvaW50cyA9IGEsIGE7XG4gIH1cbiAgdXBkYXRlKHQsIGUpIHtcbiAgICBjb25zdCBzID0gdGhpcy5vcHRpb25zLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KCkpLCBuID0gdGhpcy5fYWN0aXZlO1xuICAgIGxldCBvLCByID0gW107XG4gICAgaWYgKCFuLmxlbmd0aClcbiAgICAgIHRoaXMub3BhY2l0eSAhPT0gMCAmJiAobyA9IHtcbiAgICAgICAgb3BhY2l0eTogMFxuICAgICAgfSk7XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCBhID0gc2Vbcy5wb3NpdGlvbl0uY2FsbCh0aGlzLCBuLCB0aGlzLl9ldmVudFBvc2l0aW9uKTtcbiAgICAgIHIgPSB0aGlzLl9jcmVhdGVJdGVtcyhzKSwgdGhpcy50aXRsZSA9IHRoaXMuZ2V0VGl0bGUociwgcyksIHRoaXMuYmVmb3JlQm9keSA9IHRoaXMuZ2V0QmVmb3JlQm9keShyLCBzKSwgdGhpcy5ib2R5ID0gdGhpcy5nZXRCb2R5KHIsIHMpLCB0aGlzLmFmdGVyQm9keSA9IHRoaXMuZ2V0QWZ0ZXJCb2R5KHIsIHMpLCB0aGlzLmZvb3RlciA9IHRoaXMuZ2V0Rm9vdGVyKHIsIHMpO1xuICAgICAgY29uc3QgbCA9IHRoaXMuX3NpemUgPSBLcyh0aGlzLCBzKSwgYyA9IE9iamVjdC5hc3NpZ24oe30sIGEsIGwpLCBoID0gcXModGhpcy5jaGFydCwgcywgYyksIGQgPSBHcyhzLCBjLCBoLCB0aGlzLmNoYXJ0KTtcbiAgICAgIHRoaXMueEFsaWduID0gaC54QWxpZ24sIHRoaXMueUFsaWduID0gaC55QWxpZ24sIG8gPSB7XG4gICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgIHg6IGQueCxcbiAgICAgICAgeTogZC55LFxuICAgICAgICB3aWR0aDogbC53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBsLmhlaWdodCxcbiAgICAgICAgY2FyZXRYOiBhLngsXG4gICAgICAgIGNhcmV0WTogYS55XG4gICAgICB9O1xuICAgIH1cbiAgICB0aGlzLl90b29sdGlwSXRlbXMgPSByLCB0aGlzLiRjb250ZXh0ID0gdm9pZCAwLCBvICYmIHRoaXMuX3Jlc29sdmVBbmltYXRpb25zKCkudXBkYXRlKHRoaXMsIG8pLCB0ICYmIHMuZXh0ZXJuYWwgJiYgcy5leHRlcm5hbC5jYWxsKHRoaXMsIHsgY2hhcnQ6IHRoaXMuY2hhcnQsIHRvb2x0aXA6IHRoaXMsIHJlcGxheTogZSB9KTtcbiAgfVxuICBkcmF3Q2FyZXQodCwgZSwgcywgbikge1xuICAgIGNvbnN0IG8gPSB0aGlzLmdldENhcmV0UG9zaXRpb24odCwgcywgbik7XG4gICAgZS5saW5lVG8oby54MSwgby55MSksIGUubGluZVRvKG8ueDIsIG8ueTIpLCBlLmxpbmVUbyhvLngzLCBvLnkzKTtcbiAgfVxuICBnZXRDYXJldFBvc2l0aW9uKHQsIGUsIHMpIHtcbiAgICBjb25zdCB7IHhBbGlnbjogbiwgeUFsaWduOiBvIH0gPSB0aGlzLCB7IGNhcmV0U2l6ZTogciwgY29ybmVyUmFkaXVzOiBhIH0gPSBzLCB7IHRvcExlZnQ6IGwsIHRvcFJpZ2h0OiBjLCBib3R0b21MZWZ0OiBoLCBib3R0b21SaWdodDogZCB9ID0gRHQoYSksIHsgeDogdSwgeTogZiB9ID0gdCwgeyB3aWR0aDogZywgaGVpZ2h0OiBwIH0gPSBlO1xuICAgIGxldCBtLCBiLCB4LCB2LCB5LCBfO1xuICAgIHJldHVybiBvID09PSBcImNlbnRlclwiID8gKHkgPSBmICsgcCAvIDIsIG4gPT09IFwibGVmdFwiID8gKG0gPSB1LCBiID0gbSAtIHIsIHYgPSB5ICsgciwgXyA9IHkgLSByKSA6IChtID0gdSArIGcsIGIgPSBtICsgciwgdiA9IHkgLSByLCBfID0geSArIHIpLCB4ID0gbSkgOiAobiA9PT0gXCJsZWZ0XCIgPyBiID0gdSArIE1hdGgubWF4KGwsIGgpICsgciA6IG4gPT09IFwicmlnaHRcIiA/IGIgPSB1ICsgZyAtIE1hdGgubWF4KGMsIGQpIC0gciA6IGIgPSB0aGlzLmNhcmV0WCwgbyA9PT0gXCJ0b3BcIiA/ICh2ID0gZiwgeSA9IHYgLSByLCBtID0gYiAtIHIsIHggPSBiICsgcikgOiAodiA9IGYgKyBwLCB5ID0gdiArIHIsIG0gPSBiICsgciwgeCA9IGIgLSByKSwgXyA9IHYpLCB7IHgxOiBtLCB4MjogYiwgeDM6IHgsIHkxOiB2LCB5MjogeSwgeTM6IF8gfTtcbiAgfVxuICBkcmF3VGl0bGUodCwgZSwgcykge1xuICAgIGNvbnN0IG4gPSB0aGlzLnRpdGxlLCBvID0gbi5sZW5ndGg7XG4gICAgbGV0IHIsIGEsIGw7XG4gICAgaWYgKG8pIHtcbiAgICAgIGNvbnN0IGMgPSB6dChzLnJ0bCwgdGhpcy54LCB0aGlzLndpZHRoKTtcbiAgICAgIGZvciAodC54ID0gRWUodGhpcywgcy50aXRsZUFsaWduLCBzKSwgZS50ZXh0QWxpZ24gPSBjLnRleHRBbGlnbihzLnRpdGxlQWxpZ24pLCBlLnRleHRCYXNlbGluZSA9IFwibWlkZGxlXCIsIHIgPSAkKHMudGl0bGVGb250KSwgYSA9IHMudGl0bGVTcGFjaW5nLCBlLmZpbGxTdHlsZSA9IHMudGl0bGVDb2xvciwgZS5mb250ID0gci5zdHJpbmcsIGwgPSAwOyBsIDwgbzsgKytsKVxuICAgICAgICBlLmZpbGxUZXh0KG5bbF0sIGMueCh0LngpLCB0LnkgKyByLmxpbmVIZWlnaHQgLyAyKSwgdC55ICs9IHIubGluZUhlaWdodCArIGEsIGwgKyAxID09PSBvICYmICh0LnkgKz0gcy50aXRsZU1hcmdpbkJvdHRvbSAtIGEpO1xuICAgIH1cbiAgfVxuICBfZHJhd0NvbG9yQm94KHQsIGUsIHMsIG4sIG8pIHtcbiAgICBjb25zdCByID0gdGhpcy5sYWJlbENvbG9yc1tzXSwgYSA9IHRoaXMubGFiZWxQb2ludFN0eWxlc1tzXSwgeyBib3hIZWlnaHQ6IGwsIGJveFdpZHRoOiBjLCBib3hQYWRkaW5nOiBoIH0gPSBvLCBkID0gJChvLmJvZHlGb250KSwgdSA9IEVlKHRoaXMsIFwibGVmdFwiLCBvKSwgZiA9IG4ueCh1KSwgZyA9IGwgPCBkLmxpbmVIZWlnaHQgPyAoZC5saW5lSGVpZ2h0IC0gbCkgLyAyIDogMCwgcCA9IGUueSArIGc7XG4gICAgaWYgKG8udXNlUG9pbnRTdHlsZSkge1xuICAgICAgY29uc3QgbSA9IHtcbiAgICAgICAgcmFkaXVzOiBNYXRoLm1pbihjLCBsKSAvIDIsXG4gICAgICAgIHBvaW50U3R5bGU6IGEucG9pbnRTdHlsZSxcbiAgICAgICAgcm90YXRpb246IGEucm90YXRpb24sXG4gICAgICAgIGJvcmRlcldpZHRoOiAxXG4gICAgICB9LCBiID0gbi5sZWZ0Rm9yTHRyKGYsIGMpICsgYyAvIDIsIHggPSBwICsgbCAvIDI7XG4gICAgICB0LnN0cm9rZVN0eWxlID0gby5tdWx0aUtleUJhY2tncm91bmQsIHQuZmlsbFN0eWxlID0gby5tdWx0aUtleUJhY2tncm91bmQsIHlpKHQsIG0sIGIsIHgpLCB0LnN0cm9rZVN0eWxlID0gci5ib3JkZXJDb2xvciwgdC5maWxsU3R5bGUgPSByLmJhY2tncm91bmRDb2xvciwgeWkodCwgbSwgYiwgeCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHQubGluZVdpZHRoID0gRChyLmJvcmRlcldpZHRoKSA/IE1hdGgubWF4KC4uLk9iamVjdC52YWx1ZXMoci5ib3JkZXJXaWR0aCkpIDogci5ib3JkZXJXaWR0aCB8fCAxLCB0LnN0cm9rZVN0eWxlID0gci5ib3JkZXJDb2xvciwgdC5zZXRMaW5lRGFzaChyLmJvcmRlckRhc2ggfHwgW10pLCB0LmxpbmVEYXNoT2Zmc2V0ID0gci5ib3JkZXJEYXNoT2Zmc2V0IHx8IDA7XG4gICAgICBjb25zdCBtID0gbi5sZWZ0Rm9yTHRyKGYsIGMgLSBoKSwgYiA9IG4ubGVmdEZvckx0cihuLnhQbHVzKGYsIDEpLCBjIC0gaCAtIDIpLCB4ID0gRHQoci5ib3JkZXJSYWRpdXMpO1xuICAgICAgT2JqZWN0LnZhbHVlcyh4KS5zb21lKCh2KSA9PiB2ICE9PSAwKSA/ICh0LmJlZ2luUGF0aCgpLCB0LmZpbGxTdHlsZSA9IG8ubXVsdGlLZXlCYWNrZ3JvdW5kLCBhZSh0LCB7XG4gICAgICAgIHg6IG0sXG4gICAgICAgIHk6IHAsXG4gICAgICAgIHc6IGMsXG4gICAgICAgIGg6IGwsXG4gICAgICAgIHJhZGl1czogeFxuICAgICAgfSksIHQuZmlsbCgpLCB0LnN0cm9rZSgpLCB0LmZpbGxTdHlsZSA9IHIuYmFja2dyb3VuZENvbG9yLCB0LmJlZ2luUGF0aCgpLCBhZSh0LCB7XG4gICAgICAgIHg6IGIsXG4gICAgICAgIHk6IHAgKyAxLFxuICAgICAgICB3OiBjIC0gMixcbiAgICAgICAgaDogbCAtIDIsXG4gICAgICAgIHJhZGl1czogeFxuICAgICAgfSksIHQuZmlsbCgpKSA6ICh0LmZpbGxTdHlsZSA9IG8ubXVsdGlLZXlCYWNrZ3JvdW5kLCB0LmZpbGxSZWN0KG0sIHAsIGMsIGwpLCB0LnN0cm9rZVJlY3QobSwgcCwgYywgbCksIHQuZmlsbFN0eWxlID0gci5iYWNrZ3JvdW5kQ29sb3IsIHQuZmlsbFJlY3QoYiwgcCArIDEsIGMgLSAyLCBsIC0gMikpO1xuICAgIH1cbiAgICB0LmZpbGxTdHlsZSA9IHRoaXMubGFiZWxUZXh0Q29sb3JzW3NdO1xuICB9XG4gIGRyYXdCb2R5KHQsIGUsIHMpIHtcbiAgICBjb25zdCB7IGJvZHk6IG4gfSA9IHRoaXMsIHsgYm9keVNwYWNpbmc6IG8sIGJvZHlBbGlnbjogciwgZGlzcGxheUNvbG9yczogYSwgYm94SGVpZ2h0OiBsLCBib3hXaWR0aDogYywgYm94UGFkZGluZzogaCB9ID0gcywgZCA9ICQocy5ib2R5Rm9udCk7XG4gICAgbGV0IHUgPSBkLmxpbmVIZWlnaHQsIGYgPSAwO1xuICAgIGNvbnN0IGcgPSB6dChzLnJ0bCwgdGhpcy54LCB0aGlzLndpZHRoKSwgcCA9IGZ1bmN0aW9uKFMpIHtcbiAgICAgIGUuZmlsbFRleHQoUywgZy54KHQueCArIGYpLCB0LnkgKyB1IC8gMiksIHQueSArPSB1ICsgbztcbiAgICB9LCBtID0gZy50ZXh0QWxpZ24ocik7XG4gICAgbGV0IGIsIHgsIHYsIHksIF8sIE0sIGs7XG4gICAgZm9yIChlLnRleHRBbGlnbiA9IHIsIGUudGV4dEJhc2VsaW5lID0gXCJtaWRkbGVcIiwgZS5mb250ID0gZC5zdHJpbmcsIHQueCA9IEVlKHRoaXMsIG0sIHMpLCBlLmZpbGxTdHlsZSA9IHMuYm9keUNvbG9yLCBFKHRoaXMuYmVmb3JlQm9keSwgcCksIGYgPSBhICYmIG0gIT09IFwicmlnaHRcIiA/IHIgPT09IFwiY2VudGVyXCIgPyBjIC8gMiArIGggOiBjICsgMiArIGggOiAwLCB5ID0gMCwgTSA9IG4ubGVuZ3RoOyB5IDwgTTsgKyt5KSB7XG4gICAgICBmb3IgKGIgPSBuW3ldLCB4ID0gdGhpcy5sYWJlbFRleHRDb2xvcnNbeV0sIGUuZmlsbFN0eWxlID0geCwgRShiLmJlZm9yZSwgcCksIHYgPSBiLmxpbmVzLCBhICYmIHYubGVuZ3RoICYmICh0aGlzLl9kcmF3Q29sb3JCb3goZSwgdCwgeSwgZywgcyksIHUgPSBNYXRoLm1heChkLmxpbmVIZWlnaHQsIGwpKSwgXyA9IDAsIGsgPSB2Lmxlbmd0aDsgXyA8IGs7ICsrXylcbiAgICAgICAgcCh2W19dKSwgdSA9IGQubGluZUhlaWdodDtcbiAgICAgIEUoYi5hZnRlciwgcCk7XG4gICAgfVxuICAgIGYgPSAwLCB1ID0gZC5saW5lSGVpZ2h0LCBFKHRoaXMuYWZ0ZXJCb2R5LCBwKSwgdC55IC09IG87XG4gIH1cbiAgZHJhd0Zvb3Rlcih0LCBlLCBzKSB7XG4gICAgY29uc3QgbiA9IHRoaXMuZm9vdGVyLCBvID0gbi5sZW5ndGg7XG4gICAgbGV0IHIsIGE7XG4gICAgaWYgKG8pIHtcbiAgICAgIGNvbnN0IGwgPSB6dChzLnJ0bCwgdGhpcy54LCB0aGlzLndpZHRoKTtcbiAgICAgIGZvciAodC54ID0gRWUodGhpcywgcy5mb290ZXJBbGlnbiwgcyksIHQueSArPSBzLmZvb3Rlck1hcmdpblRvcCwgZS50ZXh0QWxpZ24gPSBsLnRleHRBbGlnbihzLmZvb3RlckFsaWduKSwgZS50ZXh0QmFzZWxpbmUgPSBcIm1pZGRsZVwiLCByID0gJChzLmZvb3RlckZvbnQpLCBlLmZpbGxTdHlsZSA9IHMuZm9vdGVyQ29sb3IsIGUuZm9udCA9IHIuc3RyaW5nLCBhID0gMDsgYSA8IG87ICsrYSlcbiAgICAgICAgZS5maWxsVGV4dChuW2FdLCBsLngodC54KSwgdC55ICsgci5saW5lSGVpZ2h0IC8gMiksIHQueSArPSByLmxpbmVIZWlnaHQgKyBzLmZvb3RlclNwYWNpbmc7XG4gICAgfVxuICB9XG4gIGRyYXdCYWNrZ3JvdW5kKHQsIGUsIHMsIG4pIHtcbiAgICBjb25zdCB7IHhBbGlnbjogbywgeUFsaWduOiByIH0gPSB0aGlzLCB7IHg6IGEsIHk6IGwgfSA9IHQsIHsgd2lkdGg6IGMsIGhlaWdodDogaCB9ID0gcywgeyB0b3BMZWZ0OiBkLCB0b3BSaWdodDogdSwgYm90dG9tTGVmdDogZiwgYm90dG9tUmlnaHQ6IGcgfSA9IER0KG4uY29ybmVyUmFkaXVzKTtcbiAgICBlLmZpbGxTdHlsZSA9IG4uYmFja2dyb3VuZENvbG9yLCBlLnN0cm9rZVN0eWxlID0gbi5ib3JkZXJDb2xvciwgZS5saW5lV2lkdGggPSBuLmJvcmRlcldpZHRoLCBlLmJlZ2luUGF0aCgpLCBlLm1vdmVUbyhhICsgZCwgbCksIHIgPT09IFwidG9wXCIgJiYgdGhpcy5kcmF3Q2FyZXQodCwgZSwgcywgbiksIGUubGluZVRvKGEgKyBjIC0gdSwgbCksIGUucXVhZHJhdGljQ3VydmVUbyhhICsgYywgbCwgYSArIGMsIGwgKyB1KSwgciA9PT0gXCJjZW50ZXJcIiAmJiBvID09PSBcInJpZ2h0XCIgJiYgdGhpcy5kcmF3Q2FyZXQodCwgZSwgcywgbiksIGUubGluZVRvKGEgKyBjLCBsICsgaCAtIGcpLCBlLnF1YWRyYXRpY0N1cnZlVG8oYSArIGMsIGwgKyBoLCBhICsgYyAtIGcsIGwgKyBoKSwgciA9PT0gXCJib3R0b21cIiAmJiB0aGlzLmRyYXdDYXJldCh0LCBlLCBzLCBuKSwgZS5saW5lVG8oYSArIGYsIGwgKyBoKSwgZS5xdWFkcmF0aWNDdXJ2ZVRvKGEsIGwgKyBoLCBhLCBsICsgaCAtIGYpLCByID09PSBcImNlbnRlclwiICYmIG8gPT09IFwibGVmdFwiICYmIHRoaXMuZHJhd0NhcmV0KHQsIGUsIHMsIG4pLCBlLmxpbmVUbyhhLCBsICsgZCksIGUucXVhZHJhdGljQ3VydmVUbyhhLCBsLCBhICsgZCwgbCksIGUuY2xvc2VQYXRoKCksIGUuZmlsbCgpLCBuLmJvcmRlcldpZHRoID4gMCAmJiBlLnN0cm9rZSgpO1xuICB9XG4gIF91cGRhdGVBbmltYXRpb25UYXJnZXQodCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLmNoYXJ0LCBzID0gdGhpcy4kYW5pbWF0aW9ucywgbiA9IHMgJiYgcy54LCBvID0gcyAmJiBzLnk7XG4gICAgaWYgKG4gfHwgbykge1xuICAgICAgY29uc3QgciA9IHNlW3QucG9zaXRpb25dLmNhbGwodGhpcywgdGhpcy5fYWN0aXZlLCB0aGlzLl9ldmVudFBvc2l0aW9uKTtcbiAgICAgIGlmICghcilcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgYSA9IHRoaXMuX3NpemUgPSBLcyh0aGlzLCB0KSwgbCA9IE9iamVjdC5hc3NpZ24oe30sIHIsIHRoaXMuX3NpemUpLCBjID0gcXMoZSwgdCwgbCksIGggPSBHcyh0LCBsLCBjLCBlKTtcbiAgICAgIChuLl90byAhPT0gaC54IHx8IG8uX3RvICE9PSBoLnkpICYmICh0aGlzLnhBbGlnbiA9IGMueEFsaWduLCB0aGlzLnlBbGlnbiA9IGMueUFsaWduLCB0aGlzLndpZHRoID0gYS53aWR0aCwgdGhpcy5oZWlnaHQgPSBhLmhlaWdodCwgdGhpcy5jYXJldFggPSByLngsIHRoaXMuY2FyZXRZID0gci55LCB0aGlzLl9yZXNvbHZlQW5pbWF0aW9ucygpLnVwZGF0ZSh0aGlzLCBoKSk7XG4gICAgfVxuICB9XG4gIF93aWxsUmVuZGVyKCkge1xuICAgIHJldHVybiAhIXRoaXMub3BhY2l0eTtcbiAgfVxuICBkcmF3KHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5vcHRpb25zLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIGxldCBzID0gdGhpcy5vcGFjaXR5O1xuICAgIGlmICghcylcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl91cGRhdGVBbmltYXRpb25UYXJnZXQoZSk7XG4gICAgY29uc3QgbiA9IHtcbiAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodFxuICAgIH0sIG8gPSB7XG4gICAgICB4OiB0aGlzLngsXG4gICAgICB5OiB0aGlzLnlcbiAgICB9O1xuICAgIHMgPSBNYXRoLmFicyhzKSA8IDFlLTMgPyAwIDogcztcbiAgICBjb25zdCByID0gSyhlLnBhZGRpbmcpLCBhID0gdGhpcy50aXRsZS5sZW5ndGggfHwgdGhpcy5iZWZvcmVCb2R5Lmxlbmd0aCB8fCB0aGlzLmJvZHkubGVuZ3RoIHx8IHRoaXMuYWZ0ZXJCb2R5Lmxlbmd0aCB8fCB0aGlzLmZvb3Rlci5sZW5ndGg7XG4gICAgZS5lbmFibGVkICYmIGEgJiYgKHQuc2F2ZSgpLCB0Lmdsb2JhbEFscGhhID0gcywgdGhpcy5kcmF3QmFja2dyb3VuZChvLCB0LCBuLCBlKSwgVG4odCwgZS50ZXh0RGlyZWN0aW9uKSwgby55ICs9IHIudG9wLCB0aGlzLmRyYXdUaXRsZShvLCB0LCBlKSwgdGhpcy5kcmF3Qm9keShvLCB0LCBlKSwgdGhpcy5kcmF3Rm9vdGVyKG8sIHQsIGUpLCBMbih0LCBlLnRleHREaXJlY3Rpb24pLCB0LnJlc3RvcmUoKSk7XG4gIH1cbiAgZ2V0QWN0aXZlRWxlbWVudHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FjdGl2ZSB8fCBbXTtcbiAgfVxuICBzZXRBY3RpdmVFbGVtZW50cyh0LCBlKSB7XG4gICAgY29uc3QgcyA9IHRoaXMuX2FjdGl2ZSwgbiA9IHQubWFwKCh7IGRhdGFzZXRJbmRleDogYSwgaW5kZXg6IGwgfSkgPT4ge1xuICAgICAgY29uc3QgYyA9IHRoaXMuY2hhcnQuZ2V0RGF0YXNldE1ldGEoYSk7XG4gICAgICBpZiAoIWMpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIGEgZGF0YXNldCBhdCBpbmRleCBcIiArIGEpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YXNldEluZGV4OiBhLFxuICAgICAgICBlbGVtZW50OiBjLmRhdGFbbF0sXG4gICAgICAgIGluZGV4OiBsXG4gICAgICB9O1xuICAgIH0pLCBvID0gIXplKHMsIG4pLCByID0gdGhpcy5fcG9zaXRpb25DaGFuZ2VkKG4sIGUpO1xuICAgIChvIHx8IHIpICYmICh0aGlzLl9hY3RpdmUgPSBuLCB0aGlzLl9ldmVudFBvc2l0aW9uID0gZSwgdGhpcy5faWdub3JlUmVwbGF5RXZlbnRzID0gITAsIHRoaXMudXBkYXRlKCEwKSk7XG4gIH1cbiAgaGFuZGxlRXZlbnQodCwgZSwgcyA9ICEwKSB7XG4gICAgaWYgKGUgJiYgdGhpcy5faWdub3JlUmVwbGF5RXZlbnRzKVxuICAgICAgcmV0dXJuICExO1xuICAgIHRoaXMuX2lnbm9yZVJlcGxheUV2ZW50cyA9ICExO1xuICAgIGNvbnN0IG4gPSB0aGlzLm9wdGlvbnMsIG8gPSB0aGlzLl9hY3RpdmUgfHwgW10sIHIgPSB0aGlzLl9nZXRBY3RpdmVFbGVtZW50cyh0LCBvLCBlLCBzKSwgYSA9IHRoaXMuX3Bvc2l0aW9uQ2hhbmdlZChyLCB0KSwgbCA9IGUgfHwgIXplKHIsIG8pIHx8IGE7XG4gICAgcmV0dXJuIGwgJiYgKHRoaXMuX2FjdGl2ZSA9IHIsIChuLmVuYWJsZWQgfHwgbi5leHRlcm5hbCkgJiYgKHRoaXMuX2V2ZW50UG9zaXRpb24gPSB7XG4gICAgICB4OiB0LngsXG4gICAgICB5OiB0LnlcbiAgICB9LCB0aGlzLnVwZGF0ZSghMCwgZSkpKSwgbDtcbiAgfVxuICBfZ2V0QWN0aXZlRWxlbWVudHModCwgZSwgcywgbikge1xuICAgIGNvbnN0IG8gPSB0aGlzLm9wdGlvbnM7XG4gICAgaWYgKHQudHlwZSA9PT0gXCJtb3VzZW91dFwiKVxuICAgICAgcmV0dXJuIFtdO1xuICAgIGlmICghbilcbiAgICAgIHJldHVybiBlO1xuICAgIGNvbnN0IHIgPSB0aGlzLmNoYXJ0LmdldEVsZW1lbnRzQXRFdmVudEZvck1vZGUodCwgby5tb2RlLCBvLCBzKTtcbiAgICByZXR1cm4gby5yZXZlcnNlICYmIHIucmV2ZXJzZSgpLCByO1xuICB9XG4gIF9wb3NpdGlvbkNoYW5nZWQodCwgZSkge1xuICAgIGNvbnN0IHsgY2FyZXRYOiBzLCBjYXJldFk6IG4sIG9wdGlvbnM6IG8gfSA9IHRoaXMsIHIgPSBzZVtvLnBvc2l0aW9uXS5jYWxsKHRoaXMsIHQsIGUpO1xuICAgIHJldHVybiByICE9PSAhMSAmJiAocyAhPT0gci54IHx8IG4gIT09IHIueSk7XG4gIH1cbn1cbkNpLnBvc2l0aW9uZXJzID0gc2U7XG52YXIgcG8gPSB7XG4gIGlkOiBcInRvb2x0aXBcIixcbiAgX2VsZW1lbnQ6IENpLFxuICBwb3NpdGlvbmVyczogc2UsXG4gIGFmdGVySW5pdChpLCB0LCBlKSB7XG4gICAgZSAmJiAoaS50b29sdGlwID0gbmV3IENpKHsgY2hhcnQ6IGksIG9wdGlvbnM6IGUgfSkpO1xuICB9LFxuICBiZWZvcmVVcGRhdGUoaSwgdCwgZSkge1xuICAgIGkudG9vbHRpcCAmJiBpLnRvb2x0aXAuaW5pdGlhbGl6ZShlKTtcbiAgfSxcbiAgcmVzZXQoaSwgdCwgZSkge1xuICAgIGkudG9vbHRpcCAmJiBpLnRvb2x0aXAuaW5pdGlhbGl6ZShlKTtcbiAgfSxcbiAgYWZ0ZXJEcmF3KGkpIHtcbiAgICBjb25zdCB0ID0gaS50b29sdGlwO1xuICAgIGlmICh0ICYmIHQuX3dpbGxSZW5kZXIoKSkge1xuICAgICAgY29uc3QgZSA9IHtcbiAgICAgICAgdG9vbHRpcDogdFxuICAgICAgfTtcbiAgICAgIGlmIChpLm5vdGlmeVBsdWdpbnMoXCJiZWZvcmVUb29sdGlwRHJhd1wiLCBlKSA9PT0gITEpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHQuZHJhdyhpLmN0eCksIGkubm90aWZ5UGx1Z2lucyhcImFmdGVyVG9vbHRpcERyYXdcIiwgZSk7XG4gICAgfVxuICB9LFxuICBhZnRlckV2ZW50KGksIHQpIHtcbiAgICBpZiAoaS50b29sdGlwKSB7XG4gICAgICBjb25zdCBlID0gdC5yZXBsYXk7XG4gICAgICBpLnRvb2x0aXAuaGFuZGxlRXZlbnQodC5ldmVudCwgZSwgdC5pbkNoYXJ0QXJlYSkgJiYgKHQuY2hhbmdlZCA9ICEwKTtcbiAgICB9XG4gIH0sXG4gIGRlZmF1bHRzOiB7XG4gICAgZW5hYmxlZDogITAsXG4gICAgZXh0ZXJuYWw6IG51bGwsXG4gICAgcG9zaXRpb246IFwiYXZlcmFnZVwiLFxuICAgIGJhY2tncm91bmRDb2xvcjogXCJyZ2JhKDAsMCwwLDAuOClcIixcbiAgICB0aXRsZUNvbG9yOiBcIiNmZmZcIixcbiAgICB0aXRsZUZvbnQ6IHtcbiAgICAgIHdlaWdodDogXCJib2xkXCJcbiAgICB9LFxuICAgIHRpdGxlU3BhY2luZzogMixcbiAgICB0aXRsZU1hcmdpbkJvdHRvbTogNixcbiAgICB0aXRsZUFsaWduOiBcImxlZnRcIixcbiAgICBib2R5Q29sb3I6IFwiI2ZmZlwiLFxuICAgIGJvZHlTcGFjaW5nOiAyLFxuICAgIGJvZHlGb250OiB7fSxcbiAgICBib2R5QWxpZ246IFwibGVmdFwiLFxuICAgIGZvb3RlckNvbG9yOiBcIiNmZmZcIixcbiAgICBmb290ZXJTcGFjaW5nOiAyLFxuICAgIGZvb3Rlck1hcmdpblRvcDogNixcbiAgICBmb290ZXJGb250OiB7XG4gICAgICB3ZWlnaHQ6IFwiYm9sZFwiXG4gICAgfSxcbiAgICBmb290ZXJBbGlnbjogXCJsZWZ0XCIsXG4gICAgcGFkZGluZzogNixcbiAgICBjYXJldFBhZGRpbmc6IDIsXG4gICAgY2FyZXRTaXplOiA1LFxuICAgIGNvcm5lclJhZGl1czogNixcbiAgICBib3hIZWlnaHQ6IChpLCB0KSA9PiB0LmJvZHlGb250LnNpemUsXG4gICAgYm94V2lkdGg6IChpLCB0KSA9PiB0LmJvZHlGb250LnNpemUsXG4gICAgbXVsdGlLZXlCYWNrZ3JvdW5kOiBcIiNmZmZcIixcbiAgICBkaXNwbGF5Q29sb3JzOiAhMCxcbiAgICBib3hQYWRkaW5nOiAwLFxuICAgIGJvcmRlckNvbG9yOiBcInJnYmEoMCwwLDAsMClcIixcbiAgICBib3JkZXJXaWR0aDogMCxcbiAgICBhbmltYXRpb246IHtcbiAgICAgIGR1cmF0aW9uOiA0MDAsXG4gICAgICBlYXNpbmc6IFwiZWFzZU91dFF1YXJ0XCJcbiAgICB9LFxuICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgIG51bWJlcnM6IHtcbiAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgcHJvcGVydGllczogW1wieFwiLCBcInlcIiwgXCJ3aWR0aFwiLCBcImhlaWdodFwiLCBcImNhcmV0WFwiLCBcImNhcmV0WVwiXVxuICAgICAgfSxcbiAgICAgIG9wYWNpdHk6IHtcbiAgICAgICAgZWFzaW5nOiBcImxpbmVhclwiLFxuICAgICAgICBkdXJhdGlvbjogMjAwXG4gICAgICB9XG4gICAgfSxcbiAgICBjYWxsYmFja3M6IHtcbiAgICAgIGJlZm9yZVRpdGxlOiBjdCxcbiAgICAgIHRpdGxlKGkpIHtcbiAgICAgICAgaWYgKGkubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IHQgPSBpWzBdLCBlID0gdC5jaGFydC5kYXRhLmxhYmVscywgcyA9IGUgPyBlLmxlbmd0aCA6IDA7XG4gICAgICAgICAgaWYgKHRoaXMgJiYgdGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5tb2RlID09PSBcImRhdGFzZXRcIilcbiAgICAgICAgICAgIHJldHVybiB0LmRhdGFzZXQubGFiZWwgfHwgXCJcIjtcbiAgICAgICAgICBpZiAodC5sYWJlbClcbiAgICAgICAgICAgIHJldHVybiB0LmxhYmVsO1xuICAgICAgICAgIGlmIChzID4gMCAmJiB0LmRhdGFJbmRleCA8IHMpXG4gICAgICAgICAgICByZXR1cm4gZVt0LmRhdGFJbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9LFxuICAgICAgYWZ0ZXJUaXRsZTogY3QsXG4gICAgICBiZWZvcmVCb2R5OiBjdCxcbiAgICAgIGJlZm9yZUxhYmVsOiBjdCxcbiAgICAgIGxhYmVsKGkpIHtcbiAgICAgICAgaWYgKHRoaXMgJiYgdGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5tb2RlID09PSBcImRhdGFzZXRcIilcbiAgICAgICAgICByZXR1cm4gaS5sYWJlbCArIFwiOiBcIiArIGkuZm9ybWF0dGVkVmFsdWUgfHwgaS5mb3JtYXR0ZWRWYWx1ZTtcbiAgICAgICAgbGV0IHQgPSBpLmRhdGFzZXQubGFiZWwgfHwgXCJcIjtcbiAgICAgICAgdCAmJiAodCArPSBcIjogXCIpO1xuICAgICAgICBjb25zdCBlID0gaS5mb3JtYXR0ZWRWYWx1ZTtcbiAgICAgICAgcmV0dXJuIFQoZSkgfHwgKHQgKz0gZSksIHQ7XG4gICAgICB9LFxuICAgICAgbGFiZWxDb2xvcihpKSB7XG4gICAgICAgIGNvbnN0IGUgPSBpLmNoYXJ0LmdldERhdGFzZXRNZXRhKGkuZGF0YXNldEluZGV4KS5jb250cm9sbGVyLmdldFN0eWxlKGkuZGF0YUluZGV4KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBib3JkZXJDb2xvcjogZS5ib3JkZXJDb2xvcixcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGUuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgIGJvcmRlcldpZHRoOiBlLmJvcmRlcldpZHRoLFxuICAgICAgICAgIGJvcmRlckRhc2g6IGUuYm9yZGVyRGFzaCxcbiAgICAgICAgICBib3JkZXJEYXNoT2Zmc2V0OiBlLmJvcmRlckRhc2hPZmZzZXQsXG4gICAgICAgICAgYm9yZGVyUmFkaXVzOiAwXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgbGFiZWxUZXh0Q29sb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuYm9keUNvbG9yO1xuICAgICAgfSxcbiAgICAgIGxhYmVsUG9pbnRTdHlsZShpKSB7XG4gICAgICAgIGNvbnN0IGUgPSBpLmNoYXJ0LmdldERhdGFzZXRNZXRhKGkuZGF0YXNldEluZGV4KS5jb250cm9sbGVyLmdldFN0eWxlKGkuZGF0YUluZGV4KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwb2ludFN0eWxlOiBlLnBvaW50U3R5bGUsXG4gICAgICAgICAgcm90YXRpb246IGUucm90YXRpb25cbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBhZnRlckxhYmVsOiBjdCxcbiAgICAgIGFmdGVyQm9keTogY3QsXG4gICAgICBiZWZvcmVGb290ZXI6IGN0LFxuICAgICAgZm9vdGVyOiBjdCxcbiAgICAgIGFmdGVyRm9vdGVyOiBjdFxuICAgIH1cbiAgfSxcbiAgZGVmYXVsdFJvdXRlczoge1xuICAgIGJvZHlGb250OiBcImZvbnRcIixcbiAgICBmb290ZXJGb250OiBcImZvbnRcIixcbiAgICB0aXRsZUZvbnQ6IFwiZm9udFwiXG4gIH0sXG4gIGRlc2NyaXB0b3JzOiB7XG4gICAgX3NjcmlwdGFibGU6IChpKSA9PiBpICE9PSBcImZpbHRlclwiICYmIGkgIT09IFwiaXRlbVNvcnRcIiAmJiBpICE9PSBcImV4dGVybmFsXCIsXG4gICAgX2luZGV4YWJsZTogITEsXG4gICAgY2FsbGJhY2tzOiB7XG4gICAgICBfc2NyaXB0YWJsZTogITEsXG4gICAgICBfaW5kZXhhYmxlOiAhMVxuICAgIH0sXG4gICAgYW5pbWF0aW9uOiB7XG4gICAgICBfZmFsbGJhY2s6ICExXG4gICAgfSxcbiAgICBhbmltYXRpb25zOiB7XG4gICAgICBfZmFsbGJhY2s6IFwiYW5pbWF0aW9uXCJcbiAgICB9XG4gIH0sXG4gIGFkZGl0aW9uYWxPcHRpb25TY29wZXM6IFtcImludGVyYWN0aW9uXCJdXG59LCBtbyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBEZWNpbWF0aW9uOiBhbyxcbiAgRmlsbGVyOiBobyxcbiAgTGVnZW5kOiB1byxcbiAgU3ViVGl0bGU6IGdvLFxuICBUaXRsZTogZm8sXG4gIFRvb2x0aXA6IHBvXG59KTtcbmNvbnN0IFNjID0gKGksIHQsIGUsIHMpID0+ICh0eXBlb2YgdCA9PSBcInN0cmluZ1wiID8gKGUgPSBpLnB1c2godCkgLSAxLCBzLnVuc2hpZnQoeyBpbmRleDogZSwgbGFiZWw6IHQgfSkpIDogaXNOYU4odCkgJiYgKGUgPSBudWxsKSwgZSk7XG5mdW5jdGlvbiBQYyhpLCB0LCBlLCBzKSB7XG4gIGNvbnN0IG4gPSBpLmluZGV4T2YodCk7XG4gIGlmIChuID09PSAtMSlcbiAgICByZXR1cm4gU2MoaSwgdCwgZSwgcyk7XG4gIGNvbnN0IG8gPSBpLmxhc3RJbmRleE9mKHQpO1xuICByZXR1cm4gbiAhPT0gbyA/IGUgOiBuO1xufVxuY29uc3QgQ2MgPSAoaSwgdCkgPT4gaSA9PT0gbnVsbCA/IG51bGwgOiBZKE1hdGgucm91bmQoaSksIDAsIHQpO1xuY2xhc3MgY2UgZXh0ZW5kcyBNdCB7XG4gIGNvbnN0cnVjdG9yKHQpIHtcbiAgICBzdXBlcih0KSwgdGhpcy5fc3RhcnRWYWx1ZSA9IHZvaWQgMCwgdGhpcy5fdmFsdWVSYW5nZSA9IDAsIHRoaXMuX2FkZGVkTGFiZWxzID0gW107XG4gIH1cbiAgaW5pdCh0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuX2FkZGVkTGFiZWxzO1xuICAgIGlmIChlLmxlbmd0aCkge1xuICAgICAgY29uc3QgcyA9IHRoaXMuZ2V0TGFiZWxzKCk7XG4gICAgICBmb3IgKGNvbnN0IHsgaW5kZXg6IG4sIGxhYmVsOiBvIH0gb2YgZSlcbiAgICAgICAgc1tuXSA9PT0gbyAmJiBzLnNwbGljZShuLCAxKTtcbiAgICAgIHRoaXMuX2FkZGVkTGFiZWxzID0gW107XG4gICAgfVxuICAgIHN1cGVyLmluaXQodCk7XG4gIH1cbiAgcGFyc2UodCwgZSkge1xuICAgIGlmIChUKHQpKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgcyA9IHRoaXMuZ2V0TGFiZWxzKCk7XG4gICAgcmV0dXJuIGUgPSBpc0Zpbml0ZShlKSAmJiBzW2VdID09PSB0ID8gZSA6IFBjKHMsIHQsIEMoZSwgdCksIHRoaXMuX2FkZGVkTGFiZWxzKSwgQ2MoZSwgcy5sZW5ndGggLSAxKTtcbiAgfVxuICBkZXRlcm1pbmVEYXRhTGltaXRzKCkge1xuICAgIGNvbnN0IHsgbWluRGVmaW5lZDogdCwgbWF4RGVmaW5lZDogZSB9ID0gdGhpcy5nZXRVc2VyQm91bmRzKCk7XG4gICAgbGV0IHsgbWluOiBzLCBtYXg6IG4gfSA9IHRoaXMuZ2V0TWluTWF4KCEwKTtcbiAgICB0aGlzLm9wdGlvbnMuYm91bmRzID09PSBcInRpY2tzXCIgJiYgKHQgfHwgKHMgPSAwKSwgZSB8fCAobiA9IHRoaXMuZ2V0TGFiZWxzKCkubGVuZ3RoIC0gMSkpLCB0aGlzLm1pbiA9IHMsIHRoaXMubWF4ID0gbjtcbiAgfVxuICBidWlsZFRpY2tzKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLm1pbiwgZSA9IHRoaXMubWF4LCBzID0gdGhpcy5vcHRpb25zLm9mZnNldCwgbiA9IFtdO1xuICAgIGxldCBvID0gdGhpcy5nZXRMYWJlbHMoKTtcbiAgICBvID0gdCA9PT0gMCAmJiBlID09PSBvLmxlbmd0aCAtIDEgPyBvIDogby5zbGljZSh0LCBlICsgMSksIHRoaXMuX3ZhbHVlUmFuZ2UgPSBNYXRoLm1heChvLmxlbmd0aCAtIChzID8gMCA6IDEpLCAxKSwgdGhpcy5fc3RhcnRWYWx1ZSA9IHRoaXMubWluIC0gKHMgPyAwLjUgOiAwKTtcbiAgICBmb3IgKGxldCByID0gdDsgciA8PSBlOyByKyspXG4gICAgICBuLnB1c2goeyB2YWx1ZTogciB9KTtcbiAgICByZXR1cm4gbjtcbiAgfVxuICBnZXRMYWJlbEZvclZhbHVlKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5nZXRMYWJlbHMoKTtcbiAgICByZXR1cm4gdCA+PSAwICYmIHQgPCBlLmxlbmd0aCA/IGVbdF0gOiB0O1xuICB9XG4gIGNvbmZpZ3VyZSgpIHtcbiAgICBzdXBlci5jb25maWd1cmUoKSwgdGhpcy5pc0hvcml6b250YWwoKSB8fCAodGhpcy5fcmV2ZXJzZVBpeGVscyA9ICF0aGlzLl9yZXZlcnNlUGl4ZWxzKTtcbiAgfVxuICBnZXRQaXhlbEZvclZhbHVlKHQpIHtcbiAgICByZXR1cm4gdHlwZW9mIHQgIT0gXCJudW1iZXJcIiAmJiAodCA9IHRoaXMucGFyc2UodCkpLCB0ID09PSBudWxsID8gTmFOIDogdGhpcy5nZXRQaXhlbEZvckRlY2ltYWwoKHQgLSB0aGlzLl9zdGFydFZhbHVlKSAvIHRoaXMuX3ZhbHVlUmFuZ2UpO1xuICB9XG4gIGdldFBpeGVsRm9yVGljayh0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMudGlja3M7XG4gICAgcmV0dXJuIHQgPCAwIHx8IHQgPiBlLmxlbmd0aCAtIDEgPyBudWxsIDogdGhpcy5nZXRQaXhlbEZvclZhbHVlKGVbdF0udmFsdWUpO1xuICB9XG4gIGdldFZhbHVlRm9yUGl4ZWwodCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKHRoaXMuX3N0YXJ0VmFsdWUgKyB0aGlzLmdldERlY2ltYWxGb3JQaXhlbCh0KSAqIHRoaXMuX3ZhbHVlUmFuZ2UpO1xuICB9XG4gIGdldEJhc2VQaXhlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5ib3R0b207XG4gIH1cbn1cbmNlLmlkID0gXCJjYXRlZ29yeVwiO1xuY2UuZGVmYXVsdHMgPSB7XG4gIHRpY2tzOiB7XG4gICAgY2FsbGJhY2s6IGNlLnByb3RvdHlwZS5nZXRMYWJlbEZvclZhbHVlXG4gIH1cbn07XG5mdW5jdGlvbiBEYyhpLCB0KSB7XG4gIGNvbnN0IGUgPSBbXSwgeyBib3VuZHM6IG4sIHN0ZXA6IG8sIG1pbjogciwgbWF4OiBhLCBwcmVjaXNpb246IGwsIGNvdW50OiBjLCBtYXhUaWNrczogaCwgbWF4RGlnaXRzOiBkLCBpbmNsdWRlQm91bmRzOiB1IH0gPSBpLCBmID0gbyB8fCAxLCBnID0gaCAtIDEsIHsgbWluOiBwLCBtYXg6IG0gfSA9IHQsIGIgPSAhVChyKSwgeCA9ICFUKGEpLCB2ID0gIVQoYyksIHkgPSAobSAtIHApIC8gKGQgKyAxKTtcbiAgbGV0IF8gPSBxaSgobSAtIHApIC8gZyAvIGYpICogZiwgTSwgaywgUywgdztcbiAgaWYgKF8gPCAxZS0xNCAmJiAhYiAmJiAheClcbiAgICByZXR1cm4gW3sgdmFsdWU6IHAgfSwgeyB2YWx1ZTogbSB9XTtcbiAgdyA9IE1hdGguY2VpbChtIC8gXykgLSBNYXRoLmZsb29yKHAgLyBfKSwgdyA+IGcgJiYgKF8gPSBxaSh3ICogXyAvIGcgLyBmKSAqIGYpLCBUKGwpIHx8IChNID0gTWF0aC5wb3coMTAsIGwpLCBfID0gTWF0aC5jZWlsKF8gKiBNKSAvIE0pLCBuID09PSBcInRpY2tzXCIgPyAoayA9IE1hdGguZmxvb3IocCAvIF8pICogXywgUyA9IE1hdGguY2VpbChtIC8gXykgKiBfKSA6IChrID0gcCwgUyA9IG0pLCBiICYmIHggJiYgbyAmJiBPbygoYSAtIHIpIC8gbywgXyAvIDFlMykgPyAodyA9IE1hdGgucm91bmQoTWF0aC5taW4oKGEgLSByKSAvIF8sIGgpKSwgXyA9IChhIC0gcikgLyB3LCBrID0gciwgUyA9IGEpIDogdiA/IChrID0gYiA/IHIgOiBrLCBTID0geCA/IGEgOiBTLCB3ID0gYyAtIDEsIF8gPSAoUyAtIGspIC8gdykgOiAodyA9IChTIC0gaykgLyBfLCB0ZSh3LCBNYXRoLnJvdW5kKHcpLCBfIC8gMWUzKSA/IHcgPSBNYXRoLnJvdW5kKHcpIDogdyA9IE1hdGguY2VpbCh3KSk7XG4gIGNvbnN0IEwgPSBNYXRoLm1heChcbiAgICBHaShfKSxcbiAgICBHaShrKVxuICApO1xuICBNID0gTWF0aC5wb3coMTAsIFQobCkgPyBMIDogbCksIGsgPSBNYXRoLnJvdW5kKGsgKiBNKSAvIE0sIFMgPSBNYXRoLnJvdW5kKFMgKiBNKSAvIE07XG4gIGxldCBSID0gMDtcbiAgZm9yIChiICYmICh1ICYmIGsgIT09IHIgPyAoZS5wdXNoKHsgdmFsdWU6IHIgfSksIGsgPCByICYmIFIrKywgdGUoTWF0aC5yb3VuZCgoayArIFIgKiBfKSAqIE0pIC8gTSwgciwgUXMociwgeSwgaSkpICYmIFIrKykgOiBrIDwgciAmJiBSKyspOyBSIDwgdzsgKytSKVxuICAgIGUucHVzaCh7IHZhbHVlOiBNYXRoLnJvdW5kKChrICsgUiAqIF8pICogTSkgLyBNIH0pO1xuICByZXR1cm4geCAmJiB1ICYmIFMgIT09IGEgPyBlLmxlbmd0aCAmJiB0ZShlW2UubGVuZ3RoIC0gMV0udmFsdWUsIGEsIFFzKGEsIHksIGkpKSA/IGVbZS5sZW5ndGggLSAxXS52YWx1ZSA9IGEgOiBlLnB1c2goeyB2YWx1ZTogYSB9KSA6ICgheCB8fCBTID09PSBhKSAmJiBlLnB1c2goeyB2YWx1ZTogUyB9KSwgZTtcbn1cbmZ1bmN0aW9uIFFzKGksIHQsIHsgaG9yaXpvbnRhbDogZSwgbWluUm90YXRpb246IHMgfSkge1xuICBjb25zdCBuID0gbnQocyksIG8gPSAoZSA/IE1hdGguc2luKG4pIDogTWF0aC5jb3MobikpIHx8IDFlLTMsIHIgPSAwLjc1ICogdCAqIChcIlwiICsgaSkubGVuZ3RoO1xuICByZXR1cm4gTWF0aC5taW4odCAvIG8sIHIpO1xufVxuY2xhc3MgWWUgZXh0ZW5kcyBNdCB7XG4gIGNvbnN0cnVjdG9yKHQpIHtcbiAgICBzdXBlcih0KSwgdGhpcy5zdGFydCA9IHZvaWQgMCwgdGhpcy5lbmQgPSB2b2lkIDAsIHRoaXMuX3N0YXJ0VmFsdWUgPSB2b2lkIDAsIHRoaXMuX2VuZFZhbHVlID0gdm9pZCAwLCB0aGlzLl92YWx1ZVJhbmdlID0gMDtcbiAgfVxuICBwYXJzZSh0LCBlKSB7XG4gICAgcmV0dXJuIFQodCkgfHwgKHR5cGVvZiB0ID09IFwibnVtYmVyXCIgfHwgdCBpbnN0YW5jZW9mIE51bWJlcikgJiYgIWlzRmluaXRlKCt0KSA/IG51bGwgOiArdDtcbiAgfVxuICBoYW5kbGVUaWNrUmFuZ2VPcHRpb25zKCkge1xuICAgIGNvbnN0IHsgYmVnaW5BdFplcm86IHQgfSA9IHRoaXMub3B0aW9ucywgeyBtaW5EZWZpbmVkOiBlLCBtYXhEZWZpbmVkOiBzIH0gPSB0aGlzLmdldFVzZXJCb3VuZHMoKTtcbiAgICBsZXQgeyBtaW46IG4sIG1heDogbyB9ID0gdGhpcztcbiAgICBjb25zdCByID0gKGwpID0+IG4gPSBlID8gbiA6IGwsIGEgPSAobCkgPT4gbyA9IHMgPyBvIDogbDtcbiAgICBpZiAodCkge1xuICAgICAgY29uc3QgbCA9IGx0KG4pLCBjID0gbHQobyk7XG4gICAgICBsIDwgMCAmJiBjIDwgMCA/IGEoMCkgOiBsID4gMCAmJiBjID4gMCAmJiByKDApO1xuICAgIH1cbiAgICBpZiAobiA9PT0gbykge1xuICAgICAgbGV0IGwgPSAxO1xuICAgICAgKG8gPj0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfHwgbiA8PSBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUikgJiYgKGwgPSBNYXRoLmFicyhvICogMC4wNSkpLCBhKG8gKyBsKSwgdCB8fCByKG4gLSBsKTtcbiAgICB9XG4gICAgdGhpcy5taW4gPSBuLCB0aGlzLm1heCA9IG87XG4gIH1cbiAgZ2V0VGlja0xpbWl0KCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLm9wdGlvbnMudGlja3M7XG4gICAgbGV0IHsgbWF4VGlja3NMaW1pdDogZSwgc3RlcFNpemU6IHMgfSA9IHQsIG47XG4gICAgcmV0dXJuIHMgPyAobiA9IE1hdGguY2VpbCh0aGlzLm1heCAvIHMpIC0gTWF0aC5mbG9vcih0aGlzLm1pbiAvIHMpICsgMSwgbiA+IDFlMyAmJiAoY29uc29sZS53YXJuKGBzY2FsZXMuJHt0aGlzLmlkfS50aWNrcy5zdGVwU2l6ZTogJHtzfSB3b3VsZCByZXN1bHQgZ2VuZXJhdGluZyB1cCB0byAke259IHRpY2tzLiBMaW1pdGluZyB0byAxMDAwLmApLCBuID0gMWUzKSkgOiAobiA9IHRoaXMuY29tcHV0ZVRpY2tMaW1pdCgpLCBlID0gZSB8fCAxMSksIGUgJiYgKG4gPSBNYXRoLm1pbihlLCBuKSksIG47XG4gIH1cbiAgY29tcHV0ZVRpY2tMaW1pdCgpIHtcbiAgICByZXR1cm4gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICB9XG4gIGJ1aWxkVGlja3MoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMub3B0aW9ucywgZSA9IHQudGlja3M7XG4gICAgbGV0IHMgPSB0aGlzLmdldFRpY2tMaW1pdCgpO1xuICAgIHMgPSBNYXRoLm1heCgyLCBzKTtcbiAgICBjb25zdCBuID0ge1xuICAgICAgbWF4VGlja3M6IHMsXG4gICAgICBib3VuZHM6IHQuYm91bmRzLFxuICAgICAgbWluOiB0Lm1pbixcbiAgICAgIG1heDogdC5tYXgsXG4gICAgICBwcmVjaXNpb246IGUucHJlY2lzaW9uLFxuICAgICAgc3RlcDogZS5zdGVwU2l6ZSxcbiAgICAgIGNvdW50OiBlLmNvdW50LFxuICAgICAgbWF4RGlnaXRzOiB0aGlzLl9tYXhEaWdpdHMoKSxcbiAgICAgIGhvcml6b250YWw6IHRoaXMuaXNIb3Jpem9udGFsKCksXG4gICAgICBtaW5Sb3RhdGlvbjogZS5taW5Sb3RhdGlvbiB8fCAwLFxuICAgICAgaW5jbHVkZUJvdW5kczogZS5pbmNsdWRlQm91bmRzICE9PSAhMVxuICAgIH0sIG8gPSB0aGlzLl9yYW5nZSB8fCB0aGlzLCByID0gRGMobiwgbyk7XG4gICAgcmV0dXJuIHQuYm91bmRzID09PSBcInRpY2tzXCIgJiYgY24ociwgdGhpcywgXCJ2YWx1ZVwiKSwgdC5yZXZlcnNlID8gKHIucmV2ZXJzZSgpLCB0aGlzLnN0YXJ0ID0gdGhpcy5tYXgsIHRoaXMuZW5kID0gdGhpcy5taW4pIDogKHRoaXMuc3RhcnQgPSB0aGlzLm1pbiwgdGhpcy5lbmQgPSB0aGlzLm1heCksIHI7XG4gIH1cbiAgY29uZmlndXJlKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLnRpY2tzO1xuICAgIGxldCBlID0gdGhpcy5taW4sIHMgPSB0aGlzLm1heDtcbiAgICBpZiAoc3VwZXIuY29uZmlndXJlKCksIHRoaXMub3B0aW9ucy5vZmZzZXQgJiYgdC5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IG4gPSAocyAtIGUpIC8gTWF0aC5tYXgodC5sZW5ndGggLSAxLCAxKSAvIDI7XG4gICAgICBlIC09IG4sIHMgKz0gbjtcbiAgICB9XG4gICAgdGhpcy5fc3RhcnRWYWx1ZSA9IGUsIHRoaXMuX2VuZFZhbHVlID0gcywgdGhpcy5fdmFsdWVSYW5nZSA9IHMgLSBlO1xuICB9XG4gIGdldExhYmVsRm9yVmFsdWUodCkge1xuICAgIHJldHVybiBkZSh0LCB0aGlzLmNoYXJ0Lm9wdGlvbnMubG9jYWxlLCB0aGlzLm9wdGlvbnMudGlja3MuZm9ybWF0KTtcbiAgfVxufVxuY2xhc3MgR2UgZXh0ZW5kcyBZZSB7XG4gIGRldGVybWluZURhdGFMaW1pdHMoKSB7XG4gICAgY29uc3QgeyBtaW46IHQsIG1heDogZSB9ID0gdGhpcy5nZXRNaW5NYXgoITApO1xuICAgIHRoaXMubWluID0gTih0KSA/IHQgOiAwLCB0aGlzLm1heCA9IE4oZSkgPyBlIDogMSwgdGhpcy5oYW5kbGVUaWNrUmFuZ2VPcHRpb25zKCk7XG4gIH1cbiAgY29tcHV0ZVRpY2tMaW1pdCgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5pc0hvcml6b250YWwoKSwgZSA9IHQgPyB0aGlzLndpZHRoIDogdGhpcy5oZWlnaHQsIHMgPSBudCh0aGlzLm9wdGlvbnMudGlja3MubWluUm90YXRpb24pLCBuID0gKHQgPyBNYXRoLnNpbihzKSA6IE1hdGguY29zKHMpKSB8fCAxZS0zLCBvID0gdGhpcy5fcmVzb2x2ZVRpY2tGb250T3B0aW9ucygwKTtcbiAgICByZXR1cm4gTWF0aC5jZWlsKGUgLyBNYXRoLm1pbig0MCwgby5saW5lSGVpZ2h0IC8gbikpO1xuICB9XG4gIGdldFBpeGVsRm9yVmFsdWUodCkge1xuICAgIHJldHVybiB0ID09PSBudWxsID8gTmFOIDogdGhpcy5nZXRQaXhlbEZvckRlY2ltYWwoKHQgLSB0aGlzLl9zdGFydFZhbHVlKSAvIHRoaXMuX3ZhbHVlUmFuZ2UpO1xuICB9XG4gIGdldFZhbHVlRm9yUGl4ZWwodCkge1xuICAgIHJldHVybiB0aGlzLl9zdGFydFZhbHVlICsgdGhpcy5nZXREZWNpbWFsRm9yUGl4ZWwodCkgKiB0aGlzLl92YWx1ZVJhbmdlO1xuICB9XG59XG5HZS5pZCA9IFwibGluZWFyXCI7XG5HZS5kZWZhdWx0cyA9IHtcbiAgdGlja3M6IHtcbiAgICBjYWxsYmFjazogYmUuZm9ybWF0dGVycy5udW1lcmljXG4gIH1cbn07XG5mdW5jdGlvbiB0bihpKSB7XG4gIHJldHVybiBpIC8gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IodHQoaSkpKSA9PT0gMTtcbn1cbmZ1bmN0aW9uIE9jKGksIHQpIHtcbiAgY29uc3QgZSA9IE1hdGguZmxvb3IodHQodC5tYXgpKSwgcyA9IE1hdGguY2VpbCh0Lm1heCAvIE1hdGgucG93KDEwLCBlKSksIG4gPSBbXTtcbiAgbGV0IG8gPSBRKGkubWluLCBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcih0dCh0Lm1pbikpKSksIHIgPSBNYXRoLmZsb29yKHR0KG8pKSwgYSA9IE1hdGguZmxvb3IobyAvIE1hdGgucG93KDEwLCByKSksIGwgPSByIDwgMCA/IE1hdGgucG93KDEwLCBNYXRoLmFicyhyKSkgOiAxO1xuICBkb1xuICAgIG4ucHVzaCh7IHZhbHVlOiBvLCBtYWpvcjogdG4obykgfSksICsrYSwgYSA9PT0gMTAgJiYgKGEgPSAxLCArK3IsIGwgPSByID49IDAgPyAxIDogbCksIG8gPSBNYXRoLnJvdW5kKGEgKiBNYXRoLnBvdygxMCwgcikgKiBsKSAvIGw7XG4gIHdoaWxlIChyIDwgZSB8fCByID09PSBlICYmIGEgPCBzKTtcbiAgY29uc3QgYyA9IFEoaS5tYXgsIG8pO1xuICByZXR1cm4gbi5wdXNoKHsgdmFsdWU6IGMsIG1ham9yOiB0bihvKSB9KSwgbjtcbn1cbmNsYXNzIFplIGV4dGVuZHMgTXQge1xuICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgc3VwZXIodCksIHRoaXMuc3RhcnQgPSB2b2lkIDAsIHRoaXMuZW5kID0gdm9pZCAwLCB0aGlzLl9zdGFydFZhbHVlID0gdm9pZCAwLCB0aGlzLl92YWx1ZVJhbmdlID0gMDtcbiAgfVxuICBwYXJzZSh0LCBlKSB7XG4gICAgY29uc3QgcyA9IFllLnByb3RvdHlwZS5wYXJzZS5hcHBseSh0aGlzLCBbdCwgZV0pO1xuICAgIGlmIChzID09PSAwKSB7XG4gICAgICB0aGlzLl96ZXJvID0gITA7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBOKHMpICYmIHMgPiAwID8gcyA6IG51bGw7XG4gIH1cbiAgZGV0ZXJtaW5lRGF0YUxpbWl0cygpIHtcbiAgICBjb25zdCB7IG1pbjogdCwgbWF4OiBlIH0gPSB0aGlzLmdldE1pbk1heCghMCk7XG4gICAgdGhpcy5taW4gPSBOKHQpID8gTWF0aC5tYXgoMCwgdCkgOiBudWxsLCB0aGlzLm1heCA9IE4oZSkgPyBNYXRoLm1heCgwLCBlKSA6IG51bGwsIHRoaXMub3B0aW9ucy5iZWdpbkF0WmVybyAmJiAodGhpcy5femVybyA9ICEwKSwgdGhpcy5oYW5kbGVUaWNrUmFuZ2VPcHRpb25zKCk7XG4gIH1cbiAgaGFuZGxlVGlja1JhbmdlT3B0aW9ucygpIHtcbiAgICBjb25zdCB7IG1pbkRlZmluZWQ6IHQsIG1heERlZmluZWQ6IGUgfSA9IHRoaXMuZ2V0VXNlckJvdW5kcygpO1xuICAgIGxldCBzID0gdGhpcy5taW4sIG4gPSB0aGlzLm1heDtcbiAgICBjb25zdCBvID0gKGwpID0+IHMgPSB0ID8gcyA6IGwsIHIgPSAobCkgPT4gbiA9IGUgPyBuIDogbCwgYSA9IChsLCBjKSA9PiBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcih0dChsKSkgKyBjKTtcbiAgICBzID09PSBuICYmIChzIDw9IDAgPyAobygxKSwgcigxMCkpIDogKG8oYShzLCAtMSkpLCByKGEobiwgMSkpKSksIHMgPD0gMCAmJiBvKGEobiwgLTEpKSwgbiA8PSAwICYmIHIoYShzLCAxKSksIHRoaXMuX3plcm8gJiYgdGhpcy5taW4gIT09IHRoaXMuX3N1Z2dlc3RlZE1pbiAmJiBzID09PSBhKHRoaXMubWluLCAwKSAmJiBvKGEocywgLTEpKSwgdGhpcy5taW4gPSBzLCB0aGlzLm1heCA9IG47XG4gIH1cbiAgYnVpbGRUaWNrcygpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5vcHRpb25zLCBlID0ge1xuICAgICAgbWluOiB0aGlzLl91c2VyTWluLFxuICAgICAgbWF4OiB0aGlzLl91c2VyTWF4XG4gICAgfSwgcyA9IE9jKGUsIHRoaXMpO1xuICAgIHJldHVybiB0LmJvdW5kcyA9PT0gXCJ0aWNrc1wiICYmIGNuKHMsIHRoaXMsIFwidmFsdWVcIiksIHQucmV2ZXJzZSA/IChzLnJldmVyc2UoKSwgdGhpcy5zdGFydCA9IHRoaXMubWF4LCB0aGlzLmVuZCA9IHRoaXMubWluKSA6ICh0aGlzLnN0YXJ0ID0gdGhpcy5taW4sIHRoaXMuZW5kID0gdGhpcy5tYXgpLCBzO1xuICB9XG4gIGdldExhYmVsRm9yVmFsdWUodCkge1xuICAgIHJldHVybiB0ID09PSB2b2lkIDAgPyBcIjBcIiA6IGRlKHQsIHRoaXMuY2hhcnQub3B0aW9ucy5sb2NhbGUsIHRoaXMub3B0aW9ucy50aWNrcy5mb3JtYXQpO1xuICB9XG4gIGNvbmZpZ3VyZSgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5taW47XG4gICAgc3VwZXIuY29uZmlndXJlKCksIHRoaXMuX3N0YXJ0VmFsdWUgPSB0dCh0KSwgdGhpcy5fdmFsdWVSYW5nZSA9IHR0KHRoaXMubWF4KSAtIHR0KHQpO1xuICB9XG4gIGdldFBpeGVsRm9yVmFsdWUodCkge1xuICAgIHJldHVybiAodCA9PT0gdm9pZCAwIHx8IHQgPT09IDApICYmICh0ID0gdGhpcy5taW4pLCB0ID09PSBudWxsIHx8IGlzTmFOKHQpID8gTmFOIDogdGhpcy5nZXRQaXhlbEZvckRlY2ltYWwodCA9PT0gdGhpcy5taW4gPyAwIDogKHR0KHQpIC0gdGhpcy5fc3RhcnRWYWx1ZSkgLyB0aGlzLl92YWx1ZVJhbmdlKTtcbiAgfVxuICBnZXRWYWx1ZUZvclBpeGVsKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5nZXREZWNpbWFsRm9yUGl4ZWwodCk7XG4gICAgcmV0dXJuIE1hdGgucG93KDEwLCB0aGlzLl9zdGFydFZhbHVlICsgZSAqIHRoaXMuX3ZhbHVlUmFuZ2UpO1xuICB9XG59XG5aZS5pZCA9IFwibG9nYXJpdGhtaWNcIjtcblplLmRlZmF1bHRzID0ge1xuICB0aWNrczoge1xuICAgIGNhbGxiYWNrOiBiZS5mb3JtYXR0ZXJzLmxvZ2FyaXRobWljLFxuICAgIG1ham9yOiB7XG4gICAgICBlbmFibGVkOiAhMFxuICAgIH1cbiAgfVxufTtcbmZ1bmN0aW9uIERpKGkpIHtcbiAgY29uc3QgdCA9IGkudGlja3M7XG4gIGlmICh0LmRpc3BsYXkgJiYgaS5kaXNwbGF5KSB7XG4gICAgY29uc3QgZSA9IEsodC5iYWNrZHJvcFBhZGRpbmcpO1xuICAgIHJldHVybiBDKHQuZm9udCAmJiB0LmZvbnQuc2l6ZSwgTy5mb250LnNpemUpICsgZS5oZWlnaHQ7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBBYyhpLCB0LCBlKSB7XG4gIHJldHVybiBlID0geihlKSA/IGUgOiBbZV0sIHtcbiAgICB3OiBhcihpLCB0LnN0cmluZywgZSksXG4gICAgaDogZS5sZW5ndGggKiB0LmxpbmVIZWlnaHRcbiAgfTtcbn1cbmZ1bmN0aW9uIGVuKGksIHQsIGUsIHMsIG4pIHtcbiAgcmV0dXJuIGkgPT09IHMgfHwgaSA9PT0gbiA/IHtcbiAgICBzdGFydDogdCAtIGUgLyAyLFxuICAgIGVuZDogdCArIGUgLyAyXG4gIH0gOiBpIDwgcyB8fCBpID4gbiA/IHtcbiAgICBzdGFydDogdCAtIGUsXG4gICAgZW5kOiB0XG4gIH0gOiB7XG4gICAgc3RhcnQ6IHQsXG4gICAgZW5kOiB0ICsgZVxuICB9O1xufVxuZnVuY3Rpb24gVGMoaSkge1xuICBjb25zdCB0ID0ge1xuICAgIGw6IGkubGVmdCArIGkuX3BhZGRpbmcubGVmdCxcbiAgICByOiBpLnJpZ2h0IC0gaS5fcGFkZGluZy5yaWdodCxcbiAgICB0OiBpLnRvcCArIGkuX3BhZGRpbmcudG9wLFxuICAgIGI6IGkuYm90dG9tIC0gaS5fcGFkZGluZy5ib3R0b21cbiAgfSwgZSA9IE9iamVjdC5hc3NpZ24oe30sIHQpLCBzID0gW10sIG4gPSBbXSwgbyA9IGkuX3BvaW50TGFiZWxzLmxlbmd0aCwgciA9IGkub3B0aW9ucy5wb2ludExhYmVscywgYSA9IHIuY2VudGVyUG9pbnRMYWJlbHMgPyBCIC8gbyA6IDA7XG4gIGZvciAobGV0IGwgPSAwOyBsIDwgbzsgbCsrKSB7XG4gICAgY29uc3QgYyA9IHIuc2V0Q29udGV4dChpLmdldFBvaW50TGFiZWxDb250ZXh0KGwpKTtcbiAgICBuW2xdID0gYy5wYWRkaW5nO1xuICAgIGNvbnN0IGggPSBpLmdldFBvaW50UG9zaXRpb24obCwgaS5kcmF3aW5nQXJlYSArIG5bbF0sIGEpLCBkID0gJChjLmZvbnQpLCB1ID0gQWMoaS5jdHgsIGQsIGkuX3BvaW50TGFiZWxzW2xdKTtcbiAgICBzW2xdID0gdTtcbiAgICBjb25zdCBmID0gWihpLmdldEluZGV4QW5nbGUobCkgKyBhKSwgZyA9IE1hdGgucm91bmQoQWkoZikpLCBwID0gZW4oZywgaC54LCB1LncsIDAsIDE4MCksIG0gPSBlbihnLCBoLnksIHUuaCwgOTAsIDI3MCk7XG4gICAgTGMoZSwgdCwgZiwgcCwgbSk7XG4gIH1cbiAgaS5zZXRDZW50ZXJQb2ludChcbiAgICB0LmwgLSBlLmwsXG4gICAgZS5yIC0gdC5yLFxuICAgIHQudCAtIGUudCxcbiAgICBlLmIgLSB0LmJcbiAgKSwgaS5fcG9pbnRMYWJlbEl0ZW1zID0gUmMoaSwgcywgbik7XG59XG5mdW5jdGlvbiBMYyhpLCB0LCBlLCBzLCBuKSB7XG4gIGNvbnN0IG8gPSBNYXRoLmFicyhNYXRoLnNpbihlKSksIHIgPSBNYXRoLmFicyhNYXRoLmNvcyhlKSk7XG4gIGxldCBhID0gMCwgbCA9IDA7XG4gIHMuc3RhcnQgPCB0LmwgPyAoYSA9ICh0LmwgLSBzLnN0YXJ0KSAvIG8sIGkubCA9IE1hdGgubWluKGkubCwgdC5sIC0gYSkpIDogcy5lbmQgPiB0LnIgJiYgKGEgPSAocy5lbmQgLSB0LnIpIC8gbywgaS5yID0gTWF0aC5tYXgoaS5yLCB0LnIgKyBhKSksIG4uc3RhcnQgPCB0LnQgPyAobCA9ICh0LnQgLSBuLnN0YXJ0KSAvIHIsIGkudCA9IE1hdGgubWluKGkudCwgdC50IC0gbCkpIDogbi5lbmQgPiB0LmIgJiYgKGwgPSAobi5lbmQgLSB0LmIpIC8gciwgaS5iID0gTWF0aC5tYXgoaS5iLCB0LmIgKyBsKSk7XG59XG5mdW5jdGlvbiBSYyhpLCB0LCBlKSB7XG4gIGNvbnN0IHMgPSBbXSwgbiA9IGkuX3BvaW50TGFiZWxzLmxlbmd0aCwgbyA9IGkub3B0aW9ucywgciA9IERpKG8pIC8gMiwgYSA9IGkuZHJhd2luZ0FyZWEsIGwgPSBvLnBvaW50TGFiZWxzLmNlbnRlclBvaW50TGFiZWxzID8gQiAvIG4gOiAwO1xuICBmb3IgKGxldCBjID0gMDsgYyA8IG47IGMrKykge1xuICAgIGNvbnN0IGggPSBpLmdldFBvaW50UG9zaXRpb24oYywgYSArIHIgKyBlW2NdLCBsKSwgZCA9IE1hdGgucm91bmQoQWkoWihoLmFuZ2xlICsgVikpKSwgdSA9IHRbY10sIGYgPSBJYyhoLnksIHUuaCwgZCksIGcgPSBFYyhkKSwgcCA9IEZjKGgueCwgdS53LCBnKTtcbiAgICBzLnB1c2goe1xuICAgICAgeDogaC54LFxuICAgICAgeTogZixcbiAgICAgIHRleHRBbGlnbjogZyxcbiAgICAgIGxlZnQ6IHAsXG4gICAgICB0b3A6IGYsXG4gICAgICByaWdodDogcCArIHUudyxcbiAgICAgIGJvdHRvbTogZiArIHUuaFxuICAgIH0pO1xuICB9XG4gIHJldHVybiBzO1xufVxuZnVuY3Rpb24gRWMoaSkge1xuICByZXR1cm4gaSA9PT0gMCB8fCBpID09PSAxODAgPyBcImNlbnRlclwiIDogaSA8IDE4MCA/IFwibGVmdFwiIDogXCJyaWdodFwiO1xufVxuZnVuY3Rpb24gRmMoaSwgdCwgZSkge1xuICByZXR1cm4gZSA9PT0gXCJyaWdodFwiID8gaSAtPSB0IDogZSA9PT0gXCJjZW50ZXJcIiAmJiAoaSAtPSB0IC8gMiksIGk7XG59XG5mdW5jdGlvbiBJYyhpLCB0LCBlKSB7XG4gIHJldHVybiBlID09PSA5MCB8fCBlID09PSAyNzAgPyBpIC09IHQgLyAyIDogKGUgPiAyNzAgfHwgZSA8IDkwKSAmJiAoaSAtPSB0KSwgaTtcbn1cbmZ1bmN0aW9uIHpjKGksIHQpIHtcbiAgY29uc3QgeyBjdHg6IGUsIG9wdGlvbnM6IHsgcG9pbnRMYWJlbHM6IHMgfSB9ID0gaTtcbiAgZm9yIChsZXQgbiA9IHQgLSAxOyBuID49IDA7IG4tLSkge1xuICAgIGNvbnN0IG8gPSBzLnNldENvbnRleHQoaS5nZXRQb2ludExhYmVsQ29udGV4dChuKSksIHIgPSAkKG8uZm9udCksIHsgeDogYSwgeTogbCwgdGV4dEFsaWduOiBjLCBsZWZ0OiBoLCB0b3A6IGQsIHJpZ2h0OiB1LCBib3R0b206IGYgfSA9IGkuX3BvaW50TGFiZWxJdGVtc1tuXSwgeyBiYWNrZHJvcENvbG9yOiBnIH0gPSBvO1xuICAgIGlmICghVChnKSkge1xuICAgICAgY29uc3QgcCA9IER0KG8uYm9yZGVyUmFkaXVzKSwgbSA9IEsoby5iYWNrZHJvcFBhZGRpbmcpO1xuICAgICAgZS5maWxsU3R5bGUgPSBnO1xuICAgICAgY29uc3QgYiA9IGggLSBtLmxlZnQsIHggPSBkIC0gbS50b3AsIHYgPSB1IC0gaCArIG0ud2lkdGgsIHkgPSBmIC0gZCArIG0uaGVpZ2h0O1xuICAgICAgT2JqZWN0LnZhbHVlcyhwKS5zb21lKChfKSA9PiBfICE9PSAwKSA/IChlLmJlZ2luUGF0aCgpLCBhZShlLCB7XG4gICAgICAgIHg6IGIsXG4gICAgICAgIHk6IHgsXG4gICAgICAgIHc6IHYsXG4gICAgICAgIGg6IHksXG4gICAgICAgIHJhZGl1czogcFxuICAgICAgfSksIGUuZmlsbCgpKSA6IGUuZmlsbFJlY3QoYiwgeCwgdiwgeSk7XG4gICAgfVxuICAgIFR0KFxuICAgICAgZSxcbiAgICAgIGkuX3BvaW50TGFiZWxzW25dLFxuICAgICAgYSxcbiAgICAgIGwgKyByLmxpbmVIZWlnaHQgLyAyLFxuICAgICAgcixcbiAgICAgIHtcbiAgICAgICAgY29sb3I6IG8uY29sb3IsXG4gICAgICAgIHRleHRBbGlnbjogYyxcbiAgICAgICAgdGV4dEJhc2VsaW5lOiBcIm1pZGRsZVwiXG4gICAgICB9XG4gICAgKTtcbiAgfVxufVxuZnVuY3Rpb24gYm8oaSwgdCwgZSwgcykge1xuICBjb25zdCB7IGN0eDogbiB9ID0gaTtcbiAgaWYgKGUpXG4gICAgbi5hcmMoaS54Q2VudGVyLCBpLnlDZW50ZXIsIHQsIDAsIEYpO1xuICBlbHNlIHtcbiAgICBsZXQgbyA9IGkuZ2V0UG9pbnRQb3NpdGlvbigwLCB0KTtcbiAgICBuLm1vdmVUbyhvLngsIG8ueSk7XG4gICAgZm9yIChsZXQgciA9IDE7IHIgPCBzOyByKyspXG4gICAgICBvID0gaS5nZXRQb2ludFBvc2l0aW9uKHIsIHQpLCBuLmxpbmVUbyhvLngsIG8ueSk7XG4gIH1cbn1cbmZ1bmN0aW9uIEJjKGksIHQsIGUsIHMpIHtcbiAgY29uc3QgbiA9IGkuY3R4LCBvID0gdC5jaXJjdWxhciwgeyBjb2xvcjogciwgbGluZVdpZHRoOiBhIH0gPSB0O1xuICAhbyAmJiAhcyB8fCAhciB8fCAhYSB8fCBlIDwgMCB8fCAobi5zYXZlKCksIG4uc3Ryb2tlU3R5bGUgPSByLCBuLmxpbmVXaWR0aCA9IGEsIG4uc2V0TGluZURhc2godC5ib3JkZXJEYXNoKSwgbi5saW5lRGFzaE9mZnNldCA9IHQuYm9yZGVyRGFzaE9mZnNldCwgbi5iZWdpblBhdGgoKSwgYm8oaSwgZSwgbywgcyksIG4uY2xvc2VQYXRoKCksIG4uc3Ryb2tlKCksIG4ucmVzdG9yZSgpKTtcbn1cbmZ1bmN0aW9uIFZjKGksIHQsIGUpIHtcbiAgcmV0dXJuIHZ0KGksIHtcbiAgICBsYWJlbDogZSxcbiAgICBpbmRleDogdCxcbiAgICB0eXBlOiBcInBvaW50TGFiZWxcIlxuICB9KTtcbn1cbmNsYXNzIE50IGV4dGVuZHMgWWUge1xuICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgc3VwZXIodCksIHRoaXMueENlbnRlciA9IHZvaWQgMCwgdGhpcy55Q2VudGVyID0gdm9pZCAwLCB0aGlzLmRyYXdpbmdBcmVhID0gdm9pZCAwLCB0aGlzLl9wb2ludExhYmVscyA9IFtdLCB0aGlzLl9wb2ludExhYmVsSXRlbXMgPSBbXTtcbiAgfVxuICBzZXREaW1lbnNpb25zKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9wYWRkaW5nID0gSyhEaSh0aGlzLm9wdGlvbnMpIC8gMiksIGUgPSB0aGlzLndpZHRoID0gdGhpcy5tYXhXaWR0aCAtIHQud2lkdGgsIHMgPSB0aGlzLmhlaWdodCA9IHRoaXMubWF4SGVpZ2h0IC0gdC5oZWlnaHQ7XG4gICAgdGhpcy54Q2VudGVyID0gTWF0aC5mbG9vcih0aGlzLmxlZnQgKyBlIC8gMiArIHQubGVmdCksIHRoaXMueUNlbnRlciA9IE1hdGguZmxvb3IodGhpcy50b3AgKyBzIC8gMiArIHQudG9wKSwgdGhpcy5kcmF3aW5nQXJlYSA9IE1hdGguZmxvb3IoTWF0aC5taW4oZSwgcykgLyAyKTtcbiAgfVxuICBkZXRlcm1pbmVEYXRhTGltaXRzKCkge1xuICAgIGNvbnN0IHsgbWluOiB0LCBtYXg6IGUgfSA9IHRoaXMuZ2V0TWluTWF4KCExKTtcbiAgICB0aGlzLm1pbiA9IE4odCkgJiYgIWlzTmFOKHQpID8gdCA6IDAsIHRoaXMubWF4ID0gTihlKSAmJiAhaXNOYU4oZSkgPyBlIDogMCwgdGhpcy5oYW5kbGVUaWNrUmFuZ2VPcHRpb25zKCk7XG4gIH1cbiAgY29tcHV0ZVRpY2tMaW1pdCgpIHtcbiAgICByZXR1cm4gTWF0aC5jZWlsKHRoaXMuZHJhd2luZ0FyZWEgLyBEaSh0aGlzLm9wdGlvbnMpKTtcbiAgfVxuICBnZW5lcmF0ZVRpY2tMYWJlbHModCkge1xuICAgIFllLnByb3RvdHlwZS5nZW5lcmF0ZVRpY2tMYWJlbHMuY2FsbCh0aGlzLCB0KSwgdGhpcy5fcG9pbnRMYWJlbHMgPSB0aGlzLmdldExhYmVscygpLm1hcCgoZSwgcykgPT4ge1xuICAgICAgY29uc3QgbiA9IEkodGhpcy5vcHRpb25zLnBvaW50TGFiZWxzLmNhbGxiYWNrLCBbZSwgc10sIHRoaXMpO1xuICAgICAgcmV0dXJuIG4gfHwgbiA9PT0gMCA/IG4gOiBcIlwiO1xuICAgIH0pLmZpbHRlcigoZSwgcykgPT4gdGhpcy5jaGFydC5nZXREYXRhVmlzaWJpbGl0eShzKSk7XG4gIH1cbiAgZml0KCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLm9wdGlvbnM7XG4gICAgdC5kaXNwbGF5ICYmIHQucG9pbnRMYWJlbHMuZGlzcGxheSA/IFRjKHRoaXMpIDogdGhpcy5zZXRDZW50ZXJQb2ludCgwLCAwLCAwLCAwKTtcbiAgfVxuICBzZXRDZW50ZXJQb2ludCh0LCBlLCBzLCBuKSB7XG4gICAgdGhpcy54Q2VudGVyICs9IE1hdGguZmxvb3IoKHQgLSBlKSAvIDIpLCB0aGlzLnlDZW50ZXIgKz0gTWF0aC5mbG9vcigocyAtIG4pIC8gMiksIHRoaXMuZHJhd2luZ0FyZWEgLT0gTWF0aC5taW4odGhpcy5kcmF3aW5nQXJlYSAvIDIsIE1hdGgubWF4KHQsIGUsIHMsIG4pKTtcbiAgfVxuICBnZXRJbmRleEFuZ2xlKHQpIHtcbiAgICBjb25zdCBlID0gRiAvICh0aGlzLl9wb2ludExhYmVscy5sZW5ndGggfHwgMSksIHMgPSB0aGlzLm9wdGlvbnMuc3RhcnRBbmdsZSB8fCAwO1xuICAgIHJldHVybiBaKHQgKiBlICsgbnQocykpO1xuICB9XG4gIGdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKHQpIHtcbiAgICBpZiAoVCh0KSlcbiAgICAgIHJldHVybiBOYU47XG4gICAgY29uc3QgZSA9IHRoaXMuZHJhd2luZ0FyZWEgLyAodGhpcy5tYXggLSB0aGlzLm1pbik7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5yZXZlcnNlID8gKHRoaXMubWF4IC0gdCkgKiBlIDogKHQgLSB0aGlzLm1pbikgKiBlO1xuICB9XG4gIGdldFZhbHVlRm9yRGlzdGFuY2VGcm9tQ2VudGVyKHQpIHtcbiAgICBpZiAoVCh0KSlcbiAgICAgIHJldHVybiBOYU47XG4gICAgY29uc3QgZSA9IHQgLyAodGhpcy5kcmF3aW5nQXJlYSAvICh0aGlzLm1heCAtIHRoaXMubWluKSk7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5yZXZlcnNlID8gdGhpcy5tYXggLSBlIDogdGhpcy5taW4gKyBlO1xuICB9XG4gIGdldFBvaW50TGFiZWxDb250ZXh0KHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5fcG9pbnRMYWJlbHMgfHwgW107XG4gICAgaWYgKHQgPj0gMCAmJiB0IDwgZS5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHMgPSBlW3RdO1xuICAgICAgcmV0dXJuIFZjKHRoaXMuZ2V0Q29udGV4dCgpLCB0LCBzKTtcbiAgICB9XG4gIH1cbiAgZ2V0UG9pbnRQb3NpdGlvbih0LCBlLCBzID0gMCkge1xuICAgIGNvbnN0IG4gPSB0aGlzLmdldEluZGV4QW5nbGUodCkgLSBWICsgcztcbiAgICByZXR1cm4ge1xuICAgICAgeDogTWF0aC5jb3MobikgKiBlICsgdGhpcy54Q2VudGVyLFxuICAgICAgeTogTWF0aC5zaW4obikgKiBlICsgdGhpcy55Q2VudGVyLFxuICAgICAgYW5nbGU6IG5cbiAgICB9O1xuICB9XG4gIGdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZSh0LCBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UG9pbnRQb3NpdGlvbih0LCB0aGlzLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKGUpKTtcbiAgfVxuICBnZXRCYXNlUG9zaXRpb24odCkge1xuICAgIHJldHVybiB0aGlzLmdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZSh0IHx8IDAsIHRoaXMuZ2V0QmFzZVZhbHVlKCkpO1xuICB9XG4gIGdldFBvaW50TGFiZWxQb3NpdGlvbih0KSB7XG4gICAgY29uc3QgeyBsZWZ0OiBlLCB0b3A6IHMsIHJpZ2h0OiBuLCBib3R0b206IG8gfSA9IHRoaXMuX3BvaW50TGFiZWxJdGVtc1t0XTtcbiAgICByZXR1cm4ge1xuICAgICAgbGVmdDogZSxcbiAgICAgIHRvcDogcyxcbiAgICAgIHJpZ2h0OiBuLFxuICAgICAgYm90dG9tOiBvXG4gICAgfTtcbiAgfVxuICBkcmF3QmFja2dyb3VuZCgpIHtcbiAgICBjb25zdCB7IGJhY2tncm91bmRDb2xvcjogdCwgZ3JpZDogeyBjaXJjdWxhcjogZSB9IH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgaWYgKHQpIHtcbiAgICAgIGNvbnN0IHMgPSB0aGlzLmN0eDtcbiAgICAgIHMuc2F2ZSgpLCBzLmJlZ2luUGF0aCgpLCBibyh0aGlzLCB0aGlzLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKHRoaXMuX2VuZFZhbHVlKSwgZSwgdGhpcy5fcG9pbnRMYWJlbHMubGVuZ3RoKSwgcy5jbG9zZVBhdGgoKSwgcy5maWxsU3R5bGUgPSB0LCBzLmZpbGwoKSwgcy5yZXN0b3JlKCk7XG4gICAgfVxuICB9XG4gIGRyYXdHcmlkKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmN0eCwgZSA9IHRoaXMub3B0aW9ucywgeyBhbmdsZUxpbmVzOiBzLCBncmlkOiBuIH0gPSBlLCBvID0gdGhpcy5fcG9pbnRMYWJlbHMubGVuZ3RoO1xuICAgIGxldCByLCBhLCBsO1xuICAgIGlmIChlLnBvaW50TGFiZWxzLmRpc3BsYXkgJiYgemModGhpcywgbyksIG4uZGlzcGxheSAmJiB0aGlzLnRpY2tzLmZvckVhY2goKGMsIGgpID0+IHtcbiAgICAgIGlmIChoICE9PSAwKSB7XG4gICAgICAgIGEgPSB0aGlzLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKGMudmFsdWUpO1xuICAgICAgICBjb25zdCBkID0gbi5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dChoIC0gMSkpO1xuICAgICAgICBCYyh0aGlzLCBkLCBhLCBvKTtcbiAgICAgIH1cbiAgICB9KSwgcy5kaXNwbGF5KSB7XG4gICAgICBmb3IgKHQuc2F2ZSgpLCByID0gbyAtIDE7IHIgPj0gMDsgci0tKSB7XG4gICAgICAgIGNvbnN0IGMgPSBzLnNldENvbnRleHQodGhpcy5nZXRQb2ludExhYmVsQ29udGV4dChyKSksIHsgY29sb3I6IGgsIGxpbmVXaWR0aDogZCB9ID0gYztcbiAgICAgICAgIWQgfHwgIWggfHwgKHQubGluZVdpZHRoID0gZCwgdC5zdHJva2VTdHlsZSA9IGgsIHQuc2V0TGluZURhc2goYy5ib3JkZXJEYXNoKSwgdC5saW5lRGFzaE9mZnNldCA9IGMuYm9yZGVyRGFzaE9mZnNldCwgYSA9IHRoaXMuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUoZS50aWNrcy5yZXZlcnNlID8gdGhpcy5taW4gOiB0aGlzLm1heCksIGwgPSB0aGlzLmdldFBvaW50UG9zaXRpb24ociwgYSksIHQuYmVnaW5QYXRoKCksIHQubW92ZVRvKHRoaXMueENlbnRlciwgdGhpcy55Q2VudGVyKSwgdC5saW5lVG8obC54LCBsLnkpLCB0LnN0cm9rZSgpKTtcbiAgICAgIH1cbiAgICAgIHQucmVzdG9yZSgpO1xuICAgIH1cbiAgfVxuICBkcmF3Qm9yZGVyKCkge1xuICB9XG4gIGRyYXdMYWJlbHMoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuY3R4LCBlID0gdGhpcy5vcHRpb25zLCBzID0gZS50aWNrcztcbiAgICBpZiAoIXMuZGlzcGxheSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBuID0gdGhpcy5nZXRJbmRleEFuZ2xlKDApO1xuICAgIGxldCBvLCByO1xuICAgIHQuc2F2ZSgpLCB0LnRyYW5zbGF0ZSh0aGlzLnhDZW50ZXIsIHRoaXMueUNlbnRlciksIHQucm90YXRlKG4pLCB0LnRleHRBbGlnbiA9IFwiY2VudGVyXCIsIHQudGV4dEJhc2VsaW5lID0gXCJtaWRkbGVcIiwgdGhpcy50aWNrcy5mb3JFYWNoKChhLCBsKSA9PiB7XG4gICAgICBpZiAobCA9PT0gMCAmJiAhZS5yZXZlcnNlKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBjID0gcy5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dChsKSksIGggPSAkKGMuZm9udCk7XG4gICAgICBpZiAobyA9IHRoaXMuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUodGhpcy50aWNrc1tsXS52YWx1ZSksIGMuc2hvd0xhYmVsQmFja2Ryb3ApIHtcbiAgICAgICAgdC5mb250ID0gaC5zdHJpbmcsIHIgPSB0Lm1lYXN1cmVUZXh0KGEubGFiZWwpLndpZHRoLCB0LmZpbGxTdHlsZSA9IGMuYmFja2Ryb3BDb2xvcjtcbiAgICAgICAgY29uc3QgZCA9IEsoYy5iYWNrZHJvcFBhZGRpbmcpO1xuICAgICAgICB0LmZpbGxSZWN0KFxuICAgICAgICAgIC1yIC8gMiAtIGQubGVmdCxcbiAgICAgICAgICAtbyAtIGguc2l6ZSAvIDIgLSBkLnRvcCxcbiAgICAgICAgICByICsgZC53aWR0aCxcbiAgICAgICAgICBoLnNpemUgKyBkLmhlaWdodFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgVHQodCwgYS5sYWJlbCwgMCwgLW8sIGgsIHtcbiAgICAgICAgY29sb3I6IGMuY29sb3JcbiAgICAgIH0pO1xuICAgIH0pLCB0LnJlc3RvcmUoKTtcbiAgfVxuICBkcmF3VGl0bGUoKSB7XG4gIH1cbn1cbk50LmlkID0gXCJyYWRpYWxMaW5lYXJcIjtcbk50LmRlZmF1bHRzID0ge1xuICBkaXNwbGF5OiAhMCxcbiAgYW5pbWF0ZTogITAsXG4gIHBvc2l0aW9uOiBcImNoYXJ0QXJlYVwiLFxuICBhbmdsZUxpbmVzOiB7XG4gICAgZGlzcGxheTogITAsXG4gICAgbGluZVdpZHRoOiAxLFxuICAgIGJvcmRlckRhc2g6IFtdLFxuICAgIGJvcmRlckRhc2hPZmZzZXQ6IDBcbiAgfSxcbiAgZ3JpZDoge1xuICAgIGNpcmN1bGFyOiAhMVxuICB9LFxuICBzdGFydEFuZ2xlOiAwLFxuICB0aWNrczoge1xuICAgIHNob3dMYWJlbEJhY2tkcm9wOiAhMCxcbiAgICBjYWxsYmFjazogYmUuZm9ybWF0dGVycy5udW1lcmljXG4gIH0sXG4gIHBvaW50TGFiZWxzOiB7XG4gICAgYmFja2Ryb3BDb2xvcjogdm9pZCAwLFxuICAgIGJhY2tkcm9wUGFkZGluZzogMixcbiAgICBkaXNwbGF5OiAhMCxcbiAgICBmb250OiB7XG4gICAgICBzaXplOiAxMFxuICAgIH0sXG4gICAgY2FsbGJhY2soaSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfSxcbiAgICBwYWRkaW5nOiA1LFxuICAgIGNlbnRlclBvaW50TGFiZWxzOiAhMVxuICB9XG59O1xuTnQuZGVmYXVsdFJvdXRlcyA9IHtcbiAgXCJhbmdsZUxpbmVzLmNvbG9yXCI6IFwiYm9yZGVyQ29sb3JcIixcbiAgXCJwb2ludExhYmVscy5jb2xvclwiOiBcImNvbG9yXCIsXG4gIFwidGlja3MuY29sb3JcIjogXCJjb2xvclwiXG59O1xuTnQuZGVzY3JpcHRvcnMgPSB7XG4gIGFuZ2xlTGluZXM6IHtcbiAgICBfZmFsbGJhY2s6IFwiZ3JpZFwiXG4gIH1cbn07XG5jb25zdCBKZSA9IHtcbiAgbWlsbGlzZWNvbmQ6IHsgY29tbW9uOiAhMCwgc2l6ZTogMSwgc3RlcHM6IDFlMyB9LFxuICBzZWNvbmQ6IHsgY29tbW9uOiAhMCwgc2l6ZTogMWUzLCBzdGVwczogNjAgfSxcbiAgbWludXRlOiB7IGNvbW1vbjogITAsIHNpemU6IDZlNCwgc3RlcHM6IDYwIH0sXG4gIGhvdXI6IHsgY29tbW9uOiAhMCwgc2l6ZTogMzZlNSwgc3RlcHM6IDI0IH0sXG4gIGRheTogeyBjb21tb246ICEwLCBzaXplOiA4NjRlNSwgc3RlcHM6IDMwIH0sXG4gIHdlZWs6IHsgY29tbW9uOiAhMSwgc2l6ZTogNjA0OGU1LCBzdGVwczogNCB9LFxuICBtb250aDogeyBjb21tb246ICEwLCBzaXplOiAyNjI4ZTYsIHN0ZXBzOiAxMiB9LFxuICBxdWFydGVyOiB7IGNvbW1vbjogITEsIHNpemU6IDc4ODRlNiwgc3RlcHM6IDQgfSxcbiAgeWVhcjogeyBjb21tb246ICEwLCBzaXplOiAzMTU0ZTcgfVxufSwgRyA9IE9iamVjdC5rZXlzKEplKTtcbmZ1bmN0aW9uIFdjKGksIHQpIHtcbiAgcmV0dXJuIGkgLSB0O1xufVxuZnVuY3Rpb24gc24oaSwgdCkge1xuICBpZiAoVCh0KSlcbiAgICByZXR1cm4gbnVsbDtcbiAgY29uc3QgZSA9IGkuX2FkYXB0ZXIsIHsgcGFyc2VyOiBzLCByb3VuZDogbiwgaXNvV2Vla2RheTogbyB9ID0gaS5fcGFyc2VPcHRzO1xuICBsZXQgciA9IHQ7XG4gIHJldHVybiB0eXBlb2YgcyA9PSBcImZ1bmN0aW9uXCIgJiYgKHIgPSBzKHIpKSwgTihyKSB8fCAociA9IHR5cGVvZiBzID09IFwic3RyaW5nXCIgPyBlLnBhcnNlKHIsIHMpIDogZS5wYXJzZShyKSksIHIgPT09IG51bGwgPyBudWxsIDogKG4gJiYgKHIgPSBuID09PSBcIndlZWtcIiAmJiAoQnQobykgfHwgbyA9PT0gITApID8gZS5zdGFydE9mKHIsIFwiaXNvV2Vla1wiLCBvKSA6IGUuc3RhcnRPZihyLCBuKSksICtyKTtcbn1cbmZ1bmN0aW9uIG5uKGksIHQsIGUsIHMpIHtcbiAgY29uc3QgbiA9IEcubGVuZ3RoO1xuICBmb3IgKGxldCBvID0gRy5pbmRleE9mKGkpOyBvIDwgbiAtIDE7ICsrbykge1xuICAgIGNvbnN0IHIgPSBKZVtHW29dXSwgYSA9IHIuc3RlcHMgPyByLnN0ZXBzIDogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gICAgaWYgKHIuY29tbW9uICYmIE1hdGguY2VpbCgoZSAtIHQpIC8gKGEgKiByLnNpemUpKSA8PSBzKVxuICAgICAgcmV0dXJuIEdbb107XG4gIH1cbiAgcmV0dXJuIEdbbiAtIDFdO1xufVxuZnVuY3Rpb24gTmMoaSwgdCwgZSwgcywgbikge1xuICBmb3IgKGxldCBvID0gRy5sZW5ndGggLSAxOyBvID49IEcuaW5kZXhPZihlKTsgby0tKSB7XG4gICAgY29uc3QgciA9IEdbb107XG4gICAgaWYgKEplW3JdLmNvbW1vbiAmJiBpLl9hZGFwdGVyLmRpZmYobiwgcywgcikgPj0gdCAtIDEpXG4gICAgICByZXR1cm4gcjtcbiAgfVxuICByZXR1cm4gR1tlID8gRy5pbmRleE9mKGUpIDogMF07XG59XG5mdW5jdGlvbiBIYyhpKSB7XG4gIGZvciAobGV0IHQgPSBHLmluZGV4T2YoaSkgKyAxLCBlID0gRy5sZW5ndGg7IHQgPCBlOyArK3QpXG4gICAgaWYgKEplW0dbdF1dLmNvbW1vbilcbiAgICAgIHJldHVybiBHW3RdO1xufVxuZnVuY3Rpb24gb24oaSwgdCwgZSkge1xuICBpZiAoIWUpXG4gICAgaVt0XSA9ICEwO1xuICBlbHNlIGlmIChlLmxlbmd0aCkge1xuICAgIGNvbnN0IHsgbG86IHMsIGhpOiBuIH0gPSBUaShlLCB0KSwgbyA9IGVbc10gPj0gdCA/IGVbc10gOiBlW25dO1xuICAgIGlbb10gPSAhMDtcbiAgfVxufVxuZnVuY3Rpb24gamMoaSwgdCwgZSwgcykge1xuICBjb25zdCBuID0gaS5fYWRhcHRlciwgbyA9ICtuLnN0YXJ0T2YodFswXS52YWx1ZSwgcyksIHIgPSB0W3QubGVuZ3RoIC0gMV0udmFsdWU7XG4gIGxldCBhLCBsO1xuICBmb3IgKGEgPSBvOyBhIDw9IHI7IGEgPSArbi5hZGQoYSwgMSwgcykpXG4gICAgbCA9IGVbYV0sIGwgPj0gMCAmJiAodFtsXS5tYWpvciA9ICEwKTtcbiAgcmV0dXJuIHQ7XG59XG5mdW5jdGlvbiBybihpLCB0LCBlKSB7XG4gIGNvbnN0IHMgPSBbXSwgbiA9IHt9LCBvID0gdC5sZW5ndGg7XG4gIGxldCByLCBhO1xuICBmb3IgKHIgPSAwOyByIDwgbzsgKytyKVxuICAgIGEgPSB0W3JdLCBuW2FdID0gciwgcy5wdXNoKHtcbiAgICAgIHZhbHVlOiBhLFxuICAgICAgbWFqb3I6ICExXG4gICAgfSk7XG4gIHJldHVybiBvID09PSAwIHx8ICFlID8gcyA6IGpjKGksIHMsIG4sIGUpO1xufVxuY2xhc3MgSHQgZXh0ZW5kcyBNdCB7XG4gIGNvbnN0cnVjdG9yKHQpIHtcbiAgICBzdXBlcih0KSwgdGhpcy5fY2FjaGUgPSB7XG4gICAgICBkYXRhOiBbXSxcbiAgICAgIGxhYmVsczogW10sXG4gICAgICBhbGw6IFtdXG4gICAgfSwgdGhpcy5fdW5pdCA9IFwiZGF5XCIsIHRoaXMuX21ham9yVW5pdCA9IHZvaWQgMCwgdGhpcy5fb2Zmc2V0cyA9IHt9LCB0aGlzLl9ub3JtYWxpemVkID0gITEsIHRoaXMuX3BhcnNlT3B0cyA9IHZvaWQgMDtcbiAgfVxuICBpbml0KHQsIGUpIHtcbiAgICBjb25zdCBzID0gdC50aW1lIHx8ICh0LnRpbWUgPSB7fSksIG4gPSB0aGlzLl9hZGFwdGVyID0gbmV3IE5uLl9kYXRlKHQuYWRhcHRlcnMuZGF0ZSk7XG4gICAgbi5pbml0KGUpLCBRdChzLmRpc3BsYXlGb3JtYXRzLCBuLmZvcm1hdHMoKSksIHRoaXMuX3BhcnNlT3B0cyA9IHtcbiAgICAgIHBhcnNlcjogcy5wYXJzZXIsXG4gICAgICByb3VuZDogcy5yb3VuZCxcbiAgICAgIGlzb1dlZWtkYXk6IHMuaXNvV2Vla2RheVxuICAgIH0sIHN1cGVyLmluaXQodCksIHRoaXMuX25vcm1hbGl6ZWQgPSBlLm5vcm1hbGl6ZWQ7XG4gIH1cbiAgcGFyc2UodCwgZSkge1xuICAgIHJldHVybiB0ID09PSB2b2lkIDAgPyBudWxsIDogc24odGhpcywgdCk7XG4gIH1cbiAgYmVmb3JlTGF5b3V0KCkge1xuICAgIHN1cGVyLmJlZm9yZUxheW91dCgpLCB0aGlzLl9jYWNoZSA9IHtcbiAgICAgIGRhdGE6IFtdLFxuICAgICAgbGFiZWxzOiBbXSxcbiAgICAgIGFsbDogW11cbiAgICB9O1xuICB9XG4gIGRldGVybWluZURhdGFMaW1pdHMoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMub3B0aW9ucywgZSA9IHRoaXMuX2FkYXB0ZXIsIHMgPSB0LnRpbWUudW5pdCB8fCBcImRheVwiO1xuICAgIGxldCB7IG1pbjogbiwgbWF4OiBvLCBtaW5EZWZpbmVkOiByLCBtYXhEZWZpbmVkOiBhIH0gPSB0aGlzLmdldFVzZXJCb3VuZHMoKTtcbiAgICBmdW5jdGlvbiBsKGMpIHtcbiAgICAgICFyICYmICFpc05hTihjLm1pbikgJiYgKG4gPSBNYXRoLm1pbihuLCBjLm1pbikpLCAhYSAmJiAhaXNOYU4oYy5tYXgpICYmIChvID0gTWF0aC5tYXgobywgYy5tYXgpKTtcbiAgICB9XG4gICAgKCFyIHx8ICFhKSAmJiAobCh0aGlzLl9nZXRMYWJlbEJvdW5kcygpKSwgKHQuYm91bmRzICE9PSBcInRpY2tzXCIgfHwgdC50aWNrcy5zb3VyY2UgIT09IFwibGFiZWxzXCIpICYmIGwodGhpcy5nZXRNaW5NYXgoITEpKSksIG4gPSBOKG4pICYmICFpc05hTihuKSA/IG4gOiArZS5zdGFydE9mKERhdGUubm93KCksIHMpLCBvID0gTihvKSAmJiAhaXNOYU4obykgPyBvIDogK2UuZW5kT2YoRGF0ZS5ub3coKSwgcykgKyAxLCB0aGlzLm1pbiA9IE1hdGgubWluKG4sIG8gLSAxKSwgdGhpcy5tYXggPSBNYXRoLm1heChuICsgMSwgbyk7XG4gIH1cbiAgX2dldExhYmVsQm91bmRzKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmdldExhYmVsVGltZXN0YW1wcygpO1xuICAgIGxldCBlID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCBzID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICAgIHJldHVybiB0Lmxlbmd0aCAmJiAoZSA9IHRbMF0sIHMgPSB0W3QubGVuZ3RoIC0gMV0pLCB7IG1pbjogZSwgbWF4OiBzIH07XG4gIH1cbiAgYnVpbGRUaWNrcygpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5vcHRpb25zLCBlID0gdC50aW1lLCBzID0gdC50aWNrcywgbiA9IHMuc291cmNlID09PSBcImxhYmVsc1wiID8gdGhpcy5nZXRMYWJlbFRpbWVzdGFtcHMoKSA6IHRoaXMuX2dlbmVyYXRlKCk7XG4gICAgdC5ib3VuZHMgPT09IFwidGlja3NcIiAmJiBuLmxlbmd0aCAmJiAodGhpcy5taW4gPSB0aGlzLl91c2VyTWluIHx8IG5bMF0sIHRoaXMubWF4ID0gdGhpcy5fdXNlck1heCB8fCBuW24ubGVuZ3RoIC0gMV0pO1xuICAgIGNvbnN0IG8gPSB0aGlzLm1pbiwgciA9IHRoaXMubWF4LCBhID0gUm8obiwgbywgcik7XG4gICAgcmV0dXJuIHRoaXMuX3VuaXQgPSBlLnVuaXQgfHwgKHMuYXV0b1NraXAgPyBubihlLm1pblVuaXQsIHRoaXMubWluLCB0aGlzLm1heCwgdGhpcy5fZ2V0TGFiZWxDYXBhY2l0eShvKSkgOiBOYyh0aGlzLCBhLmxlbmd0aCwgZS5taW5Vbml0LCB0aGlzLm1pbiwgdGhpcy5tYXgpKSwgdGhpcy5fbWFqb3JVbml0ID0gIXMubWFqb3IuZW5hYmxlZCB8fCB0aGlzLl91bml0ID09PSBcInllYXJcIiA/IHZvaWQgMCA6IEhjKHRoaXMuX3VuaXQpLCB0aGlzLmluaXRPZmZzZXRzKG4pLCB0LnJldmVyc2UgJiYgYS5yZXZlcnNlKCksIHJuKHRoaXMsIGEsIHRoaXMuX21ham9yVW5pdCk7XG4gIH1cbiAgYWZ0ZXJBdXRvU2tpcCgpIHtcbiAgICB0aGlzLm9wdGlvbnMub2Zmc2V0QWZ0ZXJBdXRvc2tpcCAmJiB0aGlzLmluaXRPZmZzZXRzKHRoaXMudGlja3MubWFwKCh0KSA9PiArdC52YWx1ZSkpO1xuICB9XG4gIGluaXRPZmZzZXRzKHQpIHtcbiAgICBsZXQgZSA9IDAsIHMgPSAwLCBuLCBvO1xuICAgIHRoaXMub3B0aW9ucy5vZmZzZXQgJiYgdC5sZW5ndGggJiYgKG4gPSB0aGlzLmdldERlY2ltYWxGb3JWYWx1ZSh0WzBdKSwgdC5sZW5ndGggPT09IDEgPyBlID0gMSAtIG4gOiBlID0gKHRoaXMuZ2V0RGVjaW1hbEZvclZhbHVlKHRbMV0pIC0gbikgLyAyLCBvID0gdGhpcy5nZXREZWNpbWFsRm9yVmFsdWUodFt0Lmxlbmd0aCAtIDFdKSwgdC5sZW5ndGggPT09IDEgPyBzID0gbyA6IHMgPSAobyAtIHRoaXMuZ2V0RGVjaW1hbEZvclZhbHVlKHRbdC5sZW5ndGggLSAyXSkpIC8gMik7XG4gICAgY29uc3QgciA9IHQubGVuZ3RoIDwgMyA/IDAuNSA6IDAuMjU7XG4gICAgZSA9IFkoZSwgMCwgciksIHMgPSBZKHMsIDAsIHIpLCB0aGlzLl9vZmZzZXRzID0geyBzdGFydDogZSwgZW5kOiBzLCBmYWN0b3I6IDEgLyAoZSArIDEgKyBzKSB9O1xuICB9XG4gIF9nZW5lcmF0ZSgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fYWRhcHRlciwgZSA9IHRoaXMubWluLCBzID0gdGhpcy5tYXgsIG4gPSB0aGlzLm9wdGlvbnMsIG8gPSBuLnRpbWUsIHIgPSBvLnVuaXQgfHwgbm4oby5taW5Vbml0LCBlLCBzLCB0aGlzLl9nZXRMYWJlbENhcGFjaXR5KGUpKSwgYSA9IEMoby5zdGVwU2l6ZSwgMSksIGwgPSByID09PSBcIndlZWtcIiA/IG8uaXNvV2Vla2RheSA6ICExLCBjID0gQnQobCkgfHwgbCA9PT0gITAsIGggPSB7fTtcbiAgICBsZXQgZCA9IGUsIHUsIGY7XG4gICAgaWYgKGMgJiYgKGQgPSArdC5zdGFydE9mKGQsIFwiaXNvV2Vla1wiLCBsKSksIGQgPSArdC5zdGFydE9mKGQsIGMgPyBcImRheVwiIDogciksIHQuZGlmZihzLCBlLCByKSA+IDFlNSAqIGEpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZSArIFwiIGFuZCBcIiArIHMgKyBcIiBhcmUgdG9vIGZhciBhcGFydCB3aXRoIHN0ZXBTaXplIG9mIFwiICsgYSArIFwiIFwiICsgcik7XG4gICAgY29uc3QgZyA9IG4udGlja3Muc291cmNlID09PSBcImRhdGFcIiAmJiB0aGlzLmdldERhdGFUaW1lc3RhbXBzKCk7XG4gICAgZm9yICh1ID0gZCwgZiA9IDA7IHUgPCBzOyB1ID0gK3QuYWRkKHUsIGEsIHIpLCBmKyspXG4gICAgICBvbihoLCB1LCBnKTtcbiAgICByZXR1cm4gKHUgPT09IHMgfHwgbi5ib3VuZHMgPT09IFwidGlja3NcIiB8fCBmID09PSAxKSAmJiBvbihoLCB1LCBnKSwgT2JqZWN0LmtleXMoaCkuc29ydCgocCwgbSkgPT4gcCAtIG0pLm1hcCgocCkgPT4gK3ApO1xuICB9XG4gIGdldExhYmVsRm9yVmFsdWUodCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLl9hZGFwdGVyLCBzID0gdGhpcy5vcHRpb25zLnRpbWU7XG4gICAgcmV0dXJuIHMudG9vbHRpcEZvcm1hdCA/IGUuZm9ybWF0KHQsIHMudG9vbHRpcEZvcm1hdCkgOiBlLmZvcm1hdCh0LCBzLmRpc3BsYXlGb3JtYXRzLmRhdGV0aW1lKTtcbiAgfVxuICBfdGlja0Zvcm1hdEZ1bmN0aW9uKHQsIGUsIHMsIG4pIHtcbiAgICBjb25zdCBvID0gdGhpcy5vcHRpb25zLCByID0gby50aW1lLmRpc3BsYXlGb3JtYXRzLCBhID0gdGhpcy5fdW5pdCwgbCA9IHRoaXMuX21ham9yVW5pdCwgYyA9IGEgJiYgclthXSwgaCA9IGwgJiYgcltsXSwgZCA9IHNbZV0sIHUgPSBsICYmIGggJiYgZCAmJiBkLm1ham9yLCBmID0gdGhpcy5fYWRhcHRlci5mb3JtYXQodCwgbiB8fCAodSA/IGggOiBjKSksIGcgPSBvLnRpY2tzLmNhbGxiYWNrO1xuICAgIHJldHVybiBnID8gSShnLCBbZiwgZSwgc10sIHRoaXMpIDogZjtcbiAgfVxuICBnZW5lcmF0ZVRpY2tMYWJlbHModCkge1xuICAgIGxldCBlLCBzLCBuO1xuICAgIGZvciAoZSA9IDAsIHMgPSB0Lmxlbmd0aDsgZSA8IHM7ICsrZSlcbiAgICAgIG4gPSB0W2VdLCBuLmxhYmVsID0gdGhpcy5fdGlja0Zvcm1hdEZ1bmN0aW9uKG4udmFsdWUsIGUsIHQpO1xuICB9XG4gIGdldERlY2ltYWxGb3JWYWx1ZSh0KSB7XG4gICAgcmV0dXJuIHQgPT09IG51bGwgPyBOYU4gOiAodCAtIHRoaXMubWluKSAvICh0aGlzLm1heCAtIHRoaXMubWluKTtcbiAgfVxuICBnZXRQaXhlbEZvclZhbHVlKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5fb2Zmc2V0cywgcyA9IHRoaXMuZ2V0RGVjaW1hbEZvclZhbHVlKHQpO1xuICAgIHJldHVybiB0aGlzLmdldFBpeGVsRm9yRGVjaW1hbCgoZS5zdGFydCArIHMpICogZS5mYWN0b3IpO1xuICB9XG4gIGdldFZhbHVlRm9yUGl4ZWwodCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLl9vZmZzZXRzLCBzID0gdGhpcy5nZXREZWNpbWFsRm9yUGl4ZWwodCkgLyBlLmZhY3RvciAtIGUuZW5kO1xuICAgIHJldHVybiB0aGlzLm1pbiArIHMgKiAodGhpcy5tYXggLSB0aGlzLm1pbik7XG4gIH1cbiAgX2dldExhYmVsU2l6ZSh0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMub3B0aW9ucy50aWNrcywgcyA9IHRoaXMuY3R4Lm1lYXN1cmVUZXh0KHQpLndpZHRoLCBuID0gbnQodGhpcy5pc0hvcml6b250YWwoKSA/IGUubWF4Um90YXRpb24gOiBlLm1pblJvdGF0aW9uKSwgbyA9IE1hdGguY29zKG4pLCByID0gTWF0aC5zaW4obiksIGEgPSB0aGlzLl9yZXNvbHZlVGlja0ZvbnRPcHRpb25zKDApLnNpemU7XG4gICAgcmV0dXJuIHtcbiAgICAgIHc6IHMgKiBvICsgYSAqIHIsXG4gICAgICBoOiBzICogciArIGEgKiBvXG4gICAgfTtcbiAgfVxuICBfZ2V0TGFiZWxDYXBhY2l0eSh0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMub3B0aW9ucy50aW1lLCBzID0gZS5kaXNwbGF5Rm9ybWF0cywgbiA9IHNbZS51bml0XSB8fCBzLm1pbGxpc2Vjb25kLCBvID0gdGhpcy5fdGlja0Zvcm1hdEZ1bmN0aW9uKHQsIDAsIHJuKHRoaXMsIFt0XSwgdGhpcy5fbWFqb3JVbml0KSwgbiksIHIgPSB0aGlzLl9nZXRMYWJlbFNpemUobyksIGEgPSBNYXRoLmZsb29yKHRoaXMuaXNIb3Jpem9udGFsKCkgPyB0aGlzLndpZHRoIC8gci53IDogdGhpcy5oZWlnaHQgLyByLmgpIC0gMTtcbiAgICByZXR1cm4gYSA+IDAgPyBhIDogMTtcbiAgfVxuICBnZXREYXRhVGltZXN0YW1wcygpIHtcbiAgICBsZXQgdCA9IHRoaXMuX2NhY2hlLmRhdGEgfHwgW10sIGUsIHM7XG4gICAgaWYgKHQubGVuZ3RoKVxuICAgICAgcmV0dXJuIHQ7XG4gICAgY29uc3QgbiA9IHRoaXMuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXMoKTtcbiAgICBpZiAodGhpcy5fbm9ybWFsaXplZCAmJiBuLmxlbmd0aClcbiAgICAgIHJldHVybiB0aGlzLl9jYWNoZS5kYXRhID0gblswXS5jb250cm9sbGVyLmdldEFsbFBhcnNlZFZhbHVlcyh0aGlzKTtcbiAgICBmb3IgKGUgPSAwLCBzID0gbi5sZW5ndGg7IGUgPCBzOyArK2UpXG4gICAgICB0ID0gdC5jb25jYXQobltlXS5jb250cm9sbGVyLmdldEFsbFBhcnNlZFZhbHVlcyh0aGlzKSk7XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlLmRhdGEgPSB0aGlzLm5vcm1hbGl6ZSh0KTtcbiAgfVxuICBnZXRMYWJlbFRpbWVzdGFtcHMoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX2NhY2hlLmxhYmVscyB8fCBbXTtcbiAgICBsZXQgZSwgcztcbiAgICBpZiAodC5sZW5ndGgpXG4gICAgICByZXR1cm4gdDtcbiAgICBjb25zdCBuID0gdGhpcy5nZXRMYWJlbHMoKTtcbiAgICBmb3IgKGUgPSAwLCBzID0gbi5sZW5ndGg7IGUgPCBzOyArK2UpXG4gICAgICB0LnB1c2goc24odGhpcywgbltlXSkpO1xuICAgIHJldHVybiB0aGlzLl9jYWNoZS5sYWJlbHMgPSB0aGlzLl9ub3JtYWxpemVkID8gdCA6IHRoaXMubm9ybWFsaXplKHQpO1xuICB9XG4gIG5vcm1hbGl6ZSh0KSB7XG4gICAgcmV0dXJuIHVuKHQuc29ydChXYykpO1xuICB9XG59XG5IdC5pZCA9IFwidGltZVwiO1xuSHQuZGVmYXVsdHMgPSB7XG4gIGJvdW5kczogXCJkYXRhXCIsXG4gIGFkYXB0ZXJzOiB7fSxcbiAgdGltZToge1xuICAgIHBhcnNlcjogITEsXG4gICAgdW5pdDogITEsXG4gICAgcm91bmQ6ICExLFxuICAgIGlzb1dlZWtkYXk6ICExLFxuICAgIG1pblVuaXQ6IFwibWlsbGlzZWNvbmRcIixcbiAgICBkaXNwbGF5Rm9ybWF0czoge31cbiAgfSxcbiAgdGlja3M6IHtcbiAgICBzb3VyY2U6IFwiYXV0b1wiLFxuICAgIG1ham9yOiB7XG4gICAgICBlbmFibGVkOiAhMVxuICAgIH1cbiAgfVxufTtcbmZ1bmN0aW9uIEZlKGksIHQsIGUpIHtcbiAgbGV0IHMgPSAwLCBuID0gaS5sZW5ndGggLSAxLCBvLCByLCBhLCBsO1xuICBlID8gKHQgPj0gaVtzXS5wb3MgJiYgdCA8PSBpW25dLnBvcyAmJiAoeyBsbzogcywgaGk6IG4gfSA9IGZ0KGksIFwicG9zXCIsIHQpKSwgeyBwb3M6IG8sIHRpbWU6IGEgfSA9IGlbc10sIHsgcG9zOiByLCB0aW1lOiBsIH0gPSBpW25dKSA6ICh0ID49IGlbc10udGltZSAmJiB0IDw9IGlbbl0udGltZSAmJiAoeyBsbzogcywgaGk6IG4gfSA9IGZ0KGksIFwidGltZVwiLCB0KSksIHsgdGltZTogbywgcG9zOiBhIH0gPSBpW3NdLCB7IHRpbWU6IHIsIHBvczogbCB9ID0gaVtuXSk7XG4gIGNvbnN0IGMgPSByIC0gbztcbiAgcmV0dXJuIGMgPyBhICsgKGwgLSBhKSAqICh0IC0gbykgLyBjIDogYTtcbn1cbmNsYXNzIFFlIGV4dGVuZHMgSHQge1xuICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgc3VwZXIodCksIHRoaXMuX3RhYmxlID0gW10sIHRoaXMuX21pblBvcyA9IHZvaWQgMCwgdGhpcy5fdGFibGVSYW5nZSA9IHZvaWQgMDtcbiAgfVxuICBpbml0T2Zmc2V0cygpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fZ2V0VGltZXN0YW1wc0ZvclRhYmxlKCksIGUgPSB0aGlzLl90YWJsZSA9IHRoaXMuYnVpbGRMb29rdXBUYWJsZSh0KTtcbiAgICB0aGlzLl9taW5Qb3MgPSBGZShlLCB0aGlzLm1pbiksIHRoaXMuX3RhYmxlUmFuZ2UgPSBGZShlLCB0aGlzLm1heCkgLSB0aGlzLl9taW5Qb3MsIHN1cGVyLmluaXRPZmZzZXRzKHQpO1xuICB9XG4gIGJ1aWxkTG9va3VwVGFibGUodCkge1xuICAgIGNvbnN0IHsgbWluOiBlLCBtYXg6IHMgfSA9IHRoaXMsIG4gPSBbXSwgbyA9IFtdO1xuICAgIGxldCByLCBhLCBsLCBjLCBoO1xuICAgIGZvciAociA9IDAsIGEgPSB0Lmxlbmd0aDsgciA8IGE7ICsrcilcbiAgICAgIGMgPSB0W3JdLCBjID49IGUgJiYgYyA8PSBzICYmIG4ucHVzaChjKTtcbiAgICBpZiAobi5sZW5ndGggPCAyKVxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgeyB0aW1lOiBlLCBwb3M6IDAgfSxcbiAgICAgICAgeyB0aW1lOiBzLCBwb3M6IDEgfVxuICAgICAgXTtcbiAgICBmb3IgKHIgPSAwLCBhID0gbi5sZW5ndGg7IHIgPCBhOyArK3IpXG4gICAgICBoID0gbltyICsgMV0sIGwgPSBuW3IgLSAxXSwgYyA9IG5bcl0sIE1hdGgucm91bmQoKGggKyBsKSAvIDIpICE9PSBjICYmIG8ucHVzaCh7IHRpbWU6IGMsIHBvczogciAvIChhIC0gMSkgfSk7XG4gICAgcmV0dXJuIG87XG4gIH1cbiAgX2dldFRpbWVzdGFtcHNGb3JUYWJsZSgpIHtcbiAgICBsZXQgdCA9IHRoaXMuX2NhY2hlLmFsbCB8fCBbXTtcbiAgICBpZiAodC5sZW5ndGgpXG4gICAgICByZXR1cm4gdDtcbiAgICBjb25zdCBlID0gdGhpcy5nZXREYXRhVGltZXN0YW1wcygpLCBzID0gdGhpcy5nZXRMYWJlbFRpbWVzdGFtcHMoKTtcbiAgICByZXR1cm4gZS5sZW5ndGggJiYgcy5sZW5ndGggPyB0ID0gdGhpcy5ub3JtYWxpemUoZS5jb25jYXQocykpIDogdCA9IGUubGVuZ3RoID8gZSA6IHMsIHQgPSB0aGlzLl9jYWNoZS5hbGwgPSB0LCB0O1xuICB9XG4gIGdldERlY2ltYWxGb3JWYWx1ZSh0KSB7XG4gICAgcmV0dXJuIChGZSh0aGlzLl90YWJsZSwgdCkgLSB0aGlzLl9taW5Qb3MpIC8gdGhpcy5fdGFibGVSYW5nZTtcbiAgfVxuICBnZXRWYWx1ZUZvclBpeGVsKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5fb2Zmc2V0cywgcyA9IHRoaXMuZ2V0RGVjaW1hbEZvclBpeGVsKHQpIC8gZS5mYWN0b3IgLSBlLmVuZDtcbiAgICByZXR1cm4gRmUodGhpcy5fdGFibGUsIHMgKiB0aGlzLl90YWJsZVJhbmdlICsgdGhpcy5fbWluUG9zLCAhMCk7XG4gIH1cbn1cblFlLmlkID0gXCJ0aW1lc2VyaWVzXCI7XG5RZS5kZWZhdWx0cyA9IEh0LmRlZmF1bHRzO1xudmFyIHhvID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIENhdGVnb3J5U2NhbGU6IGNlLFxuICBMaW5lYXJTY2FsZTogR2UsXG4gIExvZ2FyaXRobWljU2NhbGU6IFplLFxuICBSYWRpYWxMaW5lYXJTY2FsZTogTnQsXG4gIFRpbWVTY2FsZTogSHQsXG4gIFRpbWVTZXJpZXNTY2FsZTogUWVcbn0pO1xuY29uc3QgJGMgPSBbXG4gIFduLFxuICBvbyxcbiAgbW8sXG4gIHhvXG5dLCBZYyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZGVmaW5lUHJvcGVydHkoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIEFuaW1hdGlvbjogSW4sXG4gIEFuaW1hdGlvbnM6IE5pLFxuICBBcmNFbGVtZW50OiB5ZSxcbiAgQmFyQ29udHJvbGxlcjogdWUsXG4gIEJhckVsZW1lbnQ6IE1lLFxuICBCYXNlUGxhdGZvcm06IEhpLFxuICBCYXNpY1BsYXRmb3JtOiBZbixcbiAgQnViYmxlQ29udHJvbGxlcjogZmUsXG4gIENhdGVnb3J5U2NhbGU6IGNlLFxuICBDaGFydDogamksXG4gIERhdGFzZXRDb250cm9sbGVyOiBpdCxcbiAgRGVjaW1hdGlvbjogYW8sXG4gIERvbVBsYXRmb3JtOiBLbixcbiAgRG91Z2hudXRDb250cm9sbGVyOiBMdCxcbiAgRWxlbWVudDogc3QsXG4gIEZpbGxlcjogaG8sXG4gIEludGVyYWN0aW9uOiBIbixcbiAgTGVnZW5kOiB1byxcbiAgTGluZUNvbnRyb2xsZXI6IGdlLFxuICBMaW5lRWxlbWVudDogZ3QsXG4gIExpbmVhclNjYWxlOiBHZSxcbiAgTG9nYXJpdGhtaWNTY2FsZTogWmUsXG4gIFBpZUNvbnRyb2xsZXI6IHFlLFxuICBQb2ludEVsZW1lbnQ6IHZlLFxuICBQb2xhckFyZWFDb250cm9sbGVyOiBwZSxcbiAgUmFkYXJDb250cm9sbGVyOiBtZSxcbiAgUmFkaWFsTGluZWFyU2NhbGU6IE50LFxuICBTY2FsZTogTXQsXG4gIFNjYXR0ZXJDb250cm9sbGVyOiB4ZSxcbiAgU3ViVGl0bGU6IGdvLFxuICBUaWNrczogYmUsXG4gIFRpbWVTY2FsZTogSHQsXG4gIFRpbWVTZXJpZXNTY2FsZTogUWUsXG4gIFRpdGxlOiBmbyxcbiAgVG9vbHRpcDogcG8sXG4gIF9hZGFwdGVyczogTm4sXG4gIF9kZXRlY3RQbGF0Zm9ybTogcW4sXG4gIGFuaW1hdG9yOiBhdCxcbiAgY29udHJvbGxlcnM6IFduLFxuICBkZWZhdWx0czogTyxcbiAgZWxlbWVudHM6IG9vLFxuICBsYXlvdXRzOiBYLFxuICBwbHVnaW5zOiBtbyxcbiAgcmVnaXN0ZXJhYmxlczogJGMsXG4gIHJlZ2lzdHJ5OiBvdCxcbiAgc2NhbGVzOiB4b1xufSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiBcIk1vZHVsZVwiIH0pKTtcbmV4cG9ydCB7XG4gIHllIGFzIEEsXG4gIE1lIGFzIEIsXG4gIHZlIGFzIFAsXG4gIEsgYXMgYSxcbiAgRCBhcyBiLFxuICBJIGFzIGMsXG4gIE8gYXMgZCxcbiAgRSBhcyBlLFxuICBZYyBhcyBmLFxuICBUIGFzIGksXG4gIG5lIGFzIG0sXG4gIFp0IGFzIHIsXG4gICQgYXMgdCxcbiAgQyBhcyB2XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hhcnQuZXMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=